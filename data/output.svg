<?xml version="1.0"?>
<svg version="1.1" viewBox="0 0 49979.0004199916 83300" width="49979.0004199916" height="83300" xml:space="preserve" style="font-family: 'Source Code Pro'; font-size: 1px; font-weight: 900; white-space: normal;" xmlns="http://www.w3.org/2000/svg">
  <text x="0" y="0" fill="rgb(255 255 255)">import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if t</text>
  <text x="0" y="1" fill="rgb(255 255 255)">here is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightErr</text>
  <text x="0" y="2" fill="rgb(255 255 255)">or(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } f</text>
  <text x="0" y="3" fill="rgb(255 255 255)">or (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.include</text>
  <text x="0" y="4" fill="rgb(255 255 255)">s(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Arra</text>
  <text x="0" y="5" fill="rgb(255 255 255)">y.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = O</text>
  <text x="0" y="6" fill="rgb(255 255 255)">bject.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { </text>
  <text x="0" y="7" fill="rgb(255 255 255)">throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.valida</text>
  <text x="0" y="8" fill="rgb(255 255 255)">teFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: strin</text>
  <text x="0" y="9" fill="rgb(255 255 255)">g[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = [</text>
  <text x="0" y="10" fill="rgb(255 255 255)">]; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (l</text>
  <text x="0" y="11" fill="rgb(255 255 255)">et key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || apply</text>
  <text x="0" y="12" fill="rgb(255 255 255)">key.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public vali</text>
  <text x="0" y="13" fill="rgb(255 255 255)">dateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.d</text>
  <text x="0" y="14" fill="rgb(255 255 255)">ir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); brea</text>
  <text x="0" y="15" fill="rgb(255 255 255)">k; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== </text>
  <text x="0" y="16" fill="rgb(255 255 255)">&amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (i</text>
  <text x="0" y="17" fill="rgb(255 255 255)">nsightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;</text>
  <text x="0" y="18" fill="rgb(255 255 255)">]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIO</text>
  <text x="0" y="19" fill="rgb(255 255 255)">NS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2)</text>
  <text x="0" y="20" fill="rgb(255 255 255)"> { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken:</text>
  <text x="0" y="21" fill="rgb(255 255 255)"> string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } pr</text>
  <text x="0" y="22" fill="rgb(255 255 255)">ivate validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new In</text>
  <text x="0" y="23" fill="rgb(255 255 255)">sightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;</text>
  <text x="0" y="24" fill="rgb(255 255 255)">) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = </text>
  <text x="0" y="25" fill="rgb(255 255 255)">mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { ret</text>
  <text x="0" y="26" fill="rgb(255 255 255)">urn this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in col</text>
  <text x="0" y="27" fill="rgb(255 255 255)">umns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP </text>
  <text x="0" y="28" fill="rgb(255 255 255)">=== &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.i</text>
  <text x="0" y="29" fill="rgb(255 255 255)">sArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(</text>
  <text x="0" y="30" fill="rgb(255 255 255)">); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { thi</text>
  <text x="0" y="31" fill="rgb(255 255 255)">s.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).le</text>
  <text x="0" y="32" fill="rgb(255 255 255)">ngth !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0</text>
  <text x="0" y="33" fill="rgb(255 255 255)">]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArra</text>
  <text x="0" y="34" fill="rgb(255 255 255)">y(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly c</text>
  <text x="0" y="35" fill="rgb(255 255 255)">oursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(ins</text>
  <text x="0" y="36" fill="rgb(255 255 255)">ightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length</text>
  <text x="0" y="37" fill="rgb(255 255 255)"> &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: st</text>
  <text x="0" y="38" fill="rgb(255 255 255)">ring = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfie</text>
  <text x="0" y="39" fill="rgb(255 255 255)">lds.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError()</text>
  <text x="0" y="40" fill="rgb(255 255 255)">; } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; cas</text>
  <text x="0" y="41" fill="rgb(255 255 255)">e &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfiel</text>
  <text x="0" y="42" fill="rgb(255 255 255)">d)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset</text>
  <text x="0" y="43" fill="rgb(255 255 255)"> of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roo</text>
  <text x="0" y="44" fill="rgb(255 255 255)">msfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError()</text>
  <text x="0" y="45" fill="rgb(255 255 255)">; } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private va</text>
  <text x="0" y="46" fill="rgb(255 255 255)">lidateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Ar</text>
  <text x="0" y="47" fill="rgb(255 255 255)">ray.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new</text>
  <text x="0" y="48" fill="rgb(255 255 255)"> InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw</text>
  <text x="0" y="49" fill="rgb(255 255 255)"> new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError</text>
  <text x="0" y="50" fill="rgb(255 255 255)">(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.</text>
  <text x="0" y="51" fill="rgb(255 255 255)">length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mf</text>
  <text x="0" y="52" fill="rgb(255 255 255)">ields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: str</text>
  <text x="0" y="53" fill="rgb(255 255 255)">ing[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS);</text>
  <text x="0" y="54" fill="rgb(255 255 255)"> } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includ</text>
  <text x="0" y="55" fill="rgb(255 255 255)">es(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError()</text>
  <text x="0" y="56" fill="rgb(255 255 255)">; } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationK</text>
  <text x="0" y="57" fill="rgb(255 255 255)">ey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).le</text>
  <text x="0" y="58" fill="rgb(255 255 255)">ngth !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[</text>
  <text x="0" y="59" fill="rgb(255 255 255)">0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.include</text>
  <text x="0" y="60" fill="rgb(255 255 255)">s(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightData</text>
  <text x="0" y="61" fill="rgb(255 255 255)">setKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private al</text>
  <text x="0" y="62" fill="rgb(255 255 255)">lInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP)</text>
  <text x="0" y="63" fill="rgb(255 255 255)">; this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array</text>
  <text x="0" y="64" fill="rgb(255 255 255)">.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightErro</text>
  <text x="0" y="65" fill="rgb(255 255 255)">r(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightEr</text>
  <text x="0" y="66" fill="rgb(255 255 255)">ror(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { </text>
  <text x="0" y="67" fill="rgb(255 255 255)">case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { </text>
  <text x="0" y="68" fill="rgb(255 255 255)">if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private </text>
  <text x="0" y="69" fill="rgb(255 255 255)">validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, </text>
  <text x="0" y="70" fill="rgb(255 255 255)">&amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insight</text>
  <text x="0" y="71" fill="rgb(255 255 255)">Datasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key</text>
  <text x="0" y="72" fill="rgb(255 255 255)">); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transform</text>
  <text x="0" y="73" fill="rgb(255 255 255)">ationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let key</text>
  <text x="0" y="74" fill="rgb(255 255 255)">s: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { </text>
  <text x="0" y="75" fill="rgb(255 255 255)">throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(</text>
  <text x="0" y="76" fill="rgb(255 255 255)">); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).leng</text>
  <text x="0" y="77" fill="rgb(255 255 255)">th !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatas</text>
  <text x="0" y="78" fill="rgb(255 255 255)">etKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[</text>
  <text x="0" y="79" fill="rgb(255 255 255)">] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } </text>
  <text x="0" y="80" fill="rgb(255 255 255)">} this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (</text>
  <text x="0" y="81" fill="rgb(255 255 255)">!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0];</text>
  <text x="0" y="82" fill="rgb(255 255 255)"> if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void</text>
  <text x="0" y="83" fill="rgb(255 255 255)"> { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public valida</text>
  <text x="0" y="84" fill="rgb(255 255 255)">teWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if </text>
  <text x="0" y="85" fill="rgb(255 255 255)">(Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.valu</text>
  <text x="0" y="86" fill="rgb(255 255 255)">es(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstrin</text>
  <text x="0" y="87" fill="rgb(255 255 255)">g); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private </text>
  <text x="0" y="88" fill="rgb(255 255 255)">transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY =</text>
  <text x="0" y="89" fill="rgb(255 255 255)">== &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError</text>
  <text x="0" y="90" fill="rgb(255 255 255)">(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(apply</text>
  <text x="0" y="91" fill="rgb(255 255 255)">token)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder</text>
  <text x="538" y="91" fill="rgb(237 28 36)">(q.ORDER); } } private validat</text>
  <text x="568" y="91" fill="rgb(255 255 255)">eColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysIn</text>
  <text x="0" y="92" fill="rgb(255 255 255)">Query.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.include</text>
  <text x="530" y="92" fill="rgb(237 28 36)">s(anykey)) { throw new InsightError(); } } } </text>
  <text x="575" y="92" fill="rgb(255 255 255)">} public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightErro</text>
  <text x="0" y="93" fill="rgb(255 255 255)">r(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void</text>
  <text x="523" y="93" fill="rgb(237 28 36)"> { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightErro</text>
  <text x="580" y="93" fill="rgb(255 255 255)">r(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; le</text>
  <text x="0" y="94" fill="rgb(255 255 255)">t str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: st</text>
  <text x="518" y="94" fill="rgb(237 28 36)">ring = mkey[0]; let mfield: string = mkey[1]; let num: any = Objec</text>
  <text x="584" y="94" fill="rgb(255 255 255)">t.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { thr</text>
  <text x="0" y="95" fill="rgb(255 255 255)">ow new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } re</text>
  <text x="514" y="95" fill="rgb(237 28 36)">turn true; } } return false; } else { return this.idInQuery.includes(idst</text>
  <text x="587" y="95" fill="rgb(255 255 255)">ring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;p</text>
  <text x="0" y="96" fill="rgb(255 255 255)">ass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keys</text>
  <text x="509" y="96" fill="rgb(237 28 36)">InQuery: string[]; // all keys appeared in columns after being validated private t</text>
  <text x="591" y="96" fill="rgb(255 255 255)">ransformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { t</text>
  <text x="0" y="97" fill="rgb(255 255 255)">his.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTr</text>
  <text x="506" y="97" fill="rgb(237 28 36)">ansformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === </text>
  <text x="593" y="97" fill="rgb(255 255 255)">&amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); /</text>
  <text x="0" y="98" fill="rgb(255 255 255)">/ q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } </text>
  <text x="503" y="98" fill="rgb(237 28 36)">} private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); //</text>
  <text x="596" y="98" fill="rgb(255 255 255)"> q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; l</text>
  <text x="0" y="99" fill="rgb(255 255 255)">et criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken))</text>
  <text x="424" y="99" fill="rgb(237 28 36)"> {</text>
  <text x="426" y="99" fill="rgb(255 255 255)"> throw new InsightError(); } let key: string[] = criteria[applytoken].spl</text>
  <text x="499" y="99" fill="rgb(237 28 36)">it(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) {</text>
  <text x="599" y="99" fill="rgb(255 255 255)"> if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfield</text>
  <text x="0" y="100" fill="rgb(255 255 255)">s.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey </text>
  <text x="419" y="100" fill="rgb(237 28 36)">of q) {</text>
  <text x="426" y="100" fill="rgb(255 255 255)"> if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.i</text>
  <text x="497" y="100" fill="rgb(237 28 36)">ncludes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(</text>
  <text x="601" y="100" fill="rgb(255 255 255)">mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys </text>
  <text x="0" y="101" fill="rgb(255 255 255)">|| Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightErr</text>
  <text x="415" y="101" fill="rgb(237 28 36)">or(); } el</text>
  <text x="425" y="101" fill="rgb(255 255 255)">se { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } }</text>
  <text x="494" y="101" fill="rgb(237 28 36)"> private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else {</text>
  <text x="603" y="101" fill="rgb(255 255 255)"> let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.</text>
  <text x="0" y="102" fill="rgb(255 255 255)">validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); }</text>
  <text x="410" y="102" fill="rgb(237 28 36)"> let skey: str</text>
  <text x="424" y="102" fill="rgb(255 255 255)">ing[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { </text>
  <text x="491" y="102" fill="rgb(237 28 36)">throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Ob</text>
  <text x="605" y="102" fill="rgb(255 255 255)">ject.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } }</text>
  <text x="0" y="103" fill="rgb(255 255 255)"> } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.valida</text>
  <text x="406" y="103" fill="rgb(237 28 36)">teIdstring(idstr</text>
  <text x="422" y="103" fill="rgb(255 255 255)">ing) || !this.mfields.includes(mfield)) { throw new InsightError();</text>
  <text x="489" y="103" fill="rgb(237 28 36)"> } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightErr</text>
  <text x="607" y="103" fill="rgb(255 255 255)">or(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (i</text>
  <text x="0" y="104" fill="rgb(255 255 255)">nsightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.i</text>
  <text x="402" y="104" fill="rgb(237 28 36)">dInQuery; } } impor</text>
  <text x="421" y="104" fill="rgb(255 255 255)">t {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsi</text>
  <text x="487" y="104" fill="rgb(237 28 36)">ghtFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audi</text>
  <text x="609" y="104" fill="rgb(255 255 255)">t&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;</text>
  <text x="0" y="105" fill="rgb(255 255 255)">shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in tr</text>
  <text x="398" y="105" fill="rgb(237 28 36)">ansformation, if there</text>
  <text x="420" y="105" fill="rgb(255 255 255)"> is a transformation private allInsightDataset: InsightDataset[]</text>
  <text x="484" y="105" fill="rgb(237 28 36)">; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; t</text>
  <text x="611" y="105" fill="rgb(255 255 255)">his.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q))</text>
  <text x="0" y="106" fill="rgb(255 255 255)"> { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) </text>
  <text x="394" y="106" fill="rgb(237 28 36)">{ throw new InsightError(</text>
  <text x="419" y="106" fill="rgb(255 255 255)">); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); </text>
  <text x="482" y="106" fill="rgb(237 28 36)">} private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object</text>
  <text x="613" y="106" fill="rgb(255 255 255)">, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let </text>
  <text x="0" y="107" fill="rgb(255 255 255)">splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should hav</text>
  <text x="390" y="107" fill="rgb(237 28 36)">e at least one element } for</text>
  <text x="418" y="107" fill="rgb(255 255 255)"> (let applyrule of q) { if (Array.isArray(applyrule) || Object</text>
  <text x="480" y="107" fill="rgb(237 28 36)">.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[a</text>
  <text x="615" y="107" fill="rgb(255 255 255)">pplykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.key</text>
  <text x="0" y="108" fill="rgb(255 255 255)">s(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(k</text>
  <text x="386" y="108" fill="rgb(237 28 36)">ey[0]) &amp;amp;&amp;amp; this.mfields.includes</text>
  <text x="417" y="108" fill="rgb(255 255 255)">(key[1]))) { throw new InsightError(); } } else if (this.msto</text>
  <text x="478" y="108" fill="rgb(237 28 36)">ken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { th</text>
  <text x="616" y="108" fill="rgb(255 255 255)">row new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateC</text>
  <text x="0" y="109" fill="rgb(255 255 255)">olumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private vali</text>
  <text x="382" y="109" fill="rgb(237 28 36)">dateOrder(q: any): void { if (Arr</text>
  <text x="415" y="109" fill="rgb(255 255 255)">ay.isArray(q)) { throw new InsightError(); } else if (typeof </text>
  <text x="476" y="109" fill="rgb(237 28 36)">q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !==</text>
  <text x="618" y="109" fill="rgb(255 255 255)"> 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let any</text>
  <text x="0" y="110" fill="rgb(255 255 255)">key of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string =</text>
  <text x="378" y="110" fill="rgb(237 28 36)"> Object.keys(q)[0]; let value: any =</text>
  <text x="414" y="110" fill="rgb(255 255 255)"> Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: </text>
  <text x="474" y="110" fill="rgb(237 28 36)">this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; </text>
  <text x="620" y="110" fill="rgb(255 255 255)">case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); }</text>
  <text x="0" y="111" fill="rgb(255 255 255)"> private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(</text>
  <text x="374" y="111" fill="rgb(237 28 36)">value)[0]; if (typeof str !== &amp;quot;string&amp;quot;)</text>
  <text x="413" y="111" fill="rgb(255 255 255)"> { throw new InsightError(); } else { if ((str.slice(1, -1)</text>
  <text x="472" y="111" fill="rgb(237 28 36)">.includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(val</text>
  <text x="621" y="111" fill="rgb(255 255 255)">ue: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightEr</text>
  <text x="0" y="112" fill="rgb(255 255 255)">ror(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); </text>
  <text x="370" y="112" fill="rgb(237 28 36)">} for (let innerObject of value) { this.va</text>
  <text x="412" y="112" fill="rgb(255 255 255)">lidateFilter(innerObject); } } private validateIdstring(id</text>
  <text x="470" y="112" fill="rgb(237 28 36)">string: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { </text>
  <text x="623" y="112" fill="rgb(255 255 255)">this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfie</text>
  <text x="0" y="113" fill="rgb(255 255 255)">lds = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audi</text>
  <text x="366" y="113" fill="rgb(237 28 36)">t&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: </text>
  <text x="411" y="113" fill="rgb(255 255 255)">string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; </text>
  <text x="469" y="113" fill="rgb(237 28 36)">private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;ad</text>
  <text x="624" y="113" fill="rgb(255 255 255)">dress&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only </text>
  <text x="0" y="114" fill="rgb(255 255 255)">has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery =</text>
  <text x="362" y="114" fill="rgb(237 28 36)"> []; this.keysInQuery = []; this.transformationK</text>
  <text x="410" y="114" fill="rgb(255 255 255)">ey = []; this.allInsightDataset = insightDatasets; } publ</text>
  <text x="467" y="114" fill="rgb(237 28 36)">ic validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== </text>
  <text x="626" y="114" fill="rgb(255 255 255)">&amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS);</text>
  <text x="0" y="115" fill="rgb(255 255 255)"> } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should </text>
  <text x="358" y="115" fill="rgb(237 28 36)">be an object, and should has at least one element }</text>
  <text x="409" y="115" fill="rgb(255 255 255)"> for (let key of q) { this.validateKey(key); this.transf</text>
  <text x="465" y="115" fill="rgb(237 28 36)">ormationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;</text>
  <text x="627" y="115" fill="rgb(255 255 255)">); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new I</text>
  <text x="0" y="116" fill="rgb(255 255 255)">nsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let crit</text>
  <text x="354" y="116" fill="rgb(237 28 36)">eria = applyrule[applykey]; if (applykey.length === 0</text>
  <text x="407" y="116" fill="rgb(255 255 255)"> || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.incl</text>
  <text x="464" y="116" fill="rgb(237 28 36)">udes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new In</text>
  <text x="628" y="116" fill="rgb(255 255 255)">sightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[ap</text>
  <text x="0" y="117" fill="rgb(255 255 255)">plytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.in</text>
  <text x="351" y="117" fill="rgb(237 28 36)">cludes(key[1])))) { throw new InsightError(); } } } } p</text>
  <text x="406" y="117" fill="rgb(255 255 255)">ublic validateOptions(q: any): void { let keys: any[] = </text>
  <text x="462" y="117" fill="rgb(237 28 36)">Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.v</text>
  <text x="630" y="117" fill="rgb(255 255 255)">alidateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transfor</text>
  <text x="0" y="118" fill="rgb(255 255 255)">mationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys </text>
  <text x="347" y="118" fill="rgb(237 28 36)">|| Object.keys(q).length !== 2) { throw new InsightError()</text>
  <text x="405" y="118" fill="rgb(255 255 255)">; } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new</text>
  <text x="460" y="118" fill="rgb(237 28 36)"> InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.incl</text>
  <text x="631" y="118" fill="rgb(255 255 255)">udes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q</text>
  <text x="0" y="119" fill="rgb(255 255 255)">); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: t</text>
  <text x="343" y="119" fill="rgb(237 28 36)">his.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(</text>
  <text x="404" y="119" fill="rgb(255 255 255)">value); break; default: throw new InsightError(); } } }</text>
  <text x="459" y="119" fill="rgb(237 28 36)"> private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if</text>
  <text x="632" y="119" fill="rgb(255 255 255)"> (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== </text>
  <text x="0" y="120" fill="rgb(255 255 255)">2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError</text>
  <text x="340" y="120" fill="rgb(237 28 36)">(); } } } } private validateGTLTEQ(value: any): void { if (type</text>
  <text x="403" y="120" fill="rgb(255 255 255)">of value !== &amp;quot;object&amp;quot; || Object.keys(value).length !==</text>
  <text x="457" y="120" fill="rgb(237 28 36)"> 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey</text>
  <text x="633" y="120" fill="rgb(255 255 255)">[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError</text>
  <text x="0" y="121" fill="rgb(255 255 255)">(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDatas</text>
  <text x="336" y="121" fill="rgb(237 28 36)">et) { if (insightDataset.id === idstring) { this.idInQuery.push(id</text>
  <text x="402" y="121" fill="rgb(255 255 255)">string); if (insightDataset.kind === InsightDatasetKin</text>
  <text x="456" y="121" fill="rgb(237 28 36)">d.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } re</text>
  <text x="635" y="121" fill="rgb(255 255 255)">turn false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IIns</text>
  <text x="0" y="122" fill="rgb(255 255 255)">ightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = </text>
  <text x="333" y="122" fill="rgb(237 28 36)">[&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;fur</text>
  <text x="401" y="122" fill="rgb(255 255 255)">niture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] =</text>
  <text x="454" y="122" fill="rgb(237 28 36)"> [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // a</text>
  <text x="636" y="122" fill="rgb(255 255 255)">ll keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; </text>
  <text x="0" y="123" fill="rgb(255 255 255)">private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key </text>
  <text x="329" y="123" fill="rgb(237 28 36)">of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !</text>
  <text x="399" y="123" fill="rgb(255 255 255)">== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } </text>
  <text x="453" y="123" fill="rgb(237 28 36)">this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void</text>
  <text x="637" y="123" fill="rgb(255 255 255)"> { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } pr</text>
  <text x="0" y="124" fill="rgb(255 255 255)">ivate validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key:</text>
  <text x="326" y="124" fill="rgb(237 28 36)"> string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splitte</text>
  <text x="398" y="124" fill="rgb(255 255 255)">dKey.length !== 2) { throw new InsightError(); } if (</text>
  <text x="451" y="124" fill="rgb(237 28 36)">!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any)</text>
  <text x="638" y="124" fill="rgb(255 255 255)">: void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(</text>
  <text x="0" y="125" fill="rgb(255 255 255)">applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArra</text>
  <text x="322" y="125" fill="rgb(237 28 36)">y(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError()</text>
  <text x="397" y="125" fill="rgb(255 255 255)">; } let applytoken: string = Object.keys(criteria)[0]</text>
  <text x="450" y="125" fill="rgb(237 28 36)">; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { thr</text>
  <text x="639" y="125" fill="rgb(255 255 255)">ow new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.incl</text>
  <text x="0" y="126" fill="rgb(255 255 255)">udes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new Insigh</text>
  <text x="319" y="126" fill="rgb(237 28 36)">tError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOr</text>
  <text x="396" y="126" fill="rgb(255 255 255)">der(q.ORDER); } } private validateColumns(q: any): v</text>
  <text x="448" y="126" fill="rgb(237 28 36)">oid { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightErro</text>
  <text x="640" y="126" fill="rgb(255 255 255)">r(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;str</text>
  <text x="0" y="127" fill="rgb(255 255 255)">ing&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw ne</text>
  <text x="315" y="127" fill="rgb(237 28 36)">w InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(an</text>
  <text x="395" y="127" fill="rgb(255 255 255)">ykey)) { throw new InsightError(); } } } } public va</text>
  <text x="447" y="127" fill="rgb(237 28 36)">lidateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if </text>
  <text x="641" y="127" fill="rgb(255 255 255)">(Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validat</text>
  <text x="0" y="128" fill="rgb(255 255 255)">eANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError</text>
  <text x="312" y="128" fill="rgb(237 28 36)">(); } this.validateFilter(value); } private validateIS(value: any): void { if (typ</text>
  <text x="394" y="128" fill="rgb(255 255 255)">eof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); </text>
  <text x="446" y="128" fill="rgb(237 28 36)">} if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring</text>
  <text x="642" y="128" fill="rgb(255 255 255)">: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)</text>
  <text x="0" y="129" fill="rgb(255 255 255)">) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mk</text>
  <text x="309" y="129" fill="rgb(237 28 36)">ey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]</text>
  <text x="393" y="129" fill="rgb(255 255 255)">; let mfield: string = mkey[1]; let num: any = Obje</text>
  <text x="444" y="129" fill="rgb(237 28 36)">ct.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { i</text>
  <text x="643" y="129" fill="rgb(255 255 255)">f (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string):</text>
  <text x="0" y="130" fill="rgb(255 255 255)"> boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { t</text>
  <text x="306" y="130" fill="rgb(237 28 36)">his.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } r</text>
  <text x="391" y="130" fill="rgb(255 255 255)">eturn false; } else { return this.idInQuery.includes</text>
  <text x="443" y="130" fill="rgb(237 28 36)">(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { pri</text>
  <text x="644" y="130" fill="rgb(255 255 255)">vate readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly </text>
  <text x="0" y="131" fill="rgb(255 255 255)">roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idIn</text>
  <text x="302" y="131" fill="rgb(237 28 36)">Query: string[]; // make sure the query only has one id private keysInQuery: string[]; /</text>
  <text x="390" y="131" fill="rgb(255 255 255)">/ all keys appeared in columns after being validate</text>
  <text x="441" y="131" fill="rgb(237 28 36)">d private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; c</text>
  <text x="645" y="131" fill="rgb(255 255 255)">onstructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any)</text>
  <text x="0" y="132" fill="rgb(255 255 255)">: void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRAN</text>
  <text x="299" y="132" fill="rgb(237 28 36)">SFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any):</text>
  <text x="389" y="132" fill="rgb(255 255 255)"> void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeo</text>
  <text x="440" y="132" fill="rgb(237 28 36)">f q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q</text>
  <text x="646" y="132" fill="rgb(255 255 255)">) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key)</text>
  <text x="0" y="133" fill="rgb(255 255 255)">; // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || thi</text>
  <text x="296" y="133" fill="rgb(237 28 36)">s.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(</text>
  <text x="388" y="133" fill="rgb(255 255 255)">q: any): void { if (!Array.isArray(q)) { throw new </text>
  <text x="439" y="133" fill="rgb(237 28 36)">InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let </text>
  <text x="647" y="133" fill="rgb(255 255 255)">applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { thro</text>
  <text x="0" y="134" fill="rgb(255 255 255)">w new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw</text>
  <text x="293" y="134" fill="rgb(237 28 36)"> new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !==</text>
  <text x="387" y="134" fill="rgb(255 255 255)"> 2) { throw new InsightError(); } if (this.mtoken.</text>
  <text x="437" y="134" fill="rgb(237 28 36)">includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp;</text>
  <text x="648" y="134" fill="rgb(255 255 255)"> (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let</text>
  <text x="0" y="135" fill="rgb(255 255 255)"> key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if</text>
  <text x="290" y="135" fill="rgb(237 28 36)"> (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new </text>
  <text x="386" y="135" fill="rgb(255 255 255)">InsightError(); } } else { this.validateKey(mskey)</text>
  <text x="436" y="135" fill="rgb(237 28 36)">; } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new Insi</text>
  <text x="649" y="135" fill="rgb(255 255 255)">ghtError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let key</text>
  <text x="0" y="136" fill="rgb(255 255 255)">s: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } els</text>
  <text x="287" y="136" fill="rgb(237 28 36)">e { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any</text>
  <text x="385" y="136" fill="rgb(255 255 255)">): void { if (Object.keys(q).length !== 1) { throw</text>
  <text x="435" y="136" fill="rgb(237 28 36)"> new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); b</text>
  <text x="650" y="136" fill="rgb(255 255 255)">reak; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value:</text>
  <text x="0" y="137" fill="rgb(255 255 255)"> any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: st</text>
  <text x="284" y="137" fill="rgb(237 28 36)">ring[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else</text>
  <text x="384" y="137" fill="rgb(255 255 255)"> { let idstring: string = skey[0]; let sfield: st</text>
  <text x="433" y="137" fill="rgb(237 28 36)">ring = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includ</text>
  <text x="651" y="137" fill="rgb(255 255 255)">es(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(</text>
  <text x="0" y="138" fill="rgb(255 255 255)">); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idst</text>
  <text x="282" y="138" fill="rgb(237 28 36)">ring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(valu</text>
  <text x="383" y="138" fill="rgb(255 255 255)">e: any): void { if (!Array.isArray(value) || valu</text>
  <text x="432" y="138" fill="rgb(237 28 36)">e.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insight</text>
  <text x="652" y="138" fill="rgb(255 255 255)">Dataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = th</text>
  <text x="0" y="139" fill="rgb(255 255 255)">is.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } im</text>
  <text x="279" y="139" fill="rgb(237 28 36)">port {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class Q</text>
  <text x="382" y="139" fill="rgb(255 255 255)">ueryValidator { private readonly coursemfields: s</text>
  <text x="431" y="139" fill="rgb(237 28 36)">tring[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readon</text>
  <text x="653" y="139" fill="rgb(255 255 255)">ly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; p</text>
  <text x="0" y="140" fill="rgb(255 255 255)">rivate readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if </text>
  <text x="276" y="140" fill="rgb(237 28 36)">there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private</text>
  <text x="381" y="140" fill="rgb(255 255 255)"> sfields: string[]; constructor(insightDatasets: </text>
  <text x="430" y="140" fill="rgb(237 28 36)">InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightEr</text>
  <text x="654" y="140" fill="rgb(255 255 255)">ror(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (</text>
  <text x="0" y="141" fill="rgb(255 255 255)">q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new Insight</text>
  <text x="274" y="141" fill="rgb(237 28 36)">Error(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void</text>
  <text x="380" y="141" fill="rgb(255 255 255)"> { if (!Array.isArray(q) || q.length &amp;lt; 1) { thro</text>
  <text x="428" y="141" fill="rgb(237 28 36)">w new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } priva</text>
  <text x="654" y="141" fill="rgb(255 255 255)">te validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey</text>
  <text x="0" y="142" fill="rgb(255 255 255)">[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one eleme</text>
  <text x="271" y="142" fill="rgb(237 28 36)">nt } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw n</text>
  <text x="379" y="142" fill="rgb(255 255 255)">ew InsightError(); } let applykey: string = Obje</text>
  <text x="427" y="142" fill="rgb(237 28 36)">ct.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if</text>
  <text x="655" y="142" fill="rgb(255 255 255)"> (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytok</text>
  <text x="0" y="143" fill="rgb(255 255 255)">en) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields</text>
  <text x="269" y="143" fill="rgb(237 28 36)">.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.</text>
  <text x="378" y="143" fill="rgb(255 255 255)">validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includ</text>
  <text x="426" y="143" fill="rgb(237 28 36)">es(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw </text>
  <text x="656" y="143" fill="rgb(255 255 255)">new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw </text>
  <text x="0" y="144" fill="rgb(255 255 255)">new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void</text>
  <text x="266" y="144" fill="rgb(237 28 36)"> { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.</text>
  <text x="377" y="144" fill="rgb(255 255 255)">includes(q)) { throw new InsightError(); } } els</text>
  <text x="425" y="144" fill="rgb(237 28 36)">e { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { thr</text>
  <text x="657" y="144" fill="rgb(255 255 255)">ow new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.i</text>
  <text x="0" y="145" fill="rgb(255 255 255)">sArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let v</text>
  <text x="264" y="145" fill="rgb(237 28 36)">alue: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;N</text>
  <text x="376" y="145" fill="rgb(255 255 255)">OT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;:</text>
  <text x="423" y="145" fill="rgb(237 28 36)"> case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightErro</text>
  <text x="658" y="145" fill="rgb(255 255 255)">r(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) {</text>
  <text x="0" y="146" fill="rgb(255 255 255)"> throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !</text>
  <text x="262" y="146" fill="rgb(237 28 36)">== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(</text>
  <text x="375" y="146" fill="rgb(255 255 255)">idstring) || !this.sfields.includes(sfield)) { </text>
  <text x="422" y="146" fill="rgb(237 28 36)">throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey</text>
  <text x="658" y="146" fill="rgb(255 255 255)">.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;</text>
  <text x="0" y="147" fill="rgb(255 255 255)">number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of va</text>
  <text x="259" y="147" fill="rgb(237 28 36)">lue) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQue</text>
  <text x="374" y="147" fill="rgb(255 255 255)">ry.length === 0) { for (let insightDataset of t</text>
  <text x="421" y="147" fill="rgb(237 28 36)">his.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mf</text>
  <text x="659" y="147" fill="rgb(255 255 255)">ields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): stri</text>
  <text x="0" y="148" fill="rgb(255 255 255)">ng[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly </text>
  <text x="257" y="148" fill="rgb(237 28 36)">coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;</text>
  <text x="373" y="148" fill="rgb(255 255 255)">lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfi</text>
  <text x="420" y="148" fill="rgb(237 28 36)">elds: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: stri</text>
  <text x="660" y="148" fill="rgb(255 255 255)">ng[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // key</text>
  <text x="0" y="149" fill="rgb(255 255 255)">s appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this</text>
  <text x="255" y="149" fill="rgb(237 28 36)">.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHE</text>
  <text x="372" y="149" fill="rgb(255 255 255)">RE || !q.OPTIONS) { throw new InsightError(); }</text>
  <text x="419" y="149" fill="rgb(237 28 36)"> for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); }</text>
  <text x="661" y="149" fill="rgb(255 255 255)"> this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).le</text>
  <text x="0" y="150" fill="rgb(255 255 255)">ngth !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at le</text>
  <text x="253" y="150" fill="rgb(237 28 36)">ast one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is vali</text>
  <text x="370" y="150" fill="rgb(255 255 255)">d, push it to transformationKey } } private val</text>
  <text x="417" y="150" fill="rgb(237 28 36)">idateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(</text>
  <text x="662" y="150" fill="rgb(255 255 255)">splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and sh</text>
  <text x="0" y="151" fill="rgb(255 255 255)">ould have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (apply</text>
  <text x="252" y="151" fill="rgb(237 28 36)">key.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); </text>
  <text x="369" y="151" fill="rgb(255 255 255)">} this.transformationKey.push(applykey); if (Ar</text>
  <text x="416" y="151" fill="rgb(237 28 36)">ray.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); }</text>
  <text x="662" y="151" fill="rgb(255 255 255)"> let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstri</text>
  <text x="0" y="152" fill="rgb(255 255 255)">ng(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightE</text>
  <text x="250" y="152" fill="rgb(237 28 36)">rror(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (k</text>
  <text x="368" y="152" fill="rgb(255 255 255)">ey !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw ne</text>
  <text x="415" y="152" fill="rgb(237 28 36)">w InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.l</text>
  <text x="663" y="152" fill="rgb(255 255 255)">ength &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private vali</text>
  <text x="0" y="153" fill="rgb(255 255 255)">dateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw </text>
  <text x="248" y="153" fill="rgb(237 28 36)">new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if </text>
  <text x="367" y="153" fill="rgb(255 255 255)">(!Array.isArray(keys) || keys.length &amp;lt; 1) { thr</text>
  <text x="414" y="153" fill="rgb(237 28 36)">ow new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length </text>
  <text x="664" y="153" fill="rgb(255 255 255)">!== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Obj</text>
  <text x="0" y="154" fill="rgb(255 255 255)">ect.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS</text>
  <text x="246" y="154" fill="rgb(237 28 36)">&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (t</text>
  <text x="366" y="154" fill="rgb(255 255 255)">ypeof value !== &amp;quot;object&amp;quot;) { throw new InsightEr</text>
  <text x="413" y="154" fill="rgb(237 28 36)">ror(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].sp</text>
  <text x="664" y="154" fill="rgb(255 255 255)">lit(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0</text>
  <text x="0" y="155" fill="rgb(255 255 255)">]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: a</text>
  <text x="244" y="155" fill="rgb(237 28 36)">ny): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: str</text>
  <text x="365" y="155" fill="rgb(255 255 255)">ing[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (m</text>
  <text x="412" y="155" fill="rgb(237 28 36)">key.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfie</text>
  <text x="665" y="155" fill="rgb(255 255 255)">ld)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let i</text>
  <text x="0" y="156" fill="rgb(255 255 255)">nnerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { th</text>
  <text x="243" y="156" fill="rgb(237 28 36)">is.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields;</text>
  <text x="364" y="156" fill="rgb(255 255 255)"> this.sfields = this.coursesfields; } else { t</text>
  <text x="410" y="156" fill="rgb(237 28 36)">his.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind</text>
  <text x="666" y="156" fill="rgb(255 255 255)">, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; pri</text>
  <text x="0" y="157" fill="rgb(255 255 255)">vate readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;a</text>
  <text x="241" y="157" fill="rgb(237 28 36)">ddress&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly </text>
  <text x="363" y="157" fill="rgb(255 255 255)">mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQue</text>
  <text x="409" y="157" fill="rgb(237 28 36)">ry: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsigh</text>
  <text x="666" y="157" fill="rgb(255 255 255)">tDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuer</text>
  <text x="0" y="158" fill="rgb(255 255 255)">y = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key</text>
  <text x="239" y="158" fill="rgb(237 28 36)"> !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIO</text>
  <text x="362" y="158" fill="rgb(255 255 255)">NS) { this.validateTransformations(q.TRANSFORM</text>
  <text x="408" y="158" fill="rgb(237 28 36)">ATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.v</text>
  <text x="667" y="158" fill="rgb(255 255 255)">alidateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should</text>
  <text x="0" y="159" fill="rgb(255 255 255)"> has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.s</text>
  <text x="237" y="159" fill="rgb(237 28 36)">plit(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.m</text>
  <text x="362" y="159" fill="rgb(255 255 255)">fields.includes(splittedKey[1]) || this.sfiel</text>
  <text x="407" y="159" fill="rgb(237 28 36)">ds.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(</text>
  <text x="668" y="159" fill="rgb(255 255 255)">applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; </text>
  <text x="0" y="160" fill="rgb(255 255 255)">if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { th</text>
  <text x="236" y="160" fill="rgb(237 28 36)">row new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.m</text>
  <text x="361" y="160" fill="rgb(255 255 255)">stoken.includes(applytoken)) { throw new Insi</text>
  <text x="406" y="160" fill="rgb(237 28 36)">ghtError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } </text>
  <text x="668" y="160" fill="rgb(255 255 255)">else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new I</text>
  <text x="0" y="161" fill="rgb(255 255 255)">nsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.O</text>
  <text x="234" y="161" fill="rgb(237 28 36)">RDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightEr</text>
  <text x="360" y="161" fill="rgb(255 255 255)">ror(); } for (let mskey of q) { if (this.tran</text>
  <text x="405" y="161" fill="rgb(237 28 36)">sformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } e</text>
  <text x="669" y="161" fill="rgb(255 255 255)">lse if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { t</text>
  <text x="0" y="162" fill="rgb(255 255 255)">hrow new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this</text>
  <text x="232" y="162" fill="rgb(237 28 36)">.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) {</text>
  <text x="359" y="162" fill="rgb(255 255 255)"> throw new InsightError(); } else { if (Objec</text>
  <text x="404" y="162" fill="rgb(237 28 36)">t.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;</text>
  <text x="669" y="162" fill="rgb(255 255 255)">: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case </text>
  <text x="0" y="163" fill="rgb(255 255 255)">&amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(val</text>
  <text x="231" y="163" fill="rgb(237 28 36)">ue: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new </text>
  <text x="358" y="163" fill="rgb(255 255 255)">InsightError(); } let skey: string[] = Object</text>
  <text x="403" y="163" fill="rgb(237 28 36)">.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.sl</text>
  <text x="670" y="163" fill="rgb(255 255 255)">ice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: </text>
  <text x="0" y="164" fill="rgb(255 255 255)">any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let i</text>
  <text x="229" y="164" fill="rgb(237 28 36)">dstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) |</text>
  <text x="357" y="164" fill="rgb(255 255 255)">| !this.validateIdstring(idstring) || !this.</text>
  <text x="401" y="164" fill="rgb(237 28 36)">mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdst</text>
  <text x="671" y="164" fill="rgb(255 255 255)">ring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { th</text>
  <text x="0" y="165" fill="rgb(255 255 255)">is.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfie</text>
  <text x="227" y="165" fill="rgb(237 28 36)">lds; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { re</text>
  <text x="356" y="165" fill="rgb(255 255 255)">turn this.idInQuery; } } import {InsightData</text>
  <text x="400" y="165" fill="rgb(237 28 36)">set, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uui</text>
  <text x="672" y="165" fill="rgb(255 255 255)">d&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;add</text>
  <text x="0" y="166" fill="rgb(255 255 255)">ress&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private</text>
  <text x="226" y="166" fill="rgb(237 28 36)"> keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appear</text>
  <text x="355" y="166" fill="rgb(255 255 255)">ed in transformation, if there is a transfor</text>
  <text x="399" y="166" fill="rgb(237 28 36)">mation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } pu</text>
  <text x="673" y="166" fill="rgb(255 255 255)">blic validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !==</text>
  <text x="0" y="167" fill="rgb(255 255 255)"> &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public valida</text>
  <text x="224" y="167" fill="rgb(237 28 36)">teTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !=</text>
  <text x="354" y="167" fill="rgb(255 255 255)">= 2) { throw new InsightError(); } this.vali</text>
  <text x="398" y="167" fill="rgb(237 28 36)">dateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transf</text>
  <text x="673" y="167" fill="rgb(255 255 255)">ormationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;</text>
  <text x="0" y="168" fill="rgb(255 255 255)">_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); </text>
  <text x="223" y="168" fill="rgb(237 28 36)">} } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should h</text>
  <text x="353" y="168" fill="rgb(255 255 255)">ave at least one element } for (let applyrul</text>
  <text x="397" y="168" fill="rgb(237 28 36)">e of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includ</text>
  <text x="674" y="168" fill="rgb(255 255 255)">es(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new</text>
  <text x="0" y="169" fill="rgb(255 255 255)"> InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].spl</text>
  <text x="221" y="169" fill="rgb(237 28 36)">it(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(ke</text>
  <text x="352" y="169" fill="rgb(255 255 255)">y[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { t</text>
  <text x="396" y="169" fill="rgb(237 28 36)">hrow new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Objec</text>
  <text x="675" y="169" fill="rgb(255 255 255)">t.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { t</text>
  <text x="0" y="170" fill="rgb(255 255 255)">his.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.in</text>
  <text x="220" y="170" fill="rgb(237 28 36)">cludes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validate</text>
  <text x="351" y="170" fill="rgb(255 255 255)">Order(q: any): void { if (Array.isArray(q)) </text>
  <text x="395" y="170" fill="rgb(237 28 36)">{ throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new Insigh</text>
  <text x="675" y="170" fill="rgb(255 255 255)">tError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuer</text>
  <text x="0" y="171" fill="rgb(255 255 255)">y.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } p</text>
  <text x="218" y="171" fill="rgb(237 28 36)">rivate validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object</text>
  <text x="350" y="171" fill="rgb(255 255 255)">.keys(q)[0]; let value: any = Object.values(</text>
  <text x="394" y="171" fill="rgb(237 28 36)">q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private </text>
  <text x="676" y="171" fill="rgb(255 255 255)">validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): vo</text>
  <text x="0" y="172" fill="rgb(255 255 255)">id { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { thro</text>
  <text x="217" y="172" fill="rgb(237 28 36)">w new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0];</text>
  <text x="349" y="172" fill="rgb(255 255 255)"> if (typeof str !== &amp;quot;string&amp;quot;) { throw new In</text>
  <text x="393" y="172" fill="rgb(237 28 36)">sightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw </text>
  <text x="677" y="172" fill="rgb(255 255 255)">new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: strin</text>
  <text x="0" y="173" fill="rgb(255 255 255)">g = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } }</text>
  <text x="215" y="173" fill="rgb(237 28 36)"> } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let in</text>
  <text x="348" y="173" fill="rgb(255 255 255)">nerObject of value) { this.validateFilter(in</text>
  <text x="392" y="173" fill="rgb(237 28 36)">nerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { </text>
  <text x="677" y="173" fill="rgb(255 255 255)">this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return tr</text>
  <text x="0" y="174" fill="rgb(255 255 255)">ue; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFa</text>
  <text x="214" y="174" fill="rgb(237 28 36)">cade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; pri</text>
  <text x="347" y="174" fill="rgb(255 255 255)">vate readonly coursesfields: string[] = [&amp;quot;de</text>
  <text x="391" y="174" fill="rgb(237 28 36)">pt&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, </text>
  <text x="678" y="174" fill="rgb(255 255 255)">&amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: str</text>
  <text x="0" y="175" fill="rgb(255 255 255)">ing[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; priv</text>
  <text x="212" y="175" fill="rgb(237 28 36)">ate mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQue</text>
  <text x="346" y="175" fill="rgb(255 255 255)">ry = []; this.transformationKey = []; this.a</text>
  <text x="390" y="175" fill="rgb(237 28 36)">llInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWher</text>
  <text x="678" y="175" fill="rgb(255 255 255)">e(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q</text>
  <text x="0" y="176" fill="rgb(255 255 255)">: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } priva</text>
  <text x="211" y="176" fill="rgb(237 28 36)">te validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and shou</text>
  <text x="345" y="176" fill="rgb(255 255 255)">ld has at least one element } for (let key o</text>
  <text x="389" y="176" fill="rgb(237 28 36)">f q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstr</text>
  <text x="679" y="176" fill="rgb(255 255 255)">ing(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validate</text>
  <text x="0" y="177" fill="rgb(255 255 255)">APPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(a</text>
  <text x="209" y="177" fill="rgb(237 28 36)">pplyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey</text>
  <text x="344" y="177" fill="rgb(255 255 255)">]; if (applykey.length === 0 || applykey.inc</text>
  <text x="388" y="177" fill="rgb(237 28 36)">ludes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.in</text>
  <text x="679" y="177" fill="rgb(255 255 255)">cludes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.lengt</text>
  <text x="0" y="178" fill="rgb(255 255 255)">h !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.incl</text>
  <text x="208" y="178" fill="rgb(237 28 36)">udes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw n</text>
  <text x="343" y="178" fill="rgb(255 255 255)">ew InsightError(); } } } } public validateOp</text>
  <text x="387" y="178" fill="rgb(237 28 36)">tions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length</text>
  <text x="680" y="178" fill="rgb(255 255 255)"> &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw </text>
  <text x="0" y="179" fill="rgb(255 255 255)">new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;st</text>
  <text x="207" y="179" fill="rgb(237 28 36)">ring&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2)</text>
  <text x="343" y="179" fill="rgb(255 255 255)"> { throw new InsightError(); } if (q.dir !=</text>
  <text x="386" y="179" fill="rgb(237 28 36)">= &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void</text>
  <text x="680" y="179" fill="rgb(255 255 255)"> { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: </text>
  <text x="0" y="180" fill="rgb(255 255 255)">any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.vali</text>
  <text x="205" y="180" fill="rgb(237 28 36)">dateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; </text>
  <text x="342" y="180" fill="rgb(255 255 255)">case &amp;quot;IS&amp;quot;: this.validateIS(value); break; d</text>
  <text x="385" y="180" fill="rgb(237 28 36)">efault: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).l</text>
  <text x="680" y="180" fill="rgb(255 255 255)">ength !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } el</text>
  <text x="0" y="181" fill="rgb(255 255 255)">se { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(</text>
  <text x="204" y="181" fill="rgb(237 28 36)">&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(v</text>
  <text x="341" y="181" fill="rgb(255 255 255)">alue: any): void { if (typeof value !== &amp;quot;ob</text>
  <text x="384" y="181" fill="rgb(237 28 36)">ject&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typ</text>
  <text x="681" y="181" fill="rgb(255 255 255)">eof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(val</text>
  <text x="0" y="182" fill="rgb(255 255 255)">ue: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: str</text>
  <text x="203" y="182" fill="rgb(237 28 36)">ing): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstrin</text>
  <text x="340" y="182" fill="rgb(255 255 255)">g) { this.idInQuery.push(idstring); if (ins</text>
  <text x="383" y="182" fill="rgb(237 28 36)">ightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdIn</text>
  <text x="681" y="182" fill="rgb(255 255 255)">Query(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class Q</text>
  <text x="0" y="183" fill="rgb(255 255 255)">ueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private re</text>
  <text x="201" y="183" fill="rgb(237 28 36)">adonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;nam</text>
  <text x="339" y="183" fill="rgb(255 255 255)">e&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]</text>
  <text x="382" y="183" fill="rgb(237 28 36)">; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: stri</text>
  <text x="682" y="183" fill="rgb(255 255 255)">ng[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private </text>
  <text x="0" y="184" fill="rgb(255 255 255)">sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate</text>
  <text x="200" y="184" fill="rgb(237 28 36)">(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;</text>
  <text x="338" y="184" fill="rgb(255 255 255)">&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIO</text>
  <text x="381" y="184" fill="rgb(237 28 36)">NS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Objec</text>
  <text x="682" y="184" fill="rgb(255 255 255)">t.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void {</text>
  <text x="0" y="185" fill="rgb(255 255 255)"> if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.</text>
  <text x="199" y="185" fill="rgb(237 28 36)">push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = k</text>
  <text x="337" y="185" fill="rgb(255 255 255)">ey.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2</text>
  <text x="380" y="185" fill="rgb(237 28 36)">) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an a</text>
  <text x="682" y="185" fill="rgb(255 255 255)">rray, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new </text>
  <text x="0" y="186" fill="rgb(255 255 255)">InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applyke</text>
  <text x="198" y="186" fill="rgb(237 28 36)">y)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) </text>
  <text x="336" y="186" fill="rgb(255 255 255)">{ throw new InsightError(); } let applytoke</text>
  <text x="379" y="186" fill="rgb(237 28 36)">n: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.val</text>
  <text x="683" y="186" fill="rgb(255 255 255)">idateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.vali</text>
  <text x="0" y="187" fill="rgb(255 255 255)">dateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q</text>
  <text x="197" y="187" fill="rgb(237 28 36)">); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (</text>
  <text x="335" y="187" fill="rgb(255 255 255)">q.ORDER) { this.validateOrder(q.ORDER); } }</text>
  <text x="378" y="187" fill="rgb(237 28 36)"> private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } p</text>
  <text x="683" y="187" fill="rgb(255 255 255)">rivate validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.inclu</text>
  <text x="0" y="188" fill="rgb(255 255 255)">des(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError</text>
  <text x="195" y="188" fill="rgb(237 28 36)">(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!thi</text>
  <text x="335" y="188" fill="rgb(255 255 255)">s.keysInQuery.includes(anykey)) { throw ne</text>
  <text x="377" y="188" fill="rgb(237 28 36)">w InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: st</text>
  <text x="684" y="188" fill="rgb(255 255 255)">ring = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: t</text>
  <text x="0" y="189" fill="rgb(255 255 255)">his.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private vali</text>
  <text x="194" y="189" fill="rgb(237 28 36)">dateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(va</text>
  <text x="334" y="189" fill="rgb(255 255 255)">lue: any): void { if (typeof value !== &amp;quot;ob</text>
  <text x="376" y="189" fill="rgb(237 28 36)">ject&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.value</text>
  <text x="684" y="189" fill="rgb(255 255 255)">s(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstrin</text>
  <text x="0" y="190" fill="rgb(255 255 255)">g) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw ne</text>
  <text x="193" y="190" fill="rgb(237 28 36)">w InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let i</text>
  <text x="333" y="190" fill="rgb(255 255 255)">dstring: string = mkey[0]; let mfield: str</text>
  <text x="375" y="190" fill="rgb(237 28 36)">ing = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } </text>
  <text x="684" y="190" fill="rgb(255 255 255)">for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.lengt</text>
  <text x="0" y="191" fill="rgb(255 255 255)">h === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { t</text>
  <text x="192" y="191" fill="rgb(237 28 36)">his.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfiel</text>
  <text x="332" y="191" fill="rgb(255 255 255)">ds; } return true; } } return false; } else</text>
  <text x="375" y="191" fill="rgb(237 28 36)"> { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;y</text>
  <text x="684" y="191" fill="rgb(255 255 255)">ear&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lo</text>
  <text x="0" y="192" fill="rgb(255 255 255)">n&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;,</text>
  <text x="191" y="192" fill="rgb(237 28 36)"> &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private </text>
  <text x="331" y="192" fill="rgb(255 255 255)">keysInQuery: string[]; // all keys appeared</text>
  <text x="374" y="192" fill="rgb(237 28 36)"> in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.k</text>
  <text x="685" y="192" fill="rgb(255 255 255)">eysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.O</text>
  <text x="0" y="193" fill="rgb(255 255 255)">PTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWh</text>
  <text x="190" y="193" fill="rgb(237 28 36)">ere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validate</text>
  <text x="330" y="193" fill="rgb(255 255 255)">Transformations(q: any): void { if (typeof </text>
  <text x="373" y="193" fill="rgb(237 28 36)">q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, a</text>
  <text x="685" y="193" fill="rgb(255 255 255)">nd should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it t</text>
  <text x="0" y="194" fill="rgb(255 255 255)">o transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateI</text>
  <text x="189" y="194" fill="rgb(237 28 36)">dstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } </text>
  <text x="329" y="194" fill="rgb(255 255 255)">} private validateAPPLY(q: any): void { if </text>
  <text x="372" y="194" fill="rgb(237 28 36)">(!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[ap</text>
  <text x="685" y="194" fill="rgb(255 255 255)">plykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transf</text>
  <text x="0" y="195" fill="rgb(255 255 255)">ormationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtok</text>
  <text x="188" y="195" fill="rgb(237 28 36)">en.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;</text>
  <text x="329" y="195" fill="rgb(255 255 255)">_&amp;quot;); if (key.length !== 2) { throw new Ins</text>
  <text x="371" y="195" fill="rgb(237 28 36)">ightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { thr</text>
  <text x="686" y="195" fill="rgb(255 255 255)">ow new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMN</text>
  <text x="0" y="196" fill="rgb(255 255 255)">S&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q</text>
  <text x="187" y="196" fill="rgb(237 28 36)">.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includ</text>
  <text x="328" y="196" fill="rgb(255 255 255)">es(mskey)) { throw new InsightError(); } }</text>
  <text x="370" y="196" fill="rgb(237 28 36)"> else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !=</text>
  <text x="686" y="196" fill="rgb(255 255 255)">= 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray</text>
  <text x="0" y="197" fill="rgb(255 255 255)">(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: an</text>
  <text x="186" y="197" fill="rgb(237 28 36)">y): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } privat</text>
  <text x="327" y="197" fill="rgb(255 255 255)">e validateFilter(q: any): void { if (Objec</text>
  <text x="369" y="197" fill="rgb(237 28 36)">t.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); brea</text>
  <text x="686" y="197" fill="rgb(255 255 255)">k; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== </text>
  <text x="0" y="198" fill="rgb(255 255 255)">&amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys</text>
  <text x="185" y="198" fill="rgb(237 28 36)">(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new</text>
  <text x="326" y="198" fill="rgb(255 255 255)"> InsightError(); } else { let idstring: st</text>
  <text x="368" y="198" fill="rgb(237 28 36)">ring = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(</text>
  <text x="687" y="198" fill="rgb(255 255 255)">value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.ke</text>
  <text x="0" y="199" fill="rgb(255 255 255)">ys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0</text>
  <text x="184" y="199" fill="rgb(237 28 36)">]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } pri</text>
  <text x="325" y="199" fill="rgb(255 255 255)">vate validateANDOR(value: any): void { if (</text>
  <text x="368" y="199" fill="rgb(237 28 36)">!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstrin</text>
  <text x="687" y="199" fill="rgb(255 255 255)">g) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = th</text>
  <text x="0" y="200" fill="rgb(255 255 255)">is.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } pu</text>
  <text x="183" y="200" fill="rgb(237 28 36)">blic getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; </text>
  <text x="325" y="200" fill="rgb(255 255 255)">export default class QueryValidator { priv</text>
  <text x="367" y="200" fill="rgb(237 28 36)">ate readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name</text>
  <text x="687" y="200" fill="rgb(255 255 255)">&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] =</text>
  <text x="0" y="201" fill="rgb(255 255 255)"> [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transform</text>
  <text x="182" y="201" fill="rgb(237 28 36)">ationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfie</text>
  <text x="324" y="201" fill="rgb(255 255 255)">lds: string[]; private sfields: string[]; </text>
  <text x="366" y="201" fill="rgb(237 28 36)">constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; </text>
  <text x="687" y="201" fill="rgb(255 255 255)">key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateT</text>
  <text x="0" y="202" fill="rgb(255 255 255)">ransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;unde</text>
  <text x="181" y="202" fill="rgb(237 28 36)">fined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private valid</text>
  <text x="323" y="202" fill="rgb(255 255 255)">ateGROUP(q: any): void { if (!Array.isArra</text>
  <text x="365" y="202" fill="rgb(237 28 36)">y(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.s</text>
  <text x="688" y="202" fill="rgb(255 255 255)">plit(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(spli</text>
  <text x="0" y="203" fill="rgb(255 255 255)">ttedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // </text>
  <text x="180" y="203" fill="rgb(237 28 36)">q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule)</text>
  <text x="322" y="203" fill="rgb(255 255 255)">.length &amp;gt; 1) { throw new InsightError(); }</text>
  <text x="364" y="203" fill="rgb(237 28 36)"> let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { thr</text>
  <text x="688" y="203" fill="rgb(255 255 255)">ow new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(apply</text>
  <text x="0" y="204" fill="rgb(255 255 255)">token)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)</text>
  <text x="179" y="204" fill="rgb(237 28 36)">) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(appl</text>
  <text x="321" y="204" fill="rgb(255 255 255)">ytoken)) { if (!(this.validateIdstring(key[</text>
  <text x="364" y="204" fill="rgb(237 28 36)">0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDE</text>
  <text x="688" y="204" fill="rgb(255 255 255)">R) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mske</text>
  <text x="0" y="205" fill="rgb(255 255 255)">y of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery</text>
  <text x="178" y="205" fill="rgb(237 28 36)">.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { i</text>
  <text x="321" y="205" fill="rgb(255 255 255)">f (!this.keysInQuery.includes(q)) { throw </text>
  <text x="363" y="205" fill="rgb(237 28 36)">new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keys</text>
  <text x="688" y="205" fill="rgb(255 255 255)">InQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError</text>
  <text x="0" y="206" fill="rgb(255 255 255)">(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError();</text>
  <text x="177" y="206" fill="rgb(237 28 36)"> } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(v</text>
  <text x="320" y="206" fill="rgb(255 255 255)">alue); break; case &amp;quot;NOT&amp;quot;: this.validateNOT</text>
  <text x="362" y="206" fill="rgb(237 28 36)">(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: an</text>
  <text x="688" y="206" fill="rgb(255 255 255)">y): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let sk</text>
  <text x="0" y="207" fill="rgb(255 255 255)">ey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let s</text>
  <text x="176" y="207" fill="rgb(237 28 36)">tr: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !t</text>
  <text x="319" y="207" fill="rgb(255 255 255)">his.validateIdstring(idstring) || !this.sf</text>
  <text x="361" y="207" fill="rgb(237 28 36)">ields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: </text>
  <text x="689" y="207" fill="rgb(255 255 255)">string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(</text>
  <text x="0" y="208" fill="rgb(255 255 255)">idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw</text>
  <text x="175" y="208" fill="rgb(237 28 36)"> new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boole</text>
  <text x="318" y="208" fill="rgb(255 255 255)">an { if (this.idInQuery.length === 0) { for</text>
  <text x="361" y="208" fill="rgb(237 28 36)"> (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQue</text>
  <text x="461" y="208" fill="rgb(255 255 255)">ry.push(idstring); if (insightDataset</text>
  <text x="498" y="208" fill="rgb(237 28 36)">.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } retu</text>
  <text x="689" y="208" fill="rgb(255 255 255)">rn true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } i</text>
  <text x="0" y="209" fill="rgb(255 255 255)">mport {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pa</text>
  <text x="174" y="209" fill="rgb(237 28 36)">ss&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommf</text>
  <text x="318" y="209" fill="rgb(255 255 255)">ields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;];</text>
  <text x="360" y="209" fill="rgb(237 28 36)"> private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;ad</text>
  <text x="450" y="209" fill="rgb(255 255 255)">dress&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mto</text>
  <text x="508" y="209" fill="rgb(237 28 36)">ken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery</text>
  <text x="689" y="209" fill="rgb(255 255 255)">: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if th</text>
  <text x="0" y="210" fill="rgb(255 255 255)">ere is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { th</text>
  <text x="174" y="210" fill="rgb(237 28 36)">is.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): voi</text>
  <text x="317" y="210" fill="rgb(255 255 255)">d { if (!q || !q.WHERE || !q.OPTIONS) { th</text>
  <text x="359" y="210" fill="rgb(237 28 36)">row new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp;</text>
  <text x="443" y="210" fill="rgb(255 255 255)"> key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(</text>
  <text x="515" y="210" fill="rgb(237 28 36)">); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformati</text>
  <text x="689" y="210" fill="rgb(255 255 255)">ons(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightErro</text>
  <text x="0" y="211" fill="rgb(255 255 255)">r(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); /</text>
  <text x="173" y="211" fill="rgb(237 28 36)">/ q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); //</text>
  <text x="316" y="211" fill="rgb(255 255 255)"> if the key is valid, push it to transform</text>
  <text x="358" y="211" fill="rgb(237 28 36)">ationKey } } private validateKey(key: string): void { let splittedKey: string[</text>
  <text x="436" y="211" fill="rgb(255 255 255)">] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!</text>
  <text x="521" y="211" fill="rgb(237 28 36)">(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private vali</text>
  <text x="690" y="211" fill="rgb(255 255 255)">dateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } fo</text>
  <text x="0" y="212" fill="rgb(255 255 255)">r (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; </text>
  <text x="172" y="212" fill="rgb(237 28 36)">let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw n</text>
  <text x="315" y="212" fill="rgb(255 255 255)">ew InsightError(); } this.transformationKey</text>
  <text x="358" y="212" fill="rgb(237 28 36)">.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).l</text>
  <text x="429" y="212" fill="rgb(255 255 255)">ength &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!</text>
  <text x="526" y="212" fill="rgb(237 28 36)">this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.l</text>
  <text x="690" y="212" fill="rgb(255 255 255)">ength !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes</text>
  <text x="0" y="213" fill="rgb(255 255 255)">(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfie</text>
  <text x="171" y="213" fill="rgb(237 28 36)">lds.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let ke</text>
  <text x="315" y="213" fill="rgb(255 255 255)">y of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key </text>
  <text x="357" y="213" fill="rgb(237 28 36)">!== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(</text>
  <text x="423" y="213" fill="rgb(255 255 255)">q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q |</text>
  <text x="531" y="213" fill="rgb(237 28 36)">| q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { th</text>
  <text x="690" y="213" fill="rgb(255 255 255)">row new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array</text>
  <text x="0" y="214" fill="rgb(255 255 255)">.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.ke</text>
  <text x="170" y="214" fill="rgb(237 28 36)">ys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys:</text>
  <text x="314" y="214" fill="rgb(255 255 255)"> any = q.keys; if (!Array.isArray(keys) ||</text>
  <text x="356" y="214" fill="rgb(237 28 36)"> keys.length &amp;lt; 1) { throw new InsightError(); } for (let anyk</text>
  <text x="417" y="214" fill="rgb(255 255 255)">ey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any)</text>
  <text x="535" y="214" fill="rgb(237 28 36)">: void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter</text>
  <text x="690" y="214" fill="rgb(255 255 255)">(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Ob</text>
  <text x="0" y="215" fill="rgb(255 255 255)">ject.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: t</text>
  <text x="169" y="215" fill="rgb(237 28 36)">his.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: </text>
  <text x="313" y="215" fill="rgb(255 255 255)">any): void { if (typeof value !== &amp;quot;object&amp;quot;)</text>
  <text x="356" y="215" fill="rgb(237 28 36)"> { throw new InsightError(); } this.validateFilter(valu</text>
  <text x="411" y="215" fill="rgb(255 255 255)">e); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value</text>
  <text x="538" y="215" fill="rgb(237 28 36)">).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); </text>
  <text x="690" y="215" fill="rgb(255 255 255)">} else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { t</text>
  <text x="0" y="216" fill="rgb(255 255 255)">hrow new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError();</text>
  <text x="169" y="216" fill="rgb(237 28 36)"> } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(</text>
  <text x="312" y="216" fill="rgb(255 255 255)">); } let mkey: string[] = Object.keys(value</text>
  <text x="355" y="216" fill="rgb(237 28 36)">)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw ne</text>
  <text x="405" y="216" fill="rgb(255 255 255)">w InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typ</text>
  <text x="542" y="216" fill="rgb(237 28 36)">eof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR</text>
  <text x="690" y="216" fill="rgb(255 255 255)">(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validat</text>
  <text x="0" y="217" fill="rgb(255 255 255)">eFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { </text>
  <text x="168" y="217" fill="rgb(237 28 36)">if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = th</text>
  <text x="312" y="217" fill="rgb(255 255 255)">is.coursemfields; this.sfields = this.cour</text>
  <text x="354" y="217" fill="rgb(237 28 36)">sesfields; } else { this.mfields = this.roommf</text>
  <text x="400" y="217" fill="rgb(255 255 255)">ields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQue</text>
  <text x="545" y="217" fill="rgb(237 28 36)">ry(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default clas</text>
  <text x="691" y="217" fill="rgb(255 255 255)">s QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string</text>
  <text x="0" y="218" fill="rgb(255 255 255)">[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullna</text>
  <text x="167" y="218" fill="rgb(237 28 36)">me&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; </text>
  <text x="311" y="218" fill="rgb(255 255 255)">private readonly mstoken: string[] = [&amp;quot;COUN</text>
  <text x="354" y="218" fill="rgb(237 28 36)">T&amp;quot;]; private idInQuery: string[]; // mak</text>
  <text x="394" y="218" fill="rgb(255 255 255)">e sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]</text>
  <text x="547" y="218" fill="rgb(237 28 36)">; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; priva</text>
  <text x="691" y="218" fill="rgb(255 255 255)">te sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []</text>
  <text x="0" y="219" fill="rgb(255 255 255)">; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.k</text>
  <text x="166" y="219" fill="rgb(237 28 36)">eys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if</text>
  <text x="310" y="219" fill="rgb(255 255 255)"> (q.TRANSFORMATIONS) { this.validateTransfo</text>
  <text x="353" y="219" fill="rgb(237 28 36)">rmations(q.TRANSFORMATIONS); } this.</text>
  <text x="389" y="219" fill="rgb(255 255 255)">validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(</text>
  <text x="550" y="219" fill="rgb(237 28 36)">q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): voi</text>
  <text x="691" y="219" fill="rgb(255 255 255)">d { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (le</text>
  <text x="0" y="220" fill="rgb(255 255 255)">t key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void</text>
  <text x="166" y="220" fill="rgb(237 28 36)"> { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splitted</text>
  <text x="309" y="220" fill="rgb(255 255 255)">Key[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedK</text>
  <text x="352" y="220" fill="rgb(237 28 36)">ey[1]) || this.sfields.includes(</text>
  <text x="384" y="220" fill="rgb(255 255 255)">splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and </text>
  <text x="553" y="220" fill="rgb(237 28 36)">should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw n</text>
  <text x="691" y="220" fill="rgb(255 255 255)">ew InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applyk</text>
  <text x="0" y="221" fill="rgb(255 255 255)">ey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Ob</text>
  <text x="165" y="221" fill="rgb(237 28 36)">ject.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(appl</text>
  <text x="308" y="221" fill="rgb(255 255 255)">ytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken</text>
  <text x="352" y="221" fill="rgb(237 28 36)">)) { throw new InsightError</text>
  <text x="379" y="221" fill="rgb(255 255 255)">(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstri</text>
  <text x="555" y="221" fill="rgb(237 28 36)">ng(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.v</text>
  <text x="691" y="221" fill="rgb(255 255 255)">alidateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public valid</text>
  <text x="0" y="222" fill="rgb(255 255 255)">ateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.</text>
  <text x="164" y="222" fill="rgb(237 28 36)">validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { th</text>
  <text x="308" y="222" fill="rgb(255 255 255)">row new InsightError(); } for (let mskey of</text>
  <text x="351" y="222" fill="rgb(237 28 36)"> q) { if (this.transfo</text>
  <text x="373" y="222" fill="rgb(255 255 255)">rmationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private valida</text>
  <text x="557" y="222" fill="rgb(237 28 36)">teOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.in</text>
  <text x="691" y="222" fill="rgb(255 255 255)">cludes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.di</text>
  <text x="0" y="223" fill="rgb(255 255 255)">r !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } fo</text>
  <text x="163" y="223" fill="rgb(237 28 36)">r (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Ar</text>
  <text x="307" y="223" fill="rgb(255 255 255)">ray.isArray(q)) { throw new InsightError(); </text>
  <text x="351" y="223" fill="rgb(237 28 36)">} else { if (Obje</text>
  <text x="368" y="223" fill="rgb(255 255 255)">ct.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.</text>
  <text x="559" y="223" fill="rgb(237 28 36)">keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;:</text>
  <text x="692" y="223" fill="rgb(255 255 255)"> this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break</text>
  <text x="0" y="224" fill="rgb(255 255 255)">; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter</text>
  <text x="163" y="224" fill="rgb(237 28 36)">(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !=</text>
  <text x="306" y="224" fill="rgb(255 255 255)">= 1) { throw new InsightError(); } let skey:</text>
  <text x="350" y="224" fill="rgb(237 28 36)"> string[] = O</text>
  <text x="363" y="224" fill="rgb(255 255 255)">bject.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if </text>
  <text x="561" y="224" fill="rgb(237 28 36)">(typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstr</text>
  <text x="692" y="224" fill="rgb(255 255 255)">ing) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;</text>
  <text x="0" y="225" fill="rgb(255 255 255)">object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw ne</text>
  <text x="162" y="225" fill="rgb(237 28 36)">w InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof nu</text>
  <text x="305" y="225" fill="rgb(255 255 255)">m !== &amp;quot;number&amp;quot;) || !this.validateIdstring(id</text>
  <text x="349" y="225" fill="rgb(237 28 36)">string) |</text>
  <text x="358" y="225" fill="rgb(255 255 255)">| !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObje</text>
  <text x="563" y="225" fill="rgb(237 28 36)">ct of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.len</text>
  <text x="692" y="225" fill="rgb(255 255 255)">gth === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (in</text>
  <text x="0" y="226" fill="rgb(255 255 255)">sightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfield</text>
  <text x="161" y="226" fill="rgb(237 28 36)">s; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery</text>
  <text x="304" y="226" fill="rgb(255 255 255)">(): string[] { return this.idInQuery; } } imp</text>
  <text x="349" y="226" fill="rgb(237 28 36)">ort {</text>
  <text x="354" y="226" fill="rgb(255 255 255)">InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private reado</text>
  <text x="565" y="226" fill="rgb(237 28 36)">nly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;</text>
  <text x="692" y="226" fill="rgb(255 255 255)">lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]</text>
  <text x="0" y="227" fill="rgb(255 255 255)">; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure th</text>
  <text x="160" y="227" fill="rgb(237 28 36)">e query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[</text>
  <text x="303" y="227" fill="rgb(255 255 255)">]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this</text>
  <text x="567" y="227" fill="rgb(237 28 36)">.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q</text>
  <text x="692" y="227" fill="rgb(255 255 255)">.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATION</text>
  <text x="0" y="228" fill="rgb(255 255 255)">S&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOption</text>
  <text x="160" y="228" fill="rgb(237 28 36)">s(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.</text>
  <text x="302" y="228" fill="rgb(255 255 255)">keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least </text>
  <text x="569" y="228" fill="rgb(237 28 36)">one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it</text>
  <text x="692" y="228" fill="rgb(255 255 255)"> to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) </text>
  <text x="0" y="229" fill="rgb(255 255 255)">{ throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1]))))</text>
  <text x="159" y="229" fill="rgb(237 28 36)"> { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an ar</text>
  <text x="301" y="229" fill="rgb(255 255 255)">ray, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.le</text>
  <text x="570" y="229" fill="rgb(237 28 36)">ngth === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.trans</text>
  <text x="693" y="229" fill="rgb(255 255 255)">formationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: </text>
  <text x="0" y="230" fill="rgb(255 255 255)">string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[</text>
  <text x="158" y="230" fill="rgb(237 28 36)">] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.va</text>
  <text x="300" y="230" fill="rgb(255 255 255)">lidateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } </text>
  <text x="572" y="230" fill="rgb(237 28 36)">} } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUM</text>
  <text x="693" y="230" fill="rgb(255 255 255)">NS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } pri</text>
  <text x="0" y="231" fill="rgb(255 255 255)">vate validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if</text>
  <text x="157" y="231" fill="rgb(237 28 36)"> (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } }</text>
  <text x="299" y="231" fill="rgb(255 255 255)"> private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightEr</text>
  <text x="573" y="231" fill="rgb(237 28 36)">ror(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArra</text>
  <text x="693" y="231" fill="rgb(255 255 255)">y(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new Ins</text>
  <text x="0" y="232" fill="rgb(255 255 255)">ightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.</text>
  <text x="157" y="232" fill="rgb(237 28 36)">validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key:</text>
  <text x="299" y="232" fill="rgb(255 255 255)"> string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateI</text>
  <text x="575" y="232" fill="rgb(237 28 36)">S(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !==</text>
  <text x="693" y="232" fill="rgb(255 255 255)"> &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;)</text>
  <text x="0" y="233" fill="rgb(255 255 255)"> { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if </text>
  <text x="156" y="233" fill="rgb(237 28 36)">(skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.v</text>
  <text x="298" y="233" fill="rgb(255 255 255)">alues(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (type</text>
  <text x="576" y="233" fill="rgb(237 28 36)">of value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.k</text>
  <text x="693" y="233" fill="rgb(255 255 255)">eys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = m</text>
  <text x="0" y="234" fill="rgb(255 255 255)">key[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { thro</text>
  <text x="155" y="234" fill="rgb(237 28 36)">w new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(</text>
  <text x="297" y="234" fill="rgb(255 255 255)">); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idst</text>
  <text x="577" y="234" fill="rgb(237 28 36)">ring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = t</text>
  <text x="693" y="234" fill="rgb(255 255 255)">his.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { retu</text>
  <text x="0" y="235" fill="rgb(255 255 255)">rn this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, Insight</text>
  <text x="154" y="235" fill="rgb(237 28 36)">Error} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audi</text>
  <text x="296" y="235" fill="rgb(255 255 255)">t&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furnitur</text>
  <text x="579" y="235" fill="rgb(237 28 36)">e&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] </text>
  <text x="693" y="235" fill="rgb(255 255 255)">= [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in colu</text>
  <text x="0" y="236" fill="rgb(255 255 255)">mns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset:</text>
  <text x="154" y="236" fill="rgb(237 28 36)"> InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []</text>
  <text x="295" y="236" fill="rgb(255 255 255)">; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRAN</text>
  <text x="580" y="236" fill="rgb(237 28 36)">SFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validate</text>
  <text x="693" y="236" fill="rgb(255 255 255)">Transformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP =</text>
  <text x="0" y="237" fill="rgb(255 255 255)">== &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validate</text>
  <text x="153" y="237" fill="rgb(237 28 36)">APPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an </text>
  <text x="294" y="237" fill="rgb(255 255 255)">object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.lengt</text>
  <text x="581" y="237" fill="rgb(237 28 36)">h !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(spli</text>
  <text x="694" y="237" fill="rgb(255 255 255)">ttedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.is</text>
  <text x="0" y="238" fill="rgb(255 255 255)">Array(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(apply</text>
  <text x="152" y="238" fill="rgb(237 28 36)">rule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = app</text>
  <text x="294" y="238" fill="rgb(255 255 255)">lyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let appl</text>
  <text x="582" y="238" fill="rgb(237 28 36)">ytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(apply</text>
  <text x="694" y="238" fill="rgb(255 255 255)">token)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError()</text>
  <text x="0" y="239" fill="rgb(255 255 255)">; } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else</text>
  <text x="151" y="239" fill="rgb(237 28 36)"> if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1</text>
  <text x="293" y="239" fill="rgb(255 255 255)">])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); </text>
  <text x="583" y="239" fill="rgb(237 28 36)">} } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mske</text>
  <text x="694" y="239" fill="rgb(255 255 255)">y of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this</text>
  <text x="0" y="240" fill="rgb(255 255 255)">.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else</text>
  <text x="151" y="240" fill="rgb(237 28 36)"> if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(</text>
  <text x="292" y="240" fill="rgb(255 255 255)">q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw n</text>
  <text x="584" y="240" fill="rgb(237 28 36)">ew InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError</text>
  <text x="694" y="240" fill="rgb(255 255 255)">(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).len</text>
  <text x="0" y="241" fill="rgb(255 255 255)">gth !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: </text>
  <text x="150" y="241" fill="rgb(237 28 36)">case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ</text>
  <text x="291" y="241" fill="rgb(255 255 255)">(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;obje</text>
  <text x="586" y="241" fill="rgb(237 28 36)">ct&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let sk</text>
  <text x="694" y="241" fill="rgb(255 255 255)">ey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]</text>
  <text x="0" y="242" fill="rgb(255 255 255)">; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.sl</text>
  <text x="149" y="242" fill="rgb(237 28 36)">ice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private v</text>
  <text x="291" y="242" fill="rgb(255 255 255)">alidateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string </text>
  <text x="587" y="242" fill="rgb(237 28 36)">= mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(</text>
  <text x="694" y="242" fill="rgb(255 255 255)">idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray</text>
  <text x="0" y="243" fill="rgb(255 255 255)">(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIds</text>
  <text x="149" y="243" fill="rgb(237 28 36)">tring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset</text>
  <text x="290" y="243" fill="rgb(255 255 255)">.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { r</text>
  <text x="587" y="243" fill="rgb(237 28 36)">eturn this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } i</text>
  <text x="694" y="243" fill="rgb(255 255 255)">mport {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly co</text>
  <text x="0" y="244" fill="rgb(255 255 255)">ursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;</text>
  <text x="148" y="244" fill="rgb(237 28 36)">uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, </text>
  <text x="289" y="244" fill="rgb(255 255 255)">&amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, </text>
  <text x="407" y="244" fill="rgb(24 158 180)">&amp;quot;SUM&amp;quot;]; private readonly mstoken: strin</text>
  <text x="446" y="244" fill="rgb(255 255 255)">g[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in co</text>
  <text x="588" y="244" fill="rgb(237 28 36)">lumns after being validated private transformationKey: string[]; // keys appeared in transformation, if th</text>
  <text x="694" y="244" fill="rgb(255 255 255)">ere is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insi</text>
  <text x="0" y="245" fill="rgb(255 255 255)">ghtDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets;</text>
  <text x="147" y="245" fill="rgb(237 28 36)"> } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key </text>
  <text x="288" y="245" fill="rgb(255 255 255)">!== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere</text>
  <text x="401" y="245" fill="rgb(24 158 180)">(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransfo</text>
  <text x="457" y="245" fill="rgb(255 255 255)">rmations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP </text>
  <text x="589" y="245" fill="rgb(237 28 36)">=== &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightErro</text>
  <text x="694" y="245" fill="rgb(255 255 255)">r(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length </text>
  <text x="0" y="246" fill="rgb(255 255 255)">&amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.t</text>
  <text x="147" y="246" fill="rgb(237 28 36)">ransformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey</text>
  <text x="288" y="246" fill="rgb(255 255 255)">: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validate</text>
  <text x="396" y="246" fill="rgb(24 158 180)">Idstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]</text>
  <text x="461" y="246" fill="rgb(255 255 255)">) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.is</text>
  <text x="590" y="246" fill="rgb(237 28 36)">Array(q)) { throw new InsightError(); // q should be an array, and should have at least one element } fo</text>
  <text x="694" y="246" fill="rgb(255 255 255)">r (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: str</text>
  <text x="0" y="247" fill="rgb(255 255 255)">ing = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey</text>
  <text x="146" y="247" fill="rgb(237 28 36)">.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria</text>
  <text x="287" y="247" fill="rgb(255 255 255)">).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.</text>
  <text x="392" y="247" fill="rgb(24 158 180)">mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { thro</text>
  <text x="465" y="247" fill="rgb(255 255 255)">w new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError();</text>
  <text x="591" y="247" fill="rgb(237 28 36)"> } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(</text>
  <text x="695" y="247" fill="rgb(255 255 255)">key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfiel</text>
  <text x="0" y="248" fill="rgb(255 255 255)">ds.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[</text>
  <text x="145" y="248" fill="rgb(237 28 36)">] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.</text>
  <text x="286" y="248" fill="rgb(255 255 255)">COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!</text>
  <text x="389" y="248" fill="rgb(24 158 180)">q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this</text>
  <text x="469" y="248" fill="rgb(255 255 255)">.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.v</text>
  <text x="592" y="248" fill="rgb(237 28 36)">alidateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.</text>
  <text x="695" y="248" fill="rgb(255 255 255)">isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError();</text>
  <text x="0" y="249" fill="rgb(255 255 255)"> } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw n</text>
  <text x="145" y="249" fill="rgb(237 28 36)">ew InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of ke</text>
  <text x="286" y="249" fill="rgb(255 255 255)">ys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhe</text>
  <text x="386" y="249" fill="rgb(24 158 180)">re(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Obje</text>
  <text x="472" y="249" fill="rgb(255 255 255)">ct.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length</text>
  <text x="593" y="249" fill="rgb(237 28 36)"> !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Obj</text>
  <text x="695" y="249" fill="rgb(255 255 255)">ect.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case</text>
  <text x="0" y="250" fill="rgb(255 255 255)"> &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } }</text>
  <text x="144" y="250" fill="rgb(237 28 36)"> } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private</text>
  <text x="285" y="250" fill="rgb(255 255 255)"> validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (O</text>
  <text x="383" y="250" fill="rgb(24 158 180)">bject.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.ke</text>
  <text x="475" y="250" fill="rgb(255 255 255)">ys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; le</text>
  <text x="594" y="250" fill="rgb(237 28 36)">t sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { th</text>
  <text x="695" y="250" fill="rgb(255 255 255)">row new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield</text>
  <text x="0" y="251" fill="rgb(255 255 255)">)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !=</text>
  <text x="143" y="251" fill="rgb(237 28 36)">= 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); </text>
  <text x="284" y="251" fill="rgb(255 255 255)">} else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.val</text>
  <text x="380" y="251" fill="rgb(24 158 180)">ues(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.</text>
  <text x="478" y="251" fill="rgb(255 255 255)">includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(val</text>
  <text x="594" y="251" fill="rgb(237 28 36)">ue) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validate</text>
  <text x="695" y="251" fill="rgb(255 255 255)">Filter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset </text>
  <text x="0" y="252" fill="rgb(255 255 255)">of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKin</text>
  <text x="143" y="252" fill="rgb(237 28 36)">d.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = </text>
  <text x="283" y="252" fill="rgb(255 255 255)">this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(ids</text>
  <text x="377" y="252" fill="rgb(24 158 180)">tring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, Insigh</text>
  <text x="480" y="252" fill="rgb(255 255 255)">tDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursem</text>
  <text x="595" y="252" fill="rgb(237 28 36)">fields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[</text>
  <text x="695" y="252" fill="rgb(255 255 255)">] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly room</text>
  <text x="0" y="253" fill="rgb(255 255 255)">sfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = </text>
  <text x="142" y="253" fill="rgb(237 28 36)">[&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has on</text>
  <text x="283" y="253" fill="rgb(255 255 255)">e id private keysInQuery: string[]; // all keys appeared in columns after being validated p</text>
  <text x="374" y="253" fill="rgb(24 158 180)">rivate transformationKey: string[]; // keys appeared in transformation, if there is a transformation private </text>
  <text x="483" y="253" fill="rgb(255 255 255)">allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDat</text>
  <text x="596" y="253" fill="rgb(237 28 36)">asets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = [];</text>
  <text x="695" y="253" fill="rgb(255 255 255)"> this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError();</text>
  <text x="0" y="254" fill="rgb(255 255 255)"> } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } t</text>
  <text x="141" y="254" fill="rgb(237 28 36)">his.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } pu</text>
  <text x="282" y="254" fill="rgb(255 255 255)">blic validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof </text>
  <text x="372" y="254" fill="rgb(24 158 180)">q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP)</text>
  <text x="485" y="254" fill="rgb(255 255 255)">; this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { </text>
  <text x="597" y="254" fill="rgb(237 28 36)">throw new InsightError(); // q should be an object, and should has at least one element } for (let</text>
  <text x="695" y="254" fill="rgb(255 255 255)"> key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private val</text>
  <text x="0" y="255" fill="rgb(255 255 255)">idateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(t</text>
  <text x="141" y="255" fill="rgb(237 28 36)">his.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new Insig</text>
  <text x="281" y="255" fill="rgb(255 255 255)">htError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new </text>
  <text x="369" y="255" fill="rgb(24 158 180)">InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.is</text>
  <text x="488" y="255" fill="rgb(255 255 255)">Array(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Ob</text>
  <text x="598" y="255" fill="rgb(237 28 36)">ject.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applyke</text>
  <text x="695" y="255" fill="rgb(255 255 255)">y.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Arr</text>
  <text x="0" y="256" fill="rgb(255 255 255)">ay.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; i</text>
  <text x="140" y="256" fill="rgb(237 28 36)">f (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applyt</text>
  <text x="281" y="256" fill="rgb(255 255 255)">oken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.</text>
  <text x="367" y="256" fill="rgb(24 158 180)">includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); </text>
  <text x="490" y="256" fill="rgb(255 255 255)">} } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.inclu</text>
  <text x="598" y="256" fill="rgb(237 28 36)">des(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public valida</text>
  <text x="695" y="256" fill="rgb(255 255 255)">teOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new </text>
  <text x="0" y="257" fill="rgb(255 255 255)">InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void {</text>
  <text x="140" y="257" fill="rgb(237 28 36)"> if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformat</text>
  <text x="280" y="257" fill="rgb(255 255 255)">ionKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey</text>
  <text x="365" y="257" fill="rgb(24 158 180)">); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); </text>
  <text x="492" y="257" fill="rgb(255 255 255)">} else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else</text>
  <text x="599" y="257" fill="rgb(237 28 36)"> { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir</text>
  <text x="695" y="257" fill="rgb(255 255 255)"> !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw </text>
  <text x="0" y="258" fill="rgb(255 255 255)">new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validat</text>
  <text x="139" y="258" fill="rgb(237 28 36)">eWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); </text>
  <text x="280" y="258" fill="rgb(255 255 255)">} } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { thr</text>
  <text x="363" y="258" fill="rgb(24 158 180)">ow new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND</text>
  <text x="494" y="258" fill="rgb(255 255 255)">&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: cas</text>
  <text x="600" y="258" fill="rgb(237 28 36)">e &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break;</text>
  <text x="695" y="258" fill="rgb(255 255 255)"> default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(</text>
  <text x="0" y="259" fill="rgb(255 255 255)">); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (</text>
  <text x="139" y="259" fill="rgb(237 28 36)">Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2)</text>
  <text x="279" y="259" fill="rgb(255 255 255)"> { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: </text>
  <text x="361" y="259" fill="rgb(24 158 180)">string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.sl</text>
  <text x="496" y="259" fill="rgb(255 255 255)">ice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw </text>
  <text x="601" y="259" fill="rgb(237 28 36)">new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;o</text>
  <text x="695" y="259" fill="rgb(255 255 255)">bject&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.l</text>
  <text x="0" y="260" fill="rgb(255 255 255)">ength !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.valu</text>
  <text x="138" y="260" fill="rgb(237 28 36)">es(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(</text>
  <text x="278" y="260" fill="rgb(255 255 255)">); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || v</text>
  <text x="359" y="260" fill="rgb(24 158 180)">alue.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstr</text>
  <text x="498" y="260" fill="rgb(255 255 255)">ing(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.all</text>
  <text x="601" y="260" fill="rgb(237 28 36)">InsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insi</text>
  <text x="696" y="260" fill="rgb(255 255 255)">ghtDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfi</text>
  <text x="0" y="261" fill="rgb(255 255 255)">elds = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstri</text>
  <text x="137" y="261" fill="rgb(237 28 36)">ng); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsi</text>
  <text x="278" y="261" fill="rgb(255 255 255)">ghtFacade&amp;quot;; export default class QueryValidator { private readonly coursemfield</text>
  <text x="357" y="261" fill="rgb(24 158 180)">s: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;</text>
  <text x="500" y="261" fill="rgb(255 255 255)">]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: str</text>
  <text x="602" y="261" fill="rgb(237 28 36)">ing[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; </text>
  <text x="696" y="261" fill="rgb(255 255 255)">private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: stri</text>
  <text x="0" y="262" fill="rgb(255 255 255)">ng[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private</text>
  <text x="137" y="262" fill="rgb(237 28 36)"> transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; </text>
  <text x="277" y="262" fill="rgb(255 255 255)">private mfields: string[]; private sfields: string[]; constructor(insightDatas</text>
  <text x="355" y="262" fill="rgb(24 158 180)">ets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } publi</text>
  <text x="502" y="262" fill="rgb(255 255 255)">c validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let k</text>
  <text x="603" y="262" fill="rgb(237 28 36)">ey of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;</text>
  <text x="696" y="262" fill="rgb(255 255 255)">) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); </text>
  <text x="0" y="263" fill="rgb(255 255 255)">} this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY</text>
  <text x="136" y="263" fill="rgb(237 28 36)"> === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } p</text>
  <text x="276" y="263" fill="rgb(255 255 255)">rivate validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { </text>
  <text x="354" y="263" fill="rgb(24 158 180)">throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transforma</text>
  <text x="503" y="263" fill="rgb(255 255 255)">tionKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key:</text>
  <text x="603" y="263" fill="rgb(237 28 36)"> string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { </text>
  <text x="696" y="263" fill="rgb(255 255 255)">throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.include</text>
  <text x="0" y="264" fill="rgb(255 255 255)">s(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightErr</text>
  <text x="136" y="264" fill="rgb(237 28 36)">or(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys</text>
  <text x="276" y="264" fill="rgb(255 255 255)">(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string =</text>
  <text x="352" y="264" fill="rgb(24 158 180)"> Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(ap</text>
  <text x="505" y="264" fill="rgb(255 255 255)">plykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(cri</text>
  <text x="604" y="264" fill="rgb(237 28 36)">teria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: st</text>
  <text x="696" y="264" fill="rgb(255 255 255)">ring = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError();</text>
  <text x="0" y="265" fill="rgb(255 255 255)"> } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(ap</text>
  <text x="135" y="265" fill="rgb(237 28 36)">plytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.in</text>
  <text x="275" y="265" fill="rgb(255 255 255)">cludes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.</text>
  <text x="350" y="265" fill="rgb(24 158 180)">includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys</text>
  <text x="507" y="265" fill="rgb(255 255 255)">(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError();</text>
  <text x="605" y="265" fill="rgb(237 28 36)"> } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } priva</text>
  <text x="696" y="265" fill="rgb(255 255 255)">te validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKe</text>
  <text x="0" y="266" fill="rgb(255 255 255)">y.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.key</text>
  <text x="135" y="266" fill="rgb(237 28 36)">sInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;s</text>
  <text x="275" y="266" fill="rgb(255 255 255)">tring&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); }</text>
  <text x="349" y="266" fill="rgb(24 158 180)"> } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(</text>
  <text x="508" y="266" fill="rgb(255 255 255)">); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError</text>
  <text x="606" y="266" fill="rgb(237 28 36)">(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new Insig</text>
  <text x="696" y="266" fill="rgb(255 255 255)">htError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).len</text>
  <text x="0" y="267" fill="rgb(255 255 255)">gth !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new Insight</text>
  <text x="134" y="267" fill="rgb(237 28 36)">Error(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.vali</text>
  <text x="274" y="267" fill="rgb(255 255 255)">dateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case</text>
  <text x="347" y="267" fill="rgb(24 158 180)"> &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validate</text>
  <text x="510" y="267" fill="rgb(255 255 255)">NOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.valida</text>
  <text x="606" y="267" fill="rgb(237 28 36)">teFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) {</text>
  <text x="696" y="267" fill="rgb(255 255 255)"> throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0</text>
  <text x="0" y="268" fill="rgb(255 255 255)">].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]</text>
  <text x="134" y="268" fill="rgb(237 28 36)">; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;</text>
  <text x="274" y="268" fill="rgb(255 255 255)">*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfiel</text>
  <text x="346" y="268" fill="rgb(24 158 180)">d)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new Insi</text>
  <text x="511" y="268" fill="rgb(255 255 255)">ghtError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { th</text>
  <text x="607" y="268" fill="rgb(237 28 36)">row new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mke</text>
  <text x="696" y="268" fill="rgb(255 255 255)">y[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes</text>
  <text x="0" y="269" fill="rgb(255 255 255)">(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) {</text>
  <text x="134" y="269" fill="rgb(237 28 36)"> throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: stri</text>
  <text x="273" y="269" fill="rgb(255 255 255)">ng): boolean { if (this.idInQuery.length === 0) { for (let insightDatas</text>
  <text x="344" y="269" fill="rgb(24 158 180)">et of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfiel</text>
  <text x="513" y="269" fill="rgb(255 255 255)">ds = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommf</text>
  <text x="608" y="269" fill="rgb(237 28 36)">ields; this.sfields = this.roomsfields; } return true; } } return false; } else { return</text>
  <text x="696" y="269" fill="rgb(255 255 255)"> this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatas</text>
  <text x="0" y="270" fill="rgb(255 255 255)">etKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg</text>
  <text x="133" y="270" fill="rgb(237 28 36)">&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private read</text>
  <text x="272" y="270" fill="rgb(255 255 255)">only roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly </text>
  <text x="343" y="270" fill="rgb(24 158 180)">roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SU</text>
  <text x="514" y="270" fill="rgb(255 255 255)">M&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure</text>
  <text x="608" y="270" fill="rgb(237 28 36)"> the query only has one id private keysInQuery: string[]; // all keys appeared in column</text>
  <text x="696" y="270" fill="rgb(255 255 255)">s after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private all</text>
  <text x="0" y="271" fill="rgb(255 255 255)">InsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]</text>
  <text x="133" y="271" fill="rgb(237 28 36)">) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q:</text>
  <text x="272" y="271" fill="rgb(255 255 255)"> any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightErr</text>
  <text x="342" y="271" fill="rgb(24 158 180)">or(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); </text>
  <text x="516" y="271" fill="rgb(255 255 255)">if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOpti</text>
  <text x="609" y="271" fill="rgb(237 28 36)">ons(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP ===</text>
  <text x="696" y="271" fill="rgb(255 255 255)"> &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP);</text>
  <text x="0" y="272" fill="rgb(255 255 255)"> this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightErro</text>
  <text x="132" y="272" fill="rgb(237 28 36)">r(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.pus</text>
  <text x="271" y="272" fill="rgb(255 255 255)">h(key); // if the key is valid, push it to transformationKey } } priv</text>
  <text x="340" y="272" fill="rgb(24 158 180)">ate validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splitted</text>
  <text x="517" y="272" fill="rgb(255 255 255)">Key[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))</text>
  <text x="609" y="272" fill="rgb(237 28 36)">) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isAr</text>
  <text x="696" y="272" fill="rgb(255 255 255)">ray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.</text>
  <text x="0" y="273" fill="rgb(255 255 255)">isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)</text>
  <text x="132" y="273" fill="rgb(237 28 36)">[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) </text>
  <text x="271" y="273" fill="rgb(255 255 255)">{ throw new InsightError(); } this.transformationKey.push(applykey);</text>
  <text x="339" y="273" fill="rgb(24 158 180)"> if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applyt</text>
  <text x="518" y="273" fill="rgb(255 255 255)">oken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[]</text>
  <text x="610" y="273" fill="rgb(237 28 36)"> = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); </text>
  <text x="696" y="273" fill="rgb(255 255 255)">} if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError</text>
  <text x="0" y="274" fill="rgb(255 255 255)">(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this</text>
  <text x="131" y="274" fill="rgb(237 28 36)">.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); f</text>
  <text x="270" y="274" fill="rgb(255 255 255)">or (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { t</text>
  <text x="338" y="274" fill="rgb(24 158 180)">hrow new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw </text>
  <text x="520" y="274" fill="rgb(255 255 255)">new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!</text>
  <text x="611" y="274" fill="rgb(237 28 36)">this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.v</text>
  <text x="696" y="274" fill="rgb(255 255 255)">alidateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightErr</text>
  <text x="0" y="275" fill="rgb(255 255 255)">or(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !</text>
  <text x="131" y="275" fill="rgb(237 28 36)">q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } </text>
  <text x="270" y="275" fill="rgb(255 255 255)">let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1</text>
  <text x="337" y="275" fill="rgb(24 158 180)">) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.is</text>
  <text x="521" y="275" fill="rgb(255 255 255)">Array(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.val</text>
  <text x="611" y="275" fill="rgb(237 28 36)">idateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).lengt</text>
  <text x="696" y="275" fill="rgb(255 255 255)">h !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { c</text>
  <text x="0" y="276" fill="rgb(255 255 255)">ase &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;</text>
  <text x="131" y="276" fill="rgb(237 28 36)">: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNO</text>
  <text x="269" y="276" fill="rgb(255 255 255)">T(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new Ins</text>
  <text x="337" y="276" fill="rgb(24 158 180)">ightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { t</text>
  <text x="522" y="276" fill="rgb(255 255 255)">hrow new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey</text>
  <text x="612" y="276" fill="rgb(237 28 36)">.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; </text>
  <text x="696" y="276" fill="rgb(255 255 255)">let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { i</text>
  <text x="0" y="277" fill="rgb(255 255 255)">f ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightErro</text>
  <text x="130" y="277" fill="rgb(237 28 36)">r(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new Insig</text>
  <text x="269" y="277" fill="rgb(255 255 255)">htError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); </text>
  <text x="337" y="277" fill="rgb(24 158 180)">if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;num</text>
  <text x="523" y="277" fill="rgb(255 255 255)">ber&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new I</text>
  <text x="613" y="277" fill="rgb(237 28 36)">nsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(v</text>
  <text x="696" y="277" fill="rgb(255 255 255)">alue) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private v</text>
  <text x="0" y="278" fill="rgb(255 255 255)">alidateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset)</text>
  <text x="130" y="278" fill="rgb(237 28 36)"> { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfi</text>
  <text x="268" y="278" fill="rgb(255 255 255)">elds = this.coursemfields; this.sfields = this.coursesfields; } else </text>
  <text x="337" y="278" fill="rgb(24 158 180)">{ this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] </text>
  <text x="525" y="278" fill="rgb(255 255 255)">{ return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} f</text>
  <text x="613" y="278" fill="rgb(237 28 36)">rom &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly cour</text>
  <text x="696" y="278" fill="rgb(255 255 255)">semfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;</text>
  <text x="0" y="279" fill="rgb(255 255 255)">title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;full</text>
  <text x="130" y="279" fill="rgb(237 28 36)">name&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, </text>
  <text x="268" y="279" fill="rgb(255 255 255)">&amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQu</text>
  <text x="338" y="279" fill="rgb(24 158 180)">ery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appe</text>
  <text x="526" y="279" fill="rgb(255 255 255)">ared in transformation, if there is a transformation private allInsightDataset: InsightD</text>
  <text x="614" y="279" fill="rgb(237 28 36)">ataset[]; private mfields: string[]; private sfields: string[]; constructor(insigh</text>
  <text x="696" y="279" fill="rgb(255 255 255)">tDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightD</text>
  <text x="0" y="280" fill="rgb(255 255 255)">atasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object</text>
  <text x="129" y="280" fill="rgb(237 28 36)">.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WH</text>
  <text x="267" y="280" fill="rgb(255 255 255)">ERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.T</text>
  <text x="330" y="280" fill="rgb(24 158 180)">RA</text>
  <text x="332" y="280" fill="rgb(255 255 255)">NSFORMA</text>
  <text x="339" y="280" fill="rgb(24 158 180)">TIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !=</text>
  <text x="527" y="280" fill="rgb(255 255 255)">= 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.AP</text>
  <text x="614" y="280" fill="rgb(237 28 36)">PLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; </text>
  <text x="696" y="280" fill="rgb(255 255 255)">1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key)</text>
  <text x="0" y="281" fill="rgb(255 255 255)">; this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): vo</text>
  <text x="129" y="281" fill="rgb(237 28 36)">id { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(s</text>
  <text x="267" y="281" fill="rgb(255 255 255)">plittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || th</text>
  <text x="329" y="281" fill="rgb(24 158 180)">is.s</text>
  <text x="333" y="281" fill="rgb(255 255 255)">fields.</text>
  <text x="340" y="281" fill="rgb(24 158 180)">includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should hav</text>
  <text x="528" y="281" fill="rgb(255 255 255)">e at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Obj</text>
  <text x="615" y="281" fill="rgb(237 28 36)">ect.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: strin</text>
  <text x="696" y="281" fill="rgb(255 255 255)">g = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transforma</text>
  <text x="0" y="282" fill="rgb(255 255 255)">tionKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || O</text>
  <text x="129" y="282" fill="rgb(237 28 36)">bject.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includ</text>
  <text x="266" y="282" fill="rgb(255 255 255)">es(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw </text>
  <text x="328" y="282" fill="rgb(24 158 180)">new In</text>
  <text x="334" y="282" fill="rgb(255 255 255)">sightEr</text>
  <text x="341" y="282" fill="rgb(24 158 180)">ror(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]</text>
  <text x="529" y="282" fill="rgb(255 255 255)">) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mst</text>
  <text x="615" y="282" fill="rgb(237 28 36)">oken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields</text>
  <text x="696" y="282" fill="rgb(255 255 255)">.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys</text>
  <text x="0" y="283" fill="rgb(255 255 255)">: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this</text>
  <text x="128" y="283" fill="rgb(237 28 36)">.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; </text>
  <text x="266" y="283" fill="rgb(255 255 255)">1) { throw new InsightError(); } for (let mskey of q) { if (t</text>
  <text x="327" y="283" fill="rgb(24 158 180)">his.tra</text>
  <text x="334" y="283" fill="rgb(255 255 255)">nsformat</text>
  <text x="342" y="283" fill="rgb(24 158 180)">ionKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(</text>
  <text x="530" y="283" fill="rgb(255 255 255)">q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q </text>
  <text x="616" y="283" fill="rgb(237 28 36)">=== &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); }</text>
  <text x="696" y="283" fill="rgb(255 255 255)"> } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { t</text>
  <text x="0" y="284" fill="rgb(255 255 255)">hrow new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } fo</text>
  <text x="128" y="284" fill="rgb(237 28 36)">r (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void {</text>
  <text x="265" y="284" fill="rgb(255 255 255)"> if (Array.isArray(q)) { throw new InsightError(); } else { i</text>
  <text x="326" y="284" fill="rgb(24 158 180)">f (Objec</text>
  <text x="334" y="284" fill="rgb(255 255 255)">t.keys(q).</text>
  <text x="344" y="284" fill="rgb(24 158 180)">length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)</text>
  <text x="531" y="284" fill="rgb(255 255 255)">[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.</text>
  <text x="617" y="284" fill="rgb(237 28 36)">validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;</text>
  <text x="696" y="284" fill="rgb(255 255 255)">GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError()</text>
  <text x="0" y="285" fill="rgb(255 255 255)">; } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter</text>
  <text x="128" y="285" fill="rgb(237 28 36)">(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).len</text>
  <text x="265" y="285" fill="rgb(255 255 255)">gth !== 1) { throw new InsightError(); } let skey: string[] </text>
  <text x="325" y="285" fill="rgb(24 158 180)">= Object.</text>
  <text x="334" y="285" fill="rgb(255 255 255)">keys(value)</text>
  <text x="345" y="285" fill="rgb(24 158 180)">[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeo</text>
  <text x="532" y="285" fill="rgb(255 255 255)">f str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includ</text>
  <text x="617" y="285" fill="rgb(237 28 36)">es(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield))</text>
  <text x="696" y="285" fill="rgb(255 255 255)"> { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).lengt</text>
  <text x="0" y="286" fill="rgb(255 255 255)">h !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw ne</text>
  <text x="127" y="286" fill="rgb(237 28 36)">w InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typ</text>
  <text x="264" y="286" fill="rgb(255 255 255)">eof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) ||</text>
  <text x="324" y="286" fill="rgb(24 158 180)"> !this.mfi</text>
  <text x="334" y="286" fill="rgb(255 255 255)">elds.includes</text>
  <text x="347" y="286" fill="rgb(24 158 180)">(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of</text>
  <text x="533" y="286" fill="rgb(255 255 255)"> value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: st</text>
  <text x="618" y="286" fill="rgb(237 28 36)">ring): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of</text>
  <text x="696" y="286" fill="rgb(255 255 255)"> this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatase</text>
  <text x="0" y="287" fill="rgb(255 255 255)">tKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields</text>
  <text x="127" y="287" fill="rgb(237 28 36)">; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdIn</text>
  <text x="264" y="287" fill="rgb(255 255 255)">Query(): string[] { return this.idInQuery; } } import {Insi</text>
  <text x="323" y="287" fill="rgb(24 158 180)">ghtDataset,</text>
  <text x="334" y="287" fill="rgb(255 255 255)"> InsightDataset</text>
  <text x="349" y="287" fill="rgb(24 158 180)">Kind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly </text>
  <text x="534" y="287" fill="rgb(255 255 255)">coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private rea</text>
  <text x="618" y="287" fill="rgb(237 28 36)">donly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsf</text>
  <text x="696" y="287" fill="rgb(255 255 255)">ields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[]</text>
  <text x="0" y="288" fill="rgb(255 255 255)"> = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the </text>
  <text x="127" y="288" fill="rgb(237 28 36)">query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: st</text>
  <text x="263" y="288" fill="rgb(255 255 255)">ring[]; // keys appeared in transformation, if there is a t</text>
  <text x="322" y="288" fill="rgb(24 158 180)">ransformation</text>
  <text x="335" y="288" fill="rgb(255 255 255)"> private allIns</text>
  <text x="350" y="288" fill="rgb(24 158 180)">ightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.tr</text>
  <text x="535" y="288" fill="rgb(255 255 255)">ansformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q:</text>
  <text x="619" y="288" fill="rgb(237 28 36)"> any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); }</text>
  <text x="696" y="288" fill="rgb(255 255 255)"> for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } }</text>
  <text x="0" y="289" fill="rgb(255 255 255)"> this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions</text>
  <text x="126" y="289" fill="rgb(237 28 36)">(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Obj</text>
  <text x="263" y="289" fill="rgb(255 255 255)">ect.keys(q).length !== 2) { throw new InsightError(); } th</text>
  <text x="321" y="289" fill="rgb(24 158 180)">is.validateGRO</text>
  <text x="335" y="289" fill="rgb(255 255 255)">UP(q.GROUP); this</text>
  <text x="352" y="289" fill="rgb(24 158 180)">.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least on</text>
  <text x="536" y="289" fill="rgb(255 255 255)">e element } for (let key of q) { this.validateKey(key); this.transformationKey.push</text>
  <text x="619" y="289" fill="rgb(237 28 36)">(key); // if the key is valid, push it to transformationKey } } private valid</text>
  <text x="696" y="289" fill="rgb(255 255 255)">ateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!</text>
  <text x="0" y="290" fill="rgb(255 255 255)">(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) {</text>
  <text x="126" y="290" fill="rgb(237 28 36)"> throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be a</text>
  <text x="262" y="290" fill="rgb(255 255 255)">n array, and should have at least one element } for (let a</text>
  <text x="320" y="290" fill="rgb(24 158 180)">pplyrule of q) </text>
  <text x="335" y="290" fill="rgb(255 255 255)">{ if (Array.isArray</text>
  <text x="354" y="290" fill="rgb(24 158 180)">(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.leng</text>
  <text x="537" y="290" fill="rgb(255 255 255)">th === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { </text>
  <text x="620" y="290" fill="rgb(237 28 36)">throw new InsightError(); } this.transformationKey.push(applykey); if (Array</text>
  <text x="696" y="290" fill="rgb(255 255 255)">.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; </text>
  <text x="0" y="291" fill="rgb(255 255 255)">if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] =</text>
  <text x="126" y="291" fill="rgb(237 28 36)"> criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this</text>
  <text x="262" y="291" fill="rgb(255 255 255)">.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]</text>
  <text x="319" y="291" fill="rgb(24 158 180)">))) { throw new </text>
  <text x="335" y="291" fill="rgb(255 255 255)">InsightError(); } } </text>
  <text x="355" y="291" fill="rgb(24 158 180)">else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } }</text>
  <text x="538" y="291" fill="rgb(255 255 255)"> } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for </text>
  <text x="620" y="291" fill="rgb(237 28 36)">(let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new In</text>
  <text x="696" y="291" fill="rgb(255 255 255)">sightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void </text>
  <text x="0" y="292" fill="rgb(255 255 255)">{ if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!t</text>
  <text x="126" y="292" fill="rgb(237 28 36)">his.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); </text>
  <text x="261" y="292" fill="rgb(255 255 255)">} } private validateOrder(q: any): void { if (Array.isArr</text>
  <text x="318" y="292" fill="rgb(24 158 180)">ay(q)) { throw ne</text>
  <text x="335" y="292" fill="rgb(255 255 255)">w InsightError(); } el</text>
  <text x="357" y="292" fill="rgb(24 158 180)">se if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightErr</text>
  <text x="539" y="292" fill="rgb(255 255 255)">or(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let </text>
  <text x="621" y="292" fill="rgb(237 28 36)">keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw ne</text>
  <text x="696" y="292" fill="rgb(255 255 255)">w InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validat</text>
  <text x="0" y="293" fill="rgb(255 255 255)">eWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.val</text>
  <text x="125" y="293" fill="rgb(237 28 36)">idateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let k</text>
  <text x="261" y="293" fill="rgb(255 255 255)">ey: string = Object.keys(q)[0]; let value: any = Object.v</text>
  <text x="318" y="293" fill="rgb(24 158 180)">alues(q)[0]; swit</text>
  <text x="335" y="293" fill="rgb(255 255 255)">ch (key) { case &amp;quot;AND&amp;quot;: c</text>
  <text x="359" y="293" fill="rgb(24 158 180)">ase &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateI</text>
  <text x="540" y="293" fill="rgb(255 255 255)">S(value); break; default: throw new InsightError(); } } } private validateNOT(val</text>
  <text x="621" y="293" fill="rgb(237 28 36)">ue: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError();</text>
  <text x="696" y="293" fill="rgb(255 255 255)"> } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (</text>
  <text x="0" y="294" fill="rgb(255 255 255)">Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (ske</text>
  <text x="125" y="294" fill="rgb(237 28 36)">y.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object</text>
  <text x="261" y="294" fill="rgb(255 255 255)">.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw </text>
  <text x="317" y="294" fill="rgb(24 158 180)">new InsightError()</text>
  <text x="335" y="294" fill="rgb(255 255 255)">; } else { if ((str.slice(</text>
  <text x="361" y="294" fill="rgb(24 158 180)">1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (type</text>
  <text x="541" y="294" fill="rgb(255 255 255)">of value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightErro</text>
  <text x="622" y="294" fill="rgb(237 28 36)">r(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.len</text>
  <text x="696" y="294" fill="rgb(255 255 255)">gth !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.value</text>
  <text x="0" y="295" fill="rgb(255 255 255)">s(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new</text>
  <text x="125" y="295" fill="rgb(237 28 36)"> InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightErro</text>
  <text x="260" y="295" fill="rgb(255 255 255)">r(); } for (let innerObject of value) { this.validateFil</text>
  <text x="316" y="295" fill="rgb(24 158 180)">ter(innerObject); }</text>
  <text x="335" y="295" fill="rgb(255 255 255)"> } private validateIdstring(</text>
  <text x="363" y="295" fill="rgb(24 158 180)">idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idst</text>
  <text x="542" y="295" fill="rgb(255 255 255)">ring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = </text>
  <text x="622" y="295" fill="rgb(237 28 36)">this.coursemfields; this.sfields = this.coursesfields; } else { this.mfiel</text>
  <text x="696" y="295" fill="rgb(255 255 255)">ds = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring</text>
  <text x="0" y="296" fill="rgb(255 255 255)">); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError}</text>
  <text x="125" y="296" fill="rgb(237 28 36)"> from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;aud</text>
  <text x="260" y="296" fill="rgb(255 255 255)">it&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] </text>
  <text x="315" y="296" fill="rgb(24 158 180)">= [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;in</text>
  <text x="335" y="296" fill="rgb(255 255 255)">structor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; p</text>
  <text x="365" y="296" fill="rgb(24 158 180)">rivate readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furnitu</text>
  <text x="543" y="296" fill="rgb(255 255 255)">re&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; </text>
  <text x="623" y="296" fill="rgb(237 28 36)">private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string</text>
  <text x="696" y="296" fill="rgb(255 255 255)">[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private t</text>
  <text x="0" y="297" fill="rgb(255 255 255)">ransformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: Insi</text>
  <text x="124" y="297" fill="rgb(237 28 36)">ghtDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = [</text>
  <text x="259" y="297" fill="rgb(255 255 255)">]; this.keysInQuery = []; this.transformationKey = []; </text>
  <text x="314" y="297" fill="rgb(24 158 180)">this.allInsightDatase</text>
  <text x="335" y="297" fill="rgb(255 255 255)">t = insightDatasets; } public va</text>
  <text x="367" y="297" fill="rgb(24 158 180)">lidate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TR</text>
  <text x="543" y="297" fill="rgb(255 255 255)">ANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if </text>
  <text x="623" y="297" fill="rgb(237 28 36)">(q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } </text>
  <text x="696" y="297" fill="rgb(255 255 255)">this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY ==</text>
  <text x="0" y="298" fill="rgb(255 255 255)">= &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(</text>
  <text x="124" y="298" fill="rgb(237 28 36)">q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an </text>
  <text x="259" y="298" fill="rgb(255 255 255)">object, and should has at least one element } for (let</text>
  <text x="313" y="298" fill="rgb(24 158 180)"> key of q) { this.valid</text>
  <text x="336" y="298" fill="rgb(255 255 255)">ateKey(key); this.transformationK</text>
  <text x="369" y="298" fill="rgb(24 158 180)">ey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.len</text>
  <text x="544" y="298" fill="rgb(255 255 255)">gth !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey</text>
  <text x="624" y="298" fill="rgb(237 28 36)">[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(</text>
  <text x="696" y="298" fill="rgb(255 255 255)">splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(</text>
  <text x="0" y="299" fill="rgb(255 255 255)">); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) |</text>
  <text x="124" y="299" fill="rgb(237 28 36)">| Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = app</text>
  <text x="259" y="299" fill="rgb(255 255 255)">lyrule[applykey]; if (applykey.length === 0 || applyke</text>
  <text x="313" y="299" fill="rgb(24 158 180)">y.includes(&amp;quot;_&amp;quot;) || this</text>
  <text x="336" y="299" fill="rgb(255 255 255)">.transformationKey.includes(applyke</text>
  <text x="371" y="299" fill="rgb(24 158 180)">y)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let ap</text>
  <text x="545" y="299" fill="rgb(255 255 255)">plytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytok</text>
  <text x="624" y="299" fill="rgb(237 28 36)">en) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); }</text>
  <text x="696" y="299" fill="rgb(255 255 255)"> let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applyt</text>
  <text x="0" y="300" fill="rgb(255 255 255)">oken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (thi</text>
  <text x="124" y="300" fill="rgb(237 28 36)">s.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1</text>
  <text x="258" y="300" fill="rgb(255 255 255)">])))) { throw new InsightError(); } } } } public valid</text>
  <text x="312" y="300" fill="rgb(24 158 180)">ateOptions(q: any): void</text>
  <text x="336" y="300" fill="rgb(255 255 255)"> { let keys: any[] = Object.keys(q); </text>
  <text x="373" y="300" fill="rgb(24 158 180)">for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER)</text>
  <text x="546" y="300" fill="rgb(255 255 255)">; } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw </text>
  <text x="624" y="300" fill="rgb(237 28 36)">new InsightError(); } for (let mskey of q) { if (this.transformationKey.</text>
  <text x="696" y="300" fill="rgb(255 255 255)">length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQ</text>
  <text x="0" y="301" fill="rgb(255 255 255)">uery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typ</text>
  <text x="124" y="301" fill="rgb(237 28 36)">eof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q</text>
  <text x="258" y="301" fill="rgb(255 255 255)">).length !== 2) { throw new InsightError(); } if (q.d</text>
  <text x="311" y="301" fill="rgb(24 158 180)">ir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== </text>
  <text x="336" y="301" fill="rgb(255 255 255)">&amp;quot;DOWN&amp;quot;) { throw new InsightError(); } l</text>
  <text x="375" y="301" fill="rgb(24 158 180)">et keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw</text>
  <text x="547" y="301" fill="rgb(255 255 255)"> new InsightError(); } } } } public validateWhere(q: any): void { if (Array.is</text>
  <text x="625" y="301" fill="rgb(237 28 36)">Array(q)) { throw new InsightError(); } else { if (Object.keys(q).lengt</text>
  <text x="696" y="301" fill="rgb(255 255 255)">h !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError</text>
  <text x="0" y="302" fill="rgb(255 255 255)">(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR</text>
  <text x="123" y="302" fill="rgb(237 28 36)">&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(</text>
  <text x="257" y="302" fill="rgb(255 255 255)">value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); bre</text>
  <text x="310" y="302" fill="rgb(24 158 180)">ak; default: throw new Ins</text>
  <text x="336" y="302" fill="rgb(255 255 255)">ightError(); } } } private validateNOT(val</text>
  <text x="378" y="302" fill="rgb(24 158 180)">ue: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;</text>
  <text x="547" y="302" fill="rgb(255 255 255)">object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { </text>
  <text x="625" y="302" fill="rgb(237 28 36)">throw new InsightError(); } let skey: string[] = Object.keys(value)[0].</text>
  <text x="696" y="302" fill="rgb(255 255 255)">split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let</text>
  <text x="0" y="303" fill="rgb(255 255 255)"> str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1</text>
  <text x="123" y="303" fill="rgb(237 28 36)">).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private va</text>
  <text x="257" y="303" fill="rgb(255 255 255)">lidateGTLTEQ(value: any): void { if (typeof value !=</text>
  <text x="309" y="303" fill="rgb(24 158 180)">= &amp;quot;object&amp;quot; || Object.keys(v</text>
  <text x="336" y="303" fill="rgb(255 255 255)">alue).length !== 1) { throw new InsightError</text>
  <text x="380" y="303" fill="rgb(24 158 180)">(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: str</text>
  <text x="548" y="303" fill="rgb(255 255 255)">ing = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;nu</text>
  <text x="626" y="303" fill="rgb(237 28 36)">mber&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(m</text>
  <text x="696" y="303" fill="rgb(255 255 255)">field)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { thro</text>
  <text x="0" y="304" fill="rgb(255 255 255)">w new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(ids</text>
  <text x="123" y="304" fill="rgb(237 28 36)">tring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.i</text>
  <text x="257" y="304" fill="rgb(255 255 255)">d === idstring) { this.idInQuery.push(idstring); if </text>
  <text x="309" y="304" fill="rgb(24 158 180)">(insightDataset.kind === Ins</text>
  <text x="337" y="304" fill="rgb(255 255 255)">ightDatasetKind.Courses) { this.mfields = this</text>
  <text x="383" y="304" fill="rgb(24 158 180)">.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else </text>
  <text x="549" y="304" fill="rgb(255 255 255)">{ return this.idInQuery.includes(idstring); } } public getIdInQuery(): string</text>
  <text x="626" y="304" fill="rgb(237 28 36)">[] { return this.idInQuery; } } import {InsightDataset, InsightDataset</text>
  <text x="696" y="304" fill="rgb(255 255 255)">Kind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pa</text>
  <text x="0" y="305" fill="rgb(255 255 255)">ss&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; pr</text>
  <text x="123" y="305" fill="rgb(237 28 36)">ivate readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;n</text>
  <text x="256" y="305" fill="rgb(255 255 255)">umber&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;hr</text>
  <text x="308" y="305" fill="rgb(24 158 180)">ef&amp;quot;]; private readonly mtoken</text>
  <text x="337" y="305" fill="rgb(255 255 255)">: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; priva</text>
  <text x="385" y="305" fill="rgb(24 158 180)">te readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in</text>
  <text x="550" y="305" fill="rgb(255 255 255)"> columns after being validated private transformationKey: string[]; // keys </text>
  <text x="626" y="305" fill="rgb(237 28 36)">appeared in transformation, if there is a transformation private allIn</text>
  <text x="696" y="305" fill="rgb(255 255 255)">sightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { th</text>
  <text x="0" y="306" fill="rgb(255 255 255)">is.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public v</text>
  <text x="123" y="306" fill="rgb(237 28 36)">alidate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !==</text>
  <text x="256" y="306" fill="rgb(255 255 255)"> &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORM</text>
  <text x="307" y="306" fill="rgb(24 158 180)">ATIONS&amp;quot;) { throw new InsightEr</text>
  <text x="337" y="306" fill="rgb(255 255 255)">ror(); } } this.validateWhere(q.WHERE); if (q.TRANS</text>
  <text x="388" y="306" fill="rgb(24 158 180)">FORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GR</text>
  <text x="550" y="306" fill="rgb(255 255 255)">OUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).lengt</text>
  <text x="627" y="306" fill="rgb(237 28 36)">h !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); t</text>
  <text x="696" y="306" fill="rgb(255 255 255)">his.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); //</text>
  <text x="0" y="307" fill="rgb(255 255 255)"> q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformati</text>
  <text x="123" y="307" fill="rgb(237 28 36)">onKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: s</text>
  <text x="256" y="307" fill="rgb(255 255 255)">tring[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !=</text>
  <text x="307" y="307" fill="rgb(24 158 180)">= 2) { throw new InsightError(</text>
  <text x="337" y="307" fill="rgb(255 255 255)">); } if (!(this.val</text>
  <text x="356" y="307" fill="rgb(24 158 180)">idate</text>
  <text x="361" y="307" fill="rgb(255 255 255)">Idstring(splittedKey[0]) &amp;amp;&amp;amp; (</text>
  <text x="390" y="307" fill="rgb(24 158 180)">this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Arra</text>
  <text x="551" y="307" fill="rgb(255 255 255)">y.isArray(q)) { throw new InsightError(); // q should be an array, and shoul</text>
  <text x="627" y="307" fill="rgb(237 28 36)">d have at least one element } for (let applyrule of q) { if (Array.is</text>
  <text x="696" y="307" fill="rgb(255 255 255)">Array(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; le</text>
  <text x="0" y="308" fill="rgb(255 255 255)">t criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(a</text>
  <text x="122" y="308" fill="rgb(237 28 36)">pplykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).l</text>
  <text x="255" y="308" fill="rgb(255 255 255)">ength &amp;gt; 1) { throw new InsightError(); } let applyt</text>
  <text x="306" y="308" fill="rgb(24 158 180)">oken: string = Object.keys(crite</text>
  <text x="338" y="308" fill="rgb(255 255 255)">ria)[0]; if (!this.</text>
  <text x="357" y="308" fill="rgb(24 158 180)">mtoken.</text>
  <text x="364" y="308" fill="rgb(255 255 255)">includes(applytoken) &amp;amp;&amp;amp; !this</text>
  <text x="393" y="308" fill="rgb(24 158 180)">.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightErro</text>
  <text x="552" y="308" fill="rgb(255 255 255)">r(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(k</text>
  <text x="628" y="308" fill="rgb(237 28 36)">ey[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError()</text>
  <text x="696" y="308" fill="rgb(255 255 255)">; } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields</text>
  <text x="0" y="309" fill="rgb(255 255 255)">.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.k</text>
  <text x="122" y="309" fill="rgb(237 28 36)">eys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLU</text>
  <text x="255" y="309" fill="rgb(255 255 255)">MNS); if (q.ORDER) { this.validateOrder(q.ORDER); </text>
  <text x="305" y="309" fill="rgb(24 158 180)">} } private validateColumns(q: an</text>
  <text x="338" y="309" fill="rgb(255 255 255)">y): void { if (!q |</text>
  <text x="357" y="309" fill="rgb(24 158 180)">| q.length</text>
  <text x="367" y="309" fill="rgb(255 255 255)"> &amp;lt; 1) { throw new InsightErro</text>
  <text x="396" y="309" fill="rgb(24 158 180)">r(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { th</text>
  <text x="553" y="309" fill="rgb(255 255 255)">is.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validate</text>
  <text x="628" y="309" fill="rgb(237 28 36)">Order(q: any): void { if (Array.isArray(q)) { throw new InsightError</text>
  <text x="696" y="309" fill="rgb(255 255 255)">(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys |</text>
  <text x="0" y="310" fill="rgb(255 255 255)">| Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightEr</text>
  <text x="122" y="310" fill="rgb(237 28 36)">ror(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) </text>
  <text x="255" y="310" fill="rgb(255 255 255)">{ if (!this.keysInQuery.includes(anykey)) { throw </text>
  <text x="305" y="310" fill="rgb(24 158 180)">new InsightError(); } } } } publi</text>
  <text x="338" y="310" fill="rgb(255 255 255)">c validateWhere(q: </text>
  <text x="357" y="310" fill="rgb(24 158 180)">any): void {</text>
  <text x="369" y="310" fill="rgb(255 255 255)"> if (Array.isArray(q)) { throw</text>
  <text x="399" y="310" fill="rgb(24 158 180)"> new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).l</text>
  <text x="553" y="310" fill="rgb(255 255 255)">ength !== 1) { throw new InsightError(); } else { let key: string = Object.</text>
  <text x="628" y="310" fill="rgb(237 28 36)">keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { cas</text>
  <text x="696" y="310" fill="rgb(255 255 255)">e &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.v</text>
  <text x="0" y="311" fill="rgb(255 255 255)">alidateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private va</text>
  <text x="122" y="311" fill="rgb(237 28 36)">lidateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private val</text>
  <text x="254" y="311" fill="rgb(255 255 255)">idateIS(value: any): void { if (typeof value !== &amp;quot;</text>
  <text x="304" y="311" fill="rgb(24 158 180)">object&amp;quot;) { throw new InsightError(</text>
  <text x="338" y="311" fill="rgb(255 255 255)">); } if (Object.keys</text>
  <text x="358" y="311" fill="rgb(24 158 180)">(value).length</text>
  <text x="372" y="311" fill="rgb(255 255 255)"> !== 1) { throw new InsightErr</text>
  <text x="402" y="311" fill="rgb(24 158 180)">or(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0</text>
  <text x="554" y="311" fill="rgb(255 255 255)">]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if</text>
  <text x="629" y="311" fill="rgb(237 28 36)"> (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if </text>
  <text x="696" y="311" fill="rgb(255 255 255)">((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } </text>
  <text x="0" y="312" fill="rgb(255 255 255)">} } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw n</text>
  <text x="122" y="312" fill="rgb(237 28 36)">ew InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } els</text>
  <text x="254" y="312" fill="rgb(255 255 255)">e { let idstring: string = mkey[0]; let mfield: s</text>
  <text x="303" y="312" fill="rgb(24 158 180)">tring = mkey[1]; let num: any = Obje</text>
  <text x="339" y="312" fill="rgb(255 255 255)">ct.values(value)[0]</text>
  <text x="358" y="312" fill="rgb(24 158 180)">; if ((typeof nu</text>
  <text x="374" y="312" fill="rgb(255 255 255)">m !== &amp;quot;number&amp;quot;) || !this.valida</text>
  <text x="405" y="312" fill="rgb(24 158 180)">teIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray</text>
  <text x="555" y="312" fill="rgb(255 255 255)">(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerO</text>
  <text x="629" y="312" fill="rgb(237 28 36)">bject of value) { this.validateFilter(innerObject); } } private val</text>
  <text x="696" y="312" fill="rgb(255 255 255)">idateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (in</text>
  <text x="0" y="313" fill="rgb(255 255 255)">sightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { t</text>
  <text x="122" y="313" fill="rgb(237 28 36)">his.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.r</text>
  <text x="254" y="313" fill="rgb(255 255 255)">oomsfields; } return true; } } return false; } el</text>
  <text x="303" y="313" fill="rgb(24 158 180)">se { return this.idInQuery.includes(</text>
  <text x="339" y="313" fill="rgb(255 255 255)">idstring); } } publi</text>
  <text x="359" y="313" fill="rgb(24 158 180)">c getIdInQuery():</text>
  <text x="376" y="313" fill="rgb(255 255 255)"> string[] { return this.idInQuer</text>
  <text x="408" y="313" fill="rgb(24 158 180)">y; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly co</text>
  <text x="555" y="313" fill="rgb(255 255 255)">ursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private </text>
  <text x="629" y="313" fill="rgb(237 28 36)">readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;t</text>
  <text x="695" y="313" fill="rgb(255 255 255)">itle&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;s</text>
  <text x="0" y="314" fill="rgb(255 255 255)">hortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;,</text>
  <text x="121" y="314" fill="rgb(237 28 36)"> &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id </text>
  <text x="253" y="314" fill="rgb(255 255 255)">private keysInQuery: string[]; // all keys appear</text>
  <text x="302" y="314" fill="rgb(24 158 180)">ed in columns after being validated p</text>
  <text x="339" y="314" fill="rgb(255 255 255)">rivate transformatio</text>
  <text x="359" y="314" fill="rgb(24 158 180)">nKey: string[]; // </text>
  <text x="378" y="314" fill="rgb(255 255 255)">keys appeared in transformation, i</text>
  <text x="412" y="314" fill="rgb(24 158 180)">f there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insig</text>
  <text x="556" y="314" fill="rgb(255 255 255)">htDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []</text>
  <text x="630" y="314" fill="rgb(237 28 36)">; this.transformationKey = []; this.allInsightDataset = insightDa</text>
  <text x="695" y="314" fill="rgb(255 255 255)">tasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) </text>
  <text x="0" y="315" fill="rgb(255 255 255)">{ if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhe</text>
  <text x="121" y="315" fill="rgb(237 28 36)">re(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public v</text>
  <text x="253" y="315" fill="rgb(255 255 255)">alidateTransformations(q: any): void { if (typeof</text>
  <text x="302" y="315" fill="rgb(24 158 180)"> q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.A</text>
  <text x="340" y="315" fill="rgb(255 255 255)">PPLY === &amp;quot;undefined</text>
  <text x="359" y="315" fill="rgb(24 158 180)">&amp;quot; || Object.keys(q).l</text>
  <text x="380" y="315" fill="rgb(255 255 255)">ength !== 2) { throw new InsightErr</text>
  <text x="415" y="315" fill="rgb(24 158 180)">or(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; </text>
  <text x="557" y="315" fill="rgb(255 255 255)">1) { throw new InsightError(); // q should be an object, and should has a</text>
  <text x="630" y="315" fill="rgb(237 28 36)">t least one element } for (let key of q) { this.validateKey(key);</text>
  <text x="695" y="315" fill="rgb(255 255 255)"> this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let s</text>
  <text x="0" y="316" fill="rgb(255 255 255)">plittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIds</text>
  <text x="121" y="316" fill="rgb(237 28 36)">tring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError</text>
  <text x="253" y="316" fill="rgb(255 255 255)">(); } } private validateAPPLY(q: any): void { if</text>
  <text x="301" y="316" fill="rgb(24 158 180)"> (!Array.isArray(q)) { throw new Insigh</text>
  <text x="340" y="316" fill="rgb(255 255 255)">tError(); // q shoul</text>
  <text x="360" y="316" fill="rgb(24 158 180)">d be an array, and shou</text>
  <text x="383" y="316" fill="rgb(255 255 255)">ld have at least one element } for (</text>
  <text x="419" y="316" fill="rgb(24 158 180)">let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: strin</text>
  <text x="557" y="316" fill="rgb(255 255 255)">g = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (app</text>
  <text x="631" y="316" fill="rgb(237 28 36)">lykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformat</text>
  <text x="695" y="316" fill="rgb(255 255 255)">ionKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys</text>
  <text x="0" y="317" fill="rgb(255 255 255)">(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.</text>
  <text x="121" y="317" fill="rgb(237 28 36)">includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].</text>
  <text x="252" y="317" fill="rgb(255 255 255)">split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new In</text>
  <text x="300" y="317" fill="rgb(24 158 180)">sightError(); } if (this.mtoken.includes</text>
  <text x="340" y="317" fill="rgb(255 255 255)">(applytoken)) { if (</text>
  <text x="360" y="317" fill="rgb(24 158 180)">!(this.validateIdstring(k</text>
  <text x="385" y="317" fill="rgb(255 255 255)">ey[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1</text>
  <text x="422" y="317" fill="rgb(24 158 180)">]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.</text>
  <text x="558" y="317" fill="rgb(255 255 255)">includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightE</text>
  <text x="631" y="317" fill="rgb(237 28 36)">rror(); } } } } public validateOptions(q: any): void { let keys:</text>
  <text x="695" y="317" fill="rgb(255 255 255)"> any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateCo</text>
  <text x="0" y="318" fill="rgb(255 255 255)">lumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.len</text>
  <text x="121" y="318" fill="rgb(237 28 36)">gth &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.</text>
  <text x="252" y="318" fill="rgb(255 255 255)">includes(mskey)) { throw new InsightError(); } }</text>
  <text x="300" y="318" fill="rgb(24 158 180)"> else { this.validateKey(mskey); } this.k</text>
  <text x="341" y="318" fill="rgb(255 255 255)">eysInQuery.push(mske</text>
  <text x="361" y="318" fill="rgb(24 158 180)">y); } } private validateOrd</text>
  <text x="388" y="318" fill="rgb(255 255 255)">er(q: any): void { if (Array.isArray(q</text>
  <text x="426" y="318" fill="rgb(24 158 180)">)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } }</text>
  <text x="559" y="318" fill="rgb(255 255 255)"> else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw ne</text>
  <text x="631" y="318" fill="rgb(237 28 36)">w InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { th</text>
  <text x="695" y="318" fill="rgb(255 255 255)">row new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anyk</text>
  <text x="0" y="319" fill="rgb(255 255 255)">ey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): v</text>
  <text x="121" y="319" fill="rgb(237 28 36)">oid { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } p</text>
  <text x="252" y="319" fill="rgb(255 255 255)">rivate validateFilter(q: any): void { if (Objec</text>
  <text x="299" y="319" fill="rgb(24 158 180)">t.keys(q).length !== 1) { throw new Insigh</text>
  <text x="341" y="319" fill="rgb(255 255 255)">tError(); } else { l</text>
  <text x="361" y="319" fill="rgb(24 158 180)">et key: string = Object.keys(q</text>
  <text x="391" y="319" fill="rgb(255 255 255)">)[0]; let value: any = Object.values(q</text>
  <text x="429" y="319" fill="rgb(24 158 180)">)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT</text>
  <text x="559" y="319" fill="rgb(255 255 255)">&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: t</text>
  <text x="631" y="319" fill="rgb(237 28 36)">his.validateIS(value); break; default: throw new InsightError();</text>
  <text x="695" y="319" fill="rgb(255 255 255)"> } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } </text>
  <text x="0" y="320" fill="rgb(255 255 255)">private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value</text>
  <text x="121" y="320" fill="rgb(237 28 36)">).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { thro</text>
  <text x="251" y="320" fill="rgb(255 255 255)">w new InsightError(); } else { let idstring: str</text>
  <text x="299" y="320" fill="rgb(24 158 180)">ing = skey[0]; let sfield: string = skey[1]</text>
  <text x="342" y="320" fill="rgb(255 255 255)">; let str: any = Obj</text>
  <text x="362" y="320" fill="rgb(24 158 180)">ect.values(value)[0]; if (typeo</text>
  <text x="393" y="320" fill="rgb(255 255 255)">f str !== &amp;quot;string&amp;quot;) { throw new Insight</text>
  <text x="432" y="320" fill="rgb(24 158 180)">Error(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { </text>
  <text x="560" y="320" fill="rgb(255 255 255)">throw new InsightError(); } } } } private validateGTLTEQ(value: any): vo</text>
  <text x="632" y="320" fill="rgb(237 28 36)">id { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length</text>
  <text x="695" y="320" fill="rgb(255 255 255)"> !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightErr</text>
  <text x="0" y="321" fill="rgb(255 255 255)">or(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if (</text>
  <text x="121" y="321" fill="rgb(237 28 36)">(typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } }</text>
  <text x="251" y="321" fill="rgb(255 255 255)"> private validateANDOR(value: any): void { if (</text>
  <text x="298" y="321" fill="rgb(24 158 180)">!Array.isArray(value) || value.length &amp;lt; 1) {</text>
  <text x="342" y="321" fill="rgb(255 255 255)"> throw new InsightEr</text>
  <text x="362" y="321" fill="rgb(24 158 180)">ror(); } for (let innerObject of v</text>
  <text x="396" y="321" fill="rgb(255 255 255)">alue) { this.validateFilter(innerObject</text>
  <text x="435" y="321" fill="rgb(24 158 180)">); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of th</text>
  <text x="560" y="321" fill="rgb(255 255 255)">is.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQ</text>
  <text x="632" y="321" fill="rgb(237 28 36)">uery.push(idstring); if (insightDataset.kind === InsightDataset</text>
  <text x="695" y="321" fill="rgb(255 255 255)">Kind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfiel</text>
  <text x="0" y="322" fill="rgb(255 255 255)">ds = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public ge</text>
  <text x="120" y="322" fill="rgb(237 28 36)">tIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacad</text>
  <text x="251" y="322" fill="rgb(255 255 255)">e&amp;quot;; export default class QueryValidator { priva</text>
  <text x="298" y="322" fill="rgb(24 158 180)">te readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;</text>
  <text x="342" y="322" fill="rgb(255 255 255)">, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;au</text>
  <text x="363" y="322" fill="rgb(24 158 180)">dit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly cour</text>
  <text x="399" y="322" fill="rgb(255 255 255)">sesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;i</text>
  <text x="438" y="322" fill="rgb(24 158 180)">nstructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfield</text>
  <text x="561" y="322" fill="rgb(255 255 255)">s: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;</text>
  <text x="632" y="322" fill="rgb(237 28 36)">type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] </text>
  <text x="695" y="322" fill="rgb(255 255 255)">= [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only h</text>
  <text x="0" y="323" fill="rgb(255 255 255)">as one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey</text>
  <text x="120" y="323" fill="rgb(237 28 36)">: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private m</text>
  <text x="251" y="323" fill="rgb(255 255 255)">fields: string[]; private sfields: string[]; c</text>
  <text x="297" y="323" fill="rgb(24 158 180)">onstructor(insightDatasets: InsightDataset[]) </text>
  <text x="343" y="323" fill="rgb(255 255 255)">{ this.idInQuery = [</text>
  <text x="363" y="323" fill="rgb(24 158 180)">]; this.keysInQuery = []; this.transfo</text>
  <text x="401" y="323" fill="rgb(255 255 255)">rmationKey = []; this.allInsightDataset</text>
  <text x="440" y="323" fill="rgb(24 158 180)"> = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for</text>
  <text x="561" y="323" fill="rgb(255 255 255)"> (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; </text>
  <text x="633" y="323" fill="rgb(237 28 36)">&amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } </text>
  <text x="695" y="323" fill="rgb(255 255 255)">this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); </text>
  <text x="0" y="324" fill="rgb(255 255 255)">} public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; ||</text>
  <text x="120" y="324" fill="rgb(237 28 36)"> Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private va</text>
  <text x="250" y="324" fill="rgb(255 255 255)">lidateGROUP(q: any): void { if (!Array.isArray(</text>
  <text x="297" y="324" fill="rgb(24 158 180)">q) || q.length &amp;lt; 1) { throw new InsightError()</text>
  <text x="343" y="324" fill="rgb(255 255 255)">; // q should be an o</text>
  <text x="364" y="324" fill="rgb(24 158 180)">bject, and should has at least one eleme</text>
  <text x="404" y="324" fill="rgb(255 255 255)">nt } for (let key of q) { this.validat</text>
  <text x="442" y="324" fill="rgb(24 158 180)">eKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKe</text>
  <text x="562" y="324" fill="rgb(255 255 255)">y(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (</text>
  <text x="633" y="324" fill="rgb(237 28 36)">splittedKey.length !== 2) { throw new InsightError(); } if (!(</text>
  <text x="695" y="324" fill="rgb(255 255 255)">this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new In</text>
  <text x="0" y="325" fill="rgb(255 255 255)">sightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should b</text>
  <text x="120" y="325" fill="rgb(237 28 36)">e an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrul</text>
  <text x="250" y="325" fill="rgb(255 255 255)">e).length &amp;gt; 1) { throw new InsightError(); } l</text>
  <text x="296" y="325" fill="rgb(24 158 180)">et applykey: string = Object.keys(applyrule)[0];</text>
  <text x="344" y="325" fill="rgb(255 255 255)"> let criteria = appl</text>
  <text x="364" y="325" fill="rgb(24 158 180)">yrule[applykey]; if (applykey.length === 0 </text>
  <text x="407" y="325" fill="rgb(255 255 255)">|| applykey.includes(&amp;quot;_&amp;quot;) || this.tran</text>
  <text x="445" y="325" fill="rgb(24 158 180)">sformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isAr</text>
  <text x="562" y="325" fill="rgb(255 255 255)">ray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightE</text>
  <text x="633" y="325" fill="rgb(237 28 36)">rror(); } let applytoken: string = Object.keys(criteria)[0]; </text>
  <text x="694" y="325" fill="rgb(255 255 255)">if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[app</text>
  <text x="0" y="326" fill="rgb(255 255 255)">lytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(t</text>
  <text x="120" y="326" fill="rgb(237 28 36)">his.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(app</text>
  <text x="250" y="326" fill="rgb(255 255 255)">lytoken)) { if (!(this.validateIdstring(key[0]</text>
  <text x="296" y="326" fill="rgb(24 158 180)">) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfie</text>
  <text x="344" y="326" fill="rgb(255 255 255)">lds.includes(key[1]))</text>
  <text x="365" y="326" fill="rgb(24 158 180)">)) { throw new InsightError(); } } } } public</text>
  <text x="410" y="326" fill="rgb(255 255 255)"> validateOptions(q: any): void { let </text>
  <text x="447" y="326" fill="rgb(24 158 180)">keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new Insight</text>
  <text x="562" y="326" fill="rgb(255 255 255)">Error(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.valida</text>
  <text x="634" y="326" fill="rgb(237 28 36)">teOrder(q.ORDER); } } private validateColumns(q: any): void </text>
  <text x="694" y="326" fill="rgb(255 255 255)">{ if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transform</text>
  <text x="0" y="327" fill="rgb(255 255 255)">ationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey)</text>
  <text x="120" y="327" fill="rgb(237 28 36)">; } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { </text>
  <text x="250" y="327" fill="rgb(255 255 255)">if (!this.keysInQuery.includes(q)) { throw ne</text>
  <text x="295" y="327" fill="rgb(24 158 180)">w InsightError(); } } else { if (!q.dir || !q.keys</text>
  <text x="345" y="327" fill="rgb(255 255 255)"> || Object.keys(q).le</text>
  <text x="366" y="327" fill="rgb(24 158 180)">ngth !== 2) { throw new InsightError(); } if (</text>
  <text x="412" y="327" fill="rgb(255 255 255)">q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) {</text>
  <text x="449" y="327" fill="rgb(24 158 180)"> throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new Insi</text>
  <text x="563" y="327" fill="rgb(255 255 255)">ghtError(); } for (let anykey of keys) { if (!this.keysInQuery.includes</text>
  <text x="634" y="327" fill="rgb(237 28 36)">(anykey)) { throw new InsightError(); } } } } public validat</text>
  <text x="694" y="327" fill="rgb(255 255 255)">eWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q)</text>
  <text x="0" y="328" fill="rgb(255 255 255)">; } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let</text>
  <text x="120" y="328" fill="rgb(237 28 36)"> key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(</text>
  <text x="249" y="328" fill="rgb(255 255 255)">value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(va</text>
  <text x="295" y="328" fill="rgb(24 158 180)">lue); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this</text>
  <text x="345" y="328" fill="rgb(255 255 255)">.validateGTLTEQ(value</text>
  <text x="366" y="328" fill="rgb(24 158 180)">); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); brea</text>
  <text x="415" y="328" fill="rgb(255 255 255)">k; default: throw new InsightError()</text>
  <text x="451" y="328" fill="rgb(24 158 180)">; } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } thi</text>
  <text x="563" y="328" fill="rgb(255 255 255)">s.validateFilter(value); } private validateIS(value: any): void { if (t</text>
  <text x="634" y="328" fill="rgb(237 28 36)">ypeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (</text>
  <text x="694" y="328" fill="rgb(255 255 255)">Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2</text>
  <text x="0" y="329" fill="rgb(255 255 255)">) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Obje</text>
  <text x="120" y="329" fill="rgb(237 28 36)">ct.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !t</text>
  <text x="249" y="329" fill="rgb(255 255 255)">his.validateIdstring(idstring) || !this.sfiel</text>
  <text x="294" y="329" fill="rgb(24 158 180)">ds.includes(sfield)) { throw new InsightError(); } }</text>
  <text x="346" y="329" fill="rgb(255 255 255)"> } } private validate</text>
  <text x="367" y="329" fill="rgb(24 158 180)">GTLTEQ(value: any): void { if (typeof value !== &amp;quot;ob</text>
  <text x="418" y="329" fill="rgb(255 255 255)">ject&amp;quot; || Object.keys(value).length</text>
  <text x="452" y="329" fill="rgb(24 158 180)"> !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !==</text>
  <text x="564" y="329" fill="rgb(255 255 255)"> 2) { throw new InsightError(); } else { let idstring: string = mkey[0</text>
  <text x="634" y="329" fill="rgb(237 28 36)">]; let mfield: string = mkey[1]; let num: any = Object.value</text>
  <text x="694" y="329" fill="rgb(255 255 255)">s(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(</text>
  <text x="0" y="330" fill="rgb(255 255 255)">); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightErr</text>
  <text x="120" y="330" fill="rgb(237 28 36)">or(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolea</text>
  <text x="249" y="330" fill="rgb(255 255 255)">n { if (this.idInQuery.length === 0) { for (l</text>
  <text x="294" y="330" fill="rgb(24 158 180)">et insightDataset of this.allInsightDataset) { if (i</text>
  <text x="346" y="330" fill="rgb(255 255 255)">nsightDataset.id === </text>
  <text x="367" y="330" fill="rgb(24 158 180)">idstring) { this.idInQuery.push(idstring); if (insigh</text>
  <text x="420" y="330" fill="rgb(255 255 255)">tDataset.kind === InsightDatasetKi</text>
  <text x="454" y="330" fill="rgb(24 158 180)">nd.Courses) { this.mfields = this.coursemfields; this.sfields = t</text>
  <text x="519" y="330" fill="rgb(255 255 255)">his.coursesfi</text>
  <text x="532" y="330" fill="rgb(24 158 180)">elds; } else { this.mfields = th</text>
  <text x="564" y="330" fill="rgb(255 255 255)">is.roommfields; this.sfields = this.roomsfields; } return true; } } ret</text>
  <text x="635" y="330" fill="rgb(237 28 36)">urn false; } else { return this.idInQuery.includes(idstring</text>
  <text x="694" y="330" fill="rgb(255 255 255)">); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsi</text>
  <text x="0" y="331" fill="rgb(255 255 255)">ghtFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;au</text>
  <text x="120" y="331" fill="rgb(237 28 36)">dit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfi</text>
  <text x="249" y="331" fill="rgb(255 255 255)">elds: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; pr</text>
  <text x="293" y="331" fill="rgb(24 158 180)">ivate readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;s</text>
  <text x="347" y="331" fill="rgb(255 255 255)">hortname&amp;quot;, &amp;quot;number&amp;quot; ,</text>
  <text x="368" y="331" fill="rgb(24 158 180)"> &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; priva</text>
  <text x="423" y="331" fill="rgb(255 255 255)">te readonly mtoken: string[] = [&amp;quot;</text>
  <text x="456" y="331" fill="rgb(24 158 180)">MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: stri</text>
  <text x="514" y="331" fill="rgb(255 255 255)">ng[] = [&amp;quot;COUNT&amp;quot;]; priv</text>
  <text x="536" y="331" fill="rgb(24 158 180)">ate idInQuery: string[]; // </text>
  <text x="564" y="331" fill="rgb(255 255 255)">make sure the query only has one id private keysInQuery: string[]; // a</text>
  <text x="635" y="331" fill="rgb(237 28 36)">ll keys appeared in columns after being validated private t</text>
  <text x="694" y="331" fill="rgb(255 255 255)">ransformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; p</text>
  <text x="0" y="332" fill="rgb(255 255 255)">rivate mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = </text>
  <text x="119" y="332" fill="rgb(237 28 36)">[]; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void </text>
  <text x="249" y="332" fill="rgb(255 255 255)">{ if (!q || !q.WHERE || !q.OPTIONS) { throw </text>
  <text x="293" y="332" fill="rgb(24 158 180)">new InsightError(); } for (let key of Object.keys(q)) </text>
  <text x="347" y="332" fill="rgb(255 255 255)">{ if (key !== &amp;quot;OPTIONS</text>
  <text x="369" y="332" fill="rgb(24 158 180)">&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { thr</text>
  <text x="425" y="332" fill="rgb(255 255 255)">ow new InsightError(); } } this.</text>
  <text x="457" y="332" fill="rgb(24 158 180)">validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.</text>
  <text x="511" y="332" fill="rgb(255 255 255)">validateTransformations(q.TR</text>
  <text x="539" y="332" fill="rgb(24 158 180)">ANSFORMATIONS); } this.val</text>
  <text x="565" y="332" fill="rgb(255 255 255)">idateOptions(q.OPTIONS); } public validateTransformations(q: any): voi</text>
  <text x="635" y="332" fill="rgb(237 28 36)">d { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY ==</text>
  <text x="694" y="332" fill="rgb(255 255 255)">= &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } pri</text>
  <text x="0" y="333" fill="rgb(255 255 255)">vate validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an</text>
  <text x="119" y="333" fill="rgb(237 28 36)"> object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // i</text>
  <text x="248" y="333" fill="rgb(255 255 255)">f the key is valid, push it to transformatio</text>
  <text x="292" y="333" fill="rgb(24 158 180)">nKey } } private validateKey(key: string): void { let sp</text>
  <text x="348" y="333" fill="rgb(255 255 255)">littedKey: string[] =</text>
  <text x="369" y="333" fill="rgb(24 158 180)"> key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new </text>
  <text x="428" y="333" fill="rgb(255 255 255)">InsightError(); } if (!(this.va</text>
  <text x="459" y="333" fill="rgb(24 158 180)">lidateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.i</text>
  <text x="508" y="333" fill="rgb(255 255 255)">ncludes(splittedKey[1]) || this.sf</text>
  <text x="542" y="333" fill="rgb(24 158 180)">ields.includes(splitted</text>
  <text x="565" y="333" fill="rgb(255 255 255)">Key[1])))) { throw new InsightError(); } } private validateAPPLY(q: an</text>
  <text x="635" y="333" fill="rgb(237 28 36)">y): void { if (!Array.isArray(q)) { throw new InsightError(</text>
  <text x="694" y="333" fill="rgb(255 255 255)">); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(a</text>
  <text x="0" y="334" fill="rgb(255 255 255)">pplyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = ap</text>
  <text x="119" y="334" fill="rgb(237 28 36)">plyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new </text>
  <text x="248" y="334" fill="rgb(255 255 255)">InsightError(); } this.transformationKey.pus</text>
  <text x="292" y="334" fill="rgb(24 158 180)">h(applykey); if (Array.isArray(criteria) || Object.keys(c</text>
  <text x="349" y="334" fill="rgb(255 255 255)">riteria).length &amp;gt; 1) </text>
  <text x="370" y="334" fill="rgb(24 158 180)">{ throw new InsightError(); } let applytoken: string = Objec</text>
  <text x="430" y="334" fill="rgb(255 255 255)">t.keys(criteria)[0]; if (!this</text>
  <text x="460" y="334" fill="rgb(24 158 180)">.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.</text>
  <text x="506" y="334" fill="rgb(255 255 255)">includes(applytoken)) { throw new Insi</text>
  <text x="544" y="334" fill="rgb(24 158 180)">ghtError(); } let key</text>
  <text x="565" y="334" fill="rgb(255 255 255)">: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { t</text>
  <text x="636" y="334" fill="rgb(237 28 36)">hrow new InsightError(); } if (this.mtoken.includes(apply</text>
  <text x="693" y="334" fill="rgb(255 255 255)">token)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.inclu</text>
  <text x="0" y="335" fill="rgb(255 255 255)">des(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1</text>
  <text x="119" y="335" fill="rgb(237 28 36)">])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key o</text>
  <text x="248" y="335" fill="rgb(255 255 255)">f keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;</text>
  <text x="292" y="335" fill="rgb(24 158 180)">ORDER&amp;quot;) { throw new InsightError(); } } this.validateColu</text>
  <text x="349" y="335" fill="rgb(255 255 255)">mns(q.COLUMNS); if (q.</text>
  <text x="371" y="335" fill="rgb(24 158 180)">ORDER) { this.validateOrder(q.ORDER); } } private validateColu</text>
  <text x="433" y="335" fill="rgb(255 255 255)">mns(q: any): void { if (!q |</text>
  <text x="461" y="335" fill="rgb(24 158 180)">| q.length &amp;lt; 1) { throw new InsightError();</text>
  <text x="504" y="335" fill="rgb(255 255 255)"> } for (let mskey of q) { if (this.transfo</text>
  <text x="546" y="335" fill="rgb(24 158 180)">rmationKey.length &amp;gt; </text>
  <text x="566" y="335" fill="rgb(255 255 255)">0) { if (!this.transformationKey.includes(mskey)) { throw new InsightE</text>
  <text x="636" y="335" fill="rgb(237 28 36)">rror(); } } else { this.validateKey(mskey); } this.keysIn</text>
  <text x="693" y="335" fill="rgb(255 255 255)">Query.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;stri</text>
  <text x="0" y="336" fill="rgb(255 255 255)">ng&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q</text>
  <text x="119" y="336" fill="rgb(237 28 36)">).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any</text>
  <text x="248" y="336" fill="rgb(255 255 255)"> = q.keys; if (!Array.isArray(keys) || keys</text>
  <text x="291" y="336" fill="rgb(24 158 180)">.length &amp;lt; 1) { throw new InsightError(); } for (let anykey </text>
  <text x="350" y="336" fill="rgb(255 255 255)">of keys) { if (!this.k</text>
  <text x="372" y="336" fill="rgb(24 158 180)">eysInQuery.includes(anykey)) { throw new InsightError(); } } } </text>
  <text x="435" y="336" fill="rgb(255 255 255)">} public validateWhere(q: an</text>
  <text x="463" y="336" fill="rgb(24 158 180)">y): void { if (Array.isArray(q)) { thro</text>
  <text x="502" y="336" fill="rgb(255 255 255)">w new InsightError(); } else { if (Object.keys</text>
  <text x="548" y="336" fill="rgb(24 158 180)">(q).length !== 0) </text>
  <text x="566" y="336" fill="rgb(255 255 255)">{ this.validateFilter(q); } } } private validateFilter(q: any): void {</text>
  <text x="636" y="336" fill="rgb(237 28 36)"> if (Object.keys(q).length !== 1) { throw new InsightErro</text>
  <text x="693" y="336" fill="rgb(255 255 255)">r(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validate</text>
  <text x="0" y="337" fill="rgb(255 255 255)">ANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(v</text>
  <text x="119" y="337" fill="rgb(237 28 36)">alue); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any)</text>
  <text x="247" y="337" fill="rgb(255 255 255)">: void { if (typeof value !== &amp;quot;object&amp;quot;) { th</text>
  <text x="291" y="337" fill="rgb(24 158 180)">row new InsightError(); } this.validateFilter(value); } pri</text>
  <text x="350" y="337" fill="rgb(255 255 255)">vate validateIS(value:</text>
  <text x="372" y="337" fill="rgb(24 158 180)"> any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightE</text>
  <text x="437" y="337" fill="rgb(255 255 255)">rror(); } if (Object.keys(v</text>
  <text x="464" y="337" fill="rgb(24 158 180)">alue).length !== 1) { throw new Insi</text>
  <text x="500" y="337" fill="rgb(255 255 255)">ghtError(); } let skey: string[] = Object.keys(val</text>
  <text x="550" y="337" fill="rgb(24 158 180)">ue)[0].split(&amp;quot;_&amp;quot;</text>
  <text x="566" y="337" fill="rgb(255 255 255)">); if (skey.length !== 2) { throw new InsightError(); } else { let ids</text>
  <text x="636" y="337" fill="rgb(237 28 36)">tring: string = skey[0]; let sfield: string = skey[1]; le</text>
  <text x="693" y="337" fill="rgb(255 255 255)">t str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;))</text>
  <text x="0" y="338" fill="rgb(255 255 255)"> || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private val</text>
  <text x="119" y="338" fill="rgb(237 28 36)">idateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } </text>
  <text x="247" y="338" fill="rgb(255 255 255)">let mkey: string[] = Object.keys(value)[0].s</text>
  <text x="291" y="338" fill="rgb(24 158 180)">plit(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError()</text>
  <text x="351" y="338" fill="rgb(255 255 255)">; } else { let idstrin</text>
  <text x="373" y="338" fill="rgb(24 158 180)">g: string = mkey[0]; let mfield: string = mkey[1]; let num: any =</text>
  <text x="438" y="338" fill="rgb(255 255 255)"> Object.values(value)[0]; i</text>
  <text x="465" y="338" fill="rgb(24 158 180)">f ((typeof num !== &amp;quot;number&amp;quot;) || !</text>
  <text x="498" y="338" fill="rgb(255 255 255)">this.validateIdstring(idstring) || !this.mfields.incl</text>
  <text x="551" y="338" fill="rgb(24 158 180)">udes(mfield)) { </text>
  <text x="567" y="338" fill="rgb(255 255 255)">throw new InsightError(); } } } private validateANDOR(value: any): vo</text>
  <text x="636" y="338" fill="rgb(237 28 36)">id { if (!Array.isArray(value) || value.length &amp;lt; 1) { thr</text>
  <text x="693" y="338" fill="rgb(255 255 255)">ow new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): </text>
  <text x="0" y="339" fill="rgb(255 255 255)">boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id</text>
  <text x="119" y="339" fill="rgb(237 28 36)"> === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.co</text>
  <text x="247" y="339" fill="rgb(255 255 255)">ursemfields; this.sfields = this.coursesfie</text>
  <text x="290" y="339" fill="rgb(24 158 180)">lds; } else { this.mfields = this.roommfields; this.sfields = </text>
  <text x="352" y="339" fill="rgb(255 255 255)">this.roomsfields; } re</text>
  <text x="374" y="339" fill="rgb(24 158 180)">turn true; } } return false; } else { return this.idInQuery.includ</text>
  <text x="440" y="339" fill="rgb(255 255 255)">es(idstring); } } public g</text>
  <text x="466" y="339" fill="rgb(24 158 180)">etIdInQuery(): string[] { retur</text>
  <text x="497" y="339" fill="rgb(255 255 255)">n this.idInQuery; } } import {InsightDataset, InsightDat</text>
  <text x="553" y="339" fill="rgb(24 158 180)">asetKind, Insi</text>
  <text x="567" y="339" fill="rgb(255 255 255)">ghtError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator</text>
  <text x="637" y="339" fill="rgb(237 28 36)"> { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;p</text>
  <text x="693" y="339" fill="rgb(255 255 255)">ass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly r</text>
  <text x="0" y="340" fill="rgb(255 255 255)">oommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;num</text>
  <text x="119" y="340" fill="rgb(237 28 36)">ber&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; privat</text>
  <text x="247" y="340" fill="rgb(255 255 255)">e readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; p</text>
  <text x="290" y="340" fill="rgb(24 158 180)">rivate idInQuery: string[]; // make sure the query only has on</text>
  <text x="352" y="340" fill="rgb(255 255 255)">e id private keysInQuer</text>
  <text x="375" y="340" fill="rgb(24 158 180)">y: string[]; // all keys appeared in columns after being validated</text>
  <text x="441" y="340" fill="rgb(255 255 255)"> private transformationKey</text>
  <text x="467" y="340" fill="rgb(24 158 180)">: string[]; // keys appeared</text>
  <text x="495" y="340" fill="rgb(255 255 255)"> in transformation, if there is a transformation private al</text>
  <text x="554" y="340" fill="rgb(24 158 180)">lInsightDatas</text>
  <text x="567" y="340" fill="rgb(255 255 255)">et: InsightDataset[]; private mfields: string[]; private sfields: stri</text>
  <text x="637" y="340" fill="rgb(237 28 36)">ng[]; constructor(insightDatasets: InsightDataset[]) { t</text>
  <text x="693" y="340" fill="rgb(255 255 255)">his.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any):</text>
  <text x="0" y="341" fill="rgb(255 255 255)"> void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;</text>
  <text x="119" y="341" fill="rgb(237 28 36)">OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRA</text>
  <text x="247" y="341" fill="rgb(255 255 255)">NSFORMATIONS) { this.validateTransformatio</text>
  <text x="289" y="341" fill="rgb(24 158 180)">ns(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } publ</text>
  <text x="353" y="341" fill="rgb(255 255 255)">ic validateTransformat</text>
  <text x="375" y="341" fill="rgb(24 158 180)">ions(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.</text>
  <text x="443" y="341" fill="rgb(255 255 255)">APPLY === &amp;quot;undefined&amp;quot; || </text>
  <text x="468" y="341" fill="rgb(24 158 180)">Object.keys(q).length !== </text>
  <text x="494" y="341" fill="rgb(255 255 255)">2) { throw new InsightError(); } this.validateGROUP(q.GROUP); </text>
  <text x="556" y="341" fill="rgb(24 158 180)">this.validat</text>
  <text x="568" y="341" fill="rgb(255 255 255)">eAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.i</text>
  <text x="637" y="341" fill="rgb(237 28 36)">sArray(q) || q.length &amp;lt; 1) { throw new InsightError(); </text>
  <text x="692" y="341" fill="rgb(255 255 255)">// q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key);</text>
  <text x="0" y="342" fill="rgb(255 255 255)"> // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: str</text>
  <text x="119" y="342" fill="rgb(237 28 36)">ing[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) </text>
  <text x="247" y="342" fill="rgb(255 255 255)">&amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) </text>
  <text x="289" y="342" fill="rgb(24 158 180)">|| this.sfields.includes(splittedKey[1])))) { throw new InsightEr</text>
  <text x="354" y="342" fill="rgb(255 255 255)">ror(); } } private val</text>
  <text x="376" y="342" fill="rgb(24 158 180)">idateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new Insigh</text>
  <text x="444" y="342" fill="rgb(255 255 255)">tError(); // q should be </text>
  <text x="469" y="342" fill="rgb(24 158 180)">an array, and should ha</text>
  <text x="492" y="342" fill="rgb(255 255 255)">ve at least one element } for (let applyrule of q) { if (Array.is</text>
  <text x="557" y="342" fill="rgb(24 158 180)">Array(apply</text>
  <text x="568" y="342" fill="rgb(255 255 255)">rule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(</text>
  <text x="637" y="342" fill="rgb(237 28 36)">); } let applykey: string = Object.keys(applyrule)[0]; </text>
  <text x="692" y="342" fill="rgb(255 255 255)">let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw</text>
  <text x="0" y="343" fill="rgb(255 255 255)"> new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).leng</text>
  <text x="119" y="343" fill="rgb(237 28 36)">th &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) </text>
  <text x="246" y="343" fill="rgb(255 255 255)">&amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { th</text>
  <text x="289" y="343" fill="rgb(24 158 180)">row new InsightError(); } let key: string[] = criteria[applytoken]</text>
  <text x="355" y="343" fill="rgb(255 255 255)">.split(&amp;quot;_&amp;quot;); if (key.l</text>
  <text x="377" y="343" fill="rgb(24 158 180)">ength !== 2) { throw new InsightError(); } if (this.mtoken.includes(</text>
  <text x="445" y="343" fill="rgb(255 255 255)">applytoken)) { if (!(this</text>
  <text x="470" y="343" fill="rgb(24 158 180)">.validateIdstring(key</text>
  <text x="491" y="343" fill="rgb(255 255 255)">[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError();</text>
  <text x="558" y="343" fill="rgb(24 158 180)"> } } else </text>
  <text x="568" y="343" fill="rgb(255 255 255)">if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(</text>
  <text x="637" y="343" fill="rgb(237 28 36)">key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfiel</text>
  <text x="692" y="343" fill="rgb(255 255 255)">ds.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let </text>
  <text x="0" y="344" fill="rgb(255 255 255)">key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS</text>
  <text x="119" y="344" fill="rgb(237 28 36)">); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new </text>
  <text x="246" y="344" fill="rgb(255 255 255)">InsightError(); } for (let mskey of q) { i</text>
  <text x="288" y="344" fill="rgb(24 158 180)">f (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey</text>
  <text x="355" y="344" fill="rgb(255 255 255)">.includes(mskey)) { thr</text>
  <text x="378" y="344" fill="rgb(24 158 180)">ow new InsightError(); } } else { this.validateKey(mskey); } this.ke</text>
  <text x="446" y="344" fill="rgb(255 255 255)">ysInQuery.push(mskey); } </text>
  <text x="471" y="344" fill="rgb(24 158 180)">} private validateO</text>
  <text x="490" y="344" fill="rgb(255 255 255)">rder(q: any): void { if (Array.isArray(q)) { throw new InsightError();</text>
  <text x="560" y="344" fill="rgb(24 158 180)"> } else i</text>
  <text x="569" y="344" fill="rgb(255 255 255)">f (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { thro</text>
  <text x="638" y="344" fill="rgb(237 28 36)">w new InsightError(); } } else { if (!q.dir || !q.keys</text>
  <text x="692" y="344" fill="rgb(255 255 255)"> || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys</text>
  <text x="0" y="345" fill="rgb(255 255 255)">: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { i</text>
  <text x="119" y="345" fill="rgb(237 28 36)">f (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArr</text>
  <text x="246" y="345" fill="rgb(255 255 255)">ay(q)) { throw new InsightError(); } else </text>
  <text x="288" y="345" fill="rgb(24 158 180)">{ if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } p</text>
  <text x="356" y="345" fill="rgb(255 255 255)">rivate validateFilter(q</text>
  <text x="379" y="345" fill="rgb(24 158 180)">: any): void { if (Object.keys(q).length !== 1) { throw new InsightE</text>
  <text x="447" y="345" fill="rgb(255 255 255)">rror(); } else { let key:</text>
  <text x="472" y="345" fill="rgb(24 158 180)"> string = Object</text>
  <text x="488" y="345" fill="rgb(255 255 255)">.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;A</text>
  <text x="561" y="345" fill="rgb(24 158 180)">ND&amp;quot;: cas</text>
  <text x="569" y="345" fill="rgb(255 255 255)">e &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNO</text>
  <text x="638" y="345" fill="rgb(237 28 36)">T(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this</text>
  <text x="692" y="345" fill="rgb(255 255 255)">.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: </text>
  <text x="0" y="346" fill="rgb(255 255 255)">any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validat</text>
  <text x="119" y="346" fill="rgb(237 28 36)">eIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { thr</text>
  <text x="246" y="346" fill="rgb(255 255 255)">ow new InsightError(); } let skey: string[</text>
  <text x="288" y="346" fill="rgb(24 158 180)">] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw </text>
  <text x="357" y="346" fill="rgb(255 255 255)">new InsightError(); } e</text>
  <text x="380" y="346" fill="rgb(24 158 180)">lse { let idstring: string = skey[0]; let sfield: string = skey[1]; </text>
  <text x="448" y="346" fill="rgb(255 255 255)">let str: any = Object.val</text>
  <text x="473" y="346" fill="rgb(24 158 180)">ues(value)[0];</text>
  <text x="487" y="346" fill="rgb(255 255 255)"> if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str</text>
  <text x="562" y="346" fill="rgb(24 158 180)">.slice(</text>
  <text x="569" y="346" fill="rgb(255 255 255)">1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sf</text>
  <text x="638" y="346" fill="rgb(237 28 36)">ields.includes(sfield)) { throw new InsightError(); } </text>
  <text x="692" y="346" fill="rgb(255 255 255)">} } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError()</text>
  <text x="0" y="347" fill="rgb(255 255 255)">; } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { </text>
  <text x="119" y="347" fill="rgb(237 28 36)">let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;numb</text>
  <text x="246" y="347" fill="rgb(255 255 255)">er&amp;quot;) || !this.validateIdstring(idstring) </text>
  <text x="287" y="347" fill="rgb(24 158 180)">|| !this.mfields.includes(mfield)) { throw new InsightError(); } } } pr</text>
  <text x="358" y="347" fill="rgb(255 255 255)">ivate validateANDOR(val</text>
  <text x="381" y="347" fill="rgb(24 158 180)">ue: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { th</text>
  <text x="449" y="347" fill="rgb(255 255 255)">row new InsightError(); }</text>
  <text x="474" y="347" fill="rgb(24 158 180)"> for (let i</text>
  <text x="485" y="347" fill="rgb(255 255 255)">nnerObject of value) { this.validateF</text>
  <text x="522" y="347" fill="rgb(24 158 180)">ilter(in</text>
  <text x="530" y="347" fill="rgb(255 255 255)">nerObject); } } private validateI</text>
  <text x="563" y="347" fill="rgb(24 158 180)">dstring</text>
  <text x="570" y="347" fill="rgb(255 255 255)">(idstring: string): boolean { if (this.idInQuery.length === 0) { for</text>
  <text x="638" y="347" fill="rgb(237 28 36)"> (let insightDataset of this.allInsightDataset) { if (</text>
  <text x="692" y="347" fill="rgb(255 255 255)">insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = thi</text>
  <text x="0" y="348" fill="rgb(255 255 255)">s.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.rooms</text>
  <text x="119" y="348" fill="rgb(237 28 36)">fields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[]</text>
  <text x="246" y="348" fill="rgb(255 255 255)"> { return this.idInQuery; } } import {Ins</text>
  <text x="287" y="348" fill="rgb(24 158 180)">ightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;;</text>
  <text x="358" y="348" fill="rgb(255 255 255)"> export default class Qu</text>
  <text x="382" y="348" fill="rgb(24 158 180)">eryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;p</text>
  <text x="450" y="348" fill="rgb(255 255 255)">ass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;y</text>
  <text x="475" y="348" fill="rgb(24 158 180)">ear&amp;quot;]; pr</text>
  <text x="484" y="348" fill="rgb(255 255 255)">ivate readonly coursesfields: s</text>
  <text x="515" y="348" fill="rgb(24 158 180)">tring[] = [&amp;quot;dept&amp;quot;, &amp;quot;id</text>
  <text x="537" y="348" fill="rgb(255 255 255)">&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;</text>
  <text x="564" y="348" fill="rgb(24 158 180)">uuid&amp;quot;]</text>
  <text x="570" y="348" fill="rgb(255 255 255)">; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; </text>
  <text x="638" y="348" fill="rgb(237 28 36)">private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;,</text>
  <text x="691" y="348" fill="rgb(255 255 255)"> &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; pr</text>
  <text x="0" y="349" fill="rgb(255 255 255)">ivate readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id priv</text>
  <text x="118" y="349" fill="rgb(237 28 36)">ate keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys ap</text>
  <text x="246" y="349" fill="rgb(255 255 255)">peared in transformation, if there is a t</text>
  <text x="287" y="349" fill="rgb(24 158 180)">ransformation private allInsightDataset: InsightDataset[]; private mfiel</text>
  <text x="359" y="349" fill="rgb(255 255 255)">ds: string[]; private sf</text>
  <text x="383" y="349" fill="rgb(24 158 180)">ields: string[]; constructor(insightDatasets: InsightDataset[]) { th</text>
  <text x="451" y="349" fill="rgb(255 255 255)">is.idInQuery = []; this.ke</text>
  <text x="477" y="349" fill="rgb(24 158 180)">ysInQ</text>
  <text x="482" y="349" fill="rgb(255 255 255)">uery = []; this.transformatio</text>
  <text x="511" y="349" fill="rgb(24 158 180)">nKey = []; this.allInsightDa</text>
  <text x="539" y="349" fill="rgb(255 255 255)">taset = insightDatasets; }</text>
  <text x="565" y="349" fill="rgb(24 158 180)"> publ</text>
  <text x="570" y="349" fill="rgb(255 255 255)">ic validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { thro</text>
  <text x="638" y="349" fill="rgb(237 28 36)">w new InsightError(); } for (let key of Object.keys(q</text>
  <text x="691" y="349" fill="rgb(255 255 255)">)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q</text>
  <text x="0" y="350" fill="rgb(255 255 255)">.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public valid</text>
  <text x="118" y="350" fill="rgb(237 28 36)">ateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length</text>
  <text x="246" y="350" fill="rgb(255 255 255)"> !== 2) { throw new InsightError(); } thi</text>
  <text x="287" y="350" fill="rgb(24 158 180)">s.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validate</text>
  <text x="360" y="350" fill="rgb(255 255 255)">GROUP(q: any): void { if</text>
  <text x="384" y="350" fill="rgb(24 158 180)"> (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // </text>
  <text x="452" y="350" fill="rgb(255 255 255)">q should be an object, and should has at least one elemen</text>
  <text x="509" y="350" fill="rgb(24 158 180)">t } for (let key of q) { this.va</text>
  <text x="541" y="350" fill="rgb(255 255 255)">lidateKey(key); this.tran</text>
  <text x="566" y="350" fill="rgb(24 158 180)">sform</text>
  <text x="571" y="350" fill="rgb(255 255 255)">ationKey.push(key); // if the key is valid, push it to transformati</text>
  <text x="638" y="350" fill="rgb(237 28 36)">onKey } } private validateKey(key: string): void { le</text>
  <text x="691" y="350" fill="rgb(255 255 255)">t splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[</text>
  <text x="0" y="351" fill="rgb(255 255 255)">0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); </text>
  <text x="118" y="351" fill="rgb(237 28 36)">} } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and shoul</text>
  <text x="245" y="351" fill="rgb(255 255 255)">d have at least one element } for (let ap</text>
  <text x="286" y="351" fill="rgb(24 158 180)">plyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).leng</text>
  <text x="361" y="351" fill="rgb(255 255 255)">th &amp;gt; 1) { throw new Insi</text>
  <text x="385" y="351" fill="rgb(24 158 180)">ghtError(); } let applykey: string = Object.keys(applyrule)[0]; let</text>
  <text x="452" y="351" fill="rgb(255 255 255)"> criteria = applyrule[applykey]; if (applykey.length =</text>
  <text x="506" y="351" fill="rgb(24 158 180)">== 0 || applykey.includes(&amp;quot;_&amp;quot;) || th</text>
  <text x="542" y="351" fill="rgb(255 255 255)">is.transformationKey.inclu</text>
  <text x="568" y="351" fill="rgb(24 158 180)">des</text>
  <text x="571" y="351" fill="rgb(255 255 255)">(applykey)) { throw new InsightError(); } this.transformationKey.pus</text>
  <text x="639" y="351" fill="rgb(237 28 36)">h(applykey); if (Array.isArray(criteria) || Object.k</text>
  <text x="691" y="351" fill="rgb(255 255 255)">eys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoke</text>
  <text x="0" y="352" fill="rgb(255 255 255)">n) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split</text>
  <text x="118" y="352" fill="rgb(237 28 36)">(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(</text>
  <text x="245" y="352" fill="rgb(255 255 255)">key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))</text>
  <text x="286" y="352" fill="rgb(24 158 180)">) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)</text>
  <text x="362" y="352" fill="rgb(255 255 255)">) { if (!(this.validateI</text>
  <text x="386" y="352" fill="rgb(24 158 180)">dstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.i</text>
  <text x="453" y="352" fill="rgb(255 255 255)">ncludes(key[1])))) { throw new InsightError(); } } </text>
  <text x="504" y="352" fill="rgb(24 158 180)">} } public validateOptions(q: any): vo</text>
  <text x="542" y="352" fill="rgb(255 255 255)">id { let keys: any[] = Obje</text>
  <text x="569" y="352" fill="rgb(24 158 180)">ct</text>
  <text x="571" y="352" fill="rgb(255 255 255)">.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;</text>
  <text x="639" y="352" fill="rgb(237 28 36)">ORDER&amp;quot;) { throw new InsightError(); } } this.validat</text>
  <text x="691" y="352" fill="rgb(255 255 255)">eColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw n</text>
  <text x="0" y="353" fill="rgb(255 255 255)">ew InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.inclu</text>
  <text x="118" y="353" fill="rgb(237 28 36)">des(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validat</text>
  <text x="245" y="353" fill="rgb(255 255 255)">eOrder(q: any): void { if (Array.isArray(</text>
  <text x="286" y="353" fill="rgb(24 158 180)">q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this</text>
  <text x="363" y="353" fill="rgb(255 255 255)">.keysInQuery.includes(q)</text>
  <text x="387" y="353" fill="rgb(24 158 180)">) { throw new InsightError(); } } else { if (!q.dir || !q.keys || O</text>
  <text x="454" y="353" fill="rgb(255 255 255)">bject.keys(q).length !== 2) { throw new InsightE</text>
  <text x="502" y="353" fill="rgb(24 158 180)">rror(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !=</text>
  <text x="542" y="353" fill="rgb(255 255 255)">= &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.</text>
  <text x="639" y="353" fill="rgb(237 28 36)">length &amp;lt; 1) { throw new InsightError(); } for (let a</text>
  <text x="691" y="353" fill="rgb(255 255 255)">nykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.is</text>
  <text x="0" y="354" fill="rgb(255 255 255)">Array(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } privat</text>
  <text x="118" y="354" fill="rgb(237 28 36)">e validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object</text>
  <text x="245" y="354" fill="rgb(255 255 255)">.keys(q)[0]; let value: any = Object.val</text>
  <text x="285" y="354" fill="rgb(24 158 180)">ues(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); bre</text>
  <text x="364" y="354" fill="rgb(255 255 255)">ak; case &amp;quot;NOT&amp;quot;: this.val</text>
  <text x="388" y="354" fill="rgb(24 158 180)">idateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.vali</text>
  <text x="454" y="354" fill="rgb(255 255 255)">dateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.vali</text>
  <text x="500" y="354" fill="rgb(24 158 180)">dateIS(value); break; default: throw new I</text>
  <text x="542" y="354" fill="rgb(255 255 255)">nsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { thr</text>
  <text x="639" y="354" fill="rgb(237 28 36)">ow new InsightError(); } this.validateFilter(value)</text>
  <text x="690" y="354" fill="rgb(255 255 255)">; } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { </text>
  <text x="0" y="355" fill="rgb(255 255 255)">throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new </text>
  <text x="118" y="355" fill="rgb(237 28 36)">InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; </text>
  <text x="245" y="355" fill="rgb(255 255 255)">if (typeof str !== &amp;quot;string&amp;quot;) { throw new</text>
  <text x="285" y="355" fill="rgb(24 158 180)"> InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validate</text>
  <text x="365" y="355" fill="rgb(255 255 255)">Idstring(idstring) || !t</text>
  <text x="389" y="355" fill="rgb(24 158 180)">his.sfields.includes(sfield)) { throw new InsightError(); } } } } </text>
  <text x="455" y="355" fill="rgb(255 255 255)">private validateGTLTEQ(value: any): void { </text>
  <text x="498" y="355" fill="rgb(24 158 180)">if (typeof value !== &amp;quot;object&amp;quot; || Object.keys</text>
  <text x="542" y="355" fill="rgb(255 255 255)">(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].sp</text>
  <text x="639" y="355" fill="rgb(237 28 36)">lit(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new Insigh</text>
  <text x="690" y="355" fill="rgb(255 255 255)">tError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;n</text>
  <text x="0" y="356" fill="rgb(255 255 255)">umber&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } priva</text>
  <text x="118" y="356" fill="rgb(237 28 36)">te validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let inne</text>
  <text x="245" y="356" fill="rgb(255 255 255)">rObject of value) { this.validateFilter(</text>
  <text x="285" y="356" fill="rgb(24 158 180)">innerObject); } } private validateIdstring(idstring: string): boolean { if (this.</text>
  <text x="366" y="356" fill="rgb(255 255 255)">idInQuery.length === 0) </text>
  <text x="390" y="356" fill="rgb(24 158 180)">{ for (let insightDataset of this.allInsightDataset) { if (insigh</text>
  <text x="455" y="356" fill="rgb(255 255 255)">tDataset.id === idstring) { this.idInQuery</text>
  <text x="497" y="356" fill="rgb(24 158 180)">.push(idstring); if (insightDataset.kind === </text>
  <text x="542" y="356" fill="rgb(255 255 255)">InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfield</text>
  <text x="639" y="356" fill="rgb(237 28 36)">s; } else { this.mfields = this.roommfields; this.s</text>
  <text x="690" y="356" fill="rgb(255 255 255)">fields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): strin</text>
  <text x="0" y="357" fill="rgb(255 255 255)">g[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; ex</text>
  <text x="118" y="357" fill="rgb(237 28 36)">port default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; privat</text>
  <text x="245" y="357" fill="rgb(255 255 255)">e readonly coursesfields: string[] = [&amp;quot;d</text>
  <text x="285" y="357" fill="rgb(24 158 180)">ept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[]</text>
  <text x="367" y="357" fill="rgb(255 255 255)"> = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats</text>
  <text x="391" y="357" fill="rgb(24 158 180)">&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortn</text>
  <text x="456" y="357" fill="rgb(255 255 255)">ame&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;ty</text>
  <text x="495" y="357" fill="rgb(24 158 180)">pe&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mt</text>
  <text x="541" y="357" fill="rgb(255 255 255)">oken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; pri</text>
  <text x="639" y="357" fill="rgb(237 28 36)">vate idInQuery: string[]; // make sure the query on</text>
  <text x="690" y="357" fill="rgb(255 255 255)">ly has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys</text>
  <text x="0" y="358" fill="rgb(255 255 255)"> appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields</text>
  <text x="118" y="358" fill="rgb(237 28 36)">: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery =</text>
  <text x="245" y="358" fill="rgb(255 255 255)"> []; this.transformationKey = []; this.a</text>
  <text x="285" y="358" fill="rgb(24 158 180)">llInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.</text>
  <text x="368" y="358" fill="rgb(255 255 255)">WHERE || !q.OPTIONS) { t</text>
  <text x="392" y="358" fill="rgb(24 158 180)">hrow new InsightError(); } for (let key of Object.keys(q)) { if (</text>
  <text x="457" y="358" fill="rgb(255 255 255)">key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; </text>
  <text x="494" y="358" fill="rgb(24 158 180)">&amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new Insi</text>
  <text x="540" y="358" fill="rgb(255 255 255)">ghtError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(</text>
  <text x="639" y="358" fill="rgb(237 28 36)">q.TRANSFORMATIONS); } this.validateOptions(q.OPTION</text>
  <text x="690" y="358" fill="rgb(255 255 255)">S); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).len</text>
  <text x="0" y="359" fill="rgb(255 255 255)">gth !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGR</text>
  <text x="119" y="359" fill="rgb(237 28 36)">OUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should ha</text>
  <text x="245" y="359" fill="rgb(255 255 255)">s at least one element } for (let key o</text>
  <text x="284" y="359" fill="rgb(24 158 180)">f q) { this.validateKey(key); this.transformationKey.push(key); // if the key is vali</text>
  <text x="369" y="359" fill="rgb(255 255 255)">d, push it to transforma</text>
  <text x="393" y="359" fill="rgb(24 158 180)">tionKey } } private validateKey(key: string): void { let splitte</text>
  <text x="457" y="359" fill="rgb(255 255 255)">dKey: string[] = key.split(&amp;quot;_&amp;quot;); if</text>
  <text x="492" y="359" fill="rgb(24 158 180)"> (splittedKey.length !== 2) { throw new InsightE</text>
  <text x="540" y="359" fill="rgb(255 255 255)">rror(); } if (!(this.val</text>
  <text x="564" y="359" fill="rgb(24 158 180)">idateId</text>
  <text x="571" y="359" fill="rgb(255 255 255)">string(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || t</text>
  <text x="640" y="359" fill="rgb(237 28 36)">his.sfields.includes(splittedKey[1])))) { throw n</text>
  <text x="689" y="359" fill="rgb(255 255 255)">ew InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and sho</text>
  <text x="0" y="360" fill="rgb(255 255 255)">uld have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).lengt</text>
  <text x="119" y="360" fill="rgb(237 28 36)">h &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if </text>
  <text x="245" y="360" fill="rgb(255 255 255)">(applykey.length === 0 || applykey.incl</text>
  <text x="284" y="360" fill="rgb(24 158 180)">udes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } </text>
  <text x="370" y="360" fill="rgb(255 255 255)">this.transformationKey.p</text>
  <text x="394" y="360" fill="rgb(24 158 180)">ush(applykey); if (Array.isArray(criteria) || Object.keys(crite</text>
  <text x="457" y="360" fill="rgb(255 255 255)">ria).length &amp;gt; 1) { throw new Insig</text>
  <text x="491" y="360" fill="rgb(24 158 180)">htError(); } let applytoken: string = Object.key</text>
  <text x="539" y="360" fill="rgb(255 255 255)">s(criteria)[0]; if (!th</text>
  <text x="562" y="360" fill="rgb(24 158 180)">is.mtoken.</text>
  <text x="572" y="360" fill="rgb(255 255 255)">includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw </text>
  <text x="640" y="360" fill="rgb(237 28 36)">new InsightError(); } let key: string[] = criteri</text>
  <text x="689" y="360" fill="rgb(255 255 255)">a[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstrin</text>
  <text x="0" y="361" fill="rgb(255 255 255)">g(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)</text>
  <text x="119" y="361" fill="rgb(237 28 36)">) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new Insi</text>
  <text x="245" y="361" fill="rgb(255 255 255)">ghtError(); } } } } public validateOpti</text>
  <text x="284" y="361" fill="rgb(24 158 180)">ons(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !</text>
  <text x="371" y="361" fill="rgb(255 255 255)">== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== </text>
  <text x="395" y="361" fill="rgb(24 158 180)">&amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q</text>
  <text x="458" y="361" fill="rgb(255 255 255)">.COLUMNS); if (q.ORDER) { this.</text>
  <text x="489" y="361" fill="rgb(24 158 180)">validateOrder(q.ORDER); } } private validateColum</text>
  <text x="538" y="361" fill="rgb(255 255 255)">ns(q: any): void { if </text>
  <text x="560" y="361" fill="rgb(24 158 180)">(!q || q.leng</text>
  <text x="573" y="361" fill="rgb(255 255 255)">th &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (th</text>
  <text x="640" y="361" fill="rgb(237 28 36)">is.transformationKey.length &amp;gt; 0) { if (!this.tran</text>
  <text x="689" y="361" fill="rgb(255 255 255)">sformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private valid</text>
  <text x="0" y="362" fill="rgb(255 255 255)">ateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!thi</text>
  <text x="119" y="362" fill="rgb(237 28 36)">s.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { thro</text>
  <text x="245" y="362" fill="rgb(255 255 255)">w new InsightError(); } if (q.dir !== &amp;quot;</text>
  <text x="284" y="362" fill="rgb(24 158 180)">UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Arra</text>
  <text x="372" y="362" fill="rgb(255 255 255)">y.isArray(keys) || keys.l</text>
  <text x="397" y="362" fill="rgb(24 158 180)">ength &amp;lt; 1) { throw new InsightError(); } for (let anykey of k</text>
  <text x="458" y="362" fill="rgb(255 255 255)">eys) { if (!this.keysInQuery.i</text>
  <text x="488" y="362" fill="rgb(24 158 180)">ncludes(anykey)) { throw new InsightError(); } } </text>
  <text x="537" y="362" fill="rgb(255 255 255)">} } public validateWhe</text>
  <text x="559" y="362" fill="rgb(24 158 180)">re(q: any): vo</text>
  <text x="573" y="362" fill="rgb(255 255 255)">id { if (Array.isArray(q)) { throw new InsightError(); } else { if </text>
  <text x="640" y="362" fill="rgb(237 28 36)">(Object.keys(q).length !== 0) { this.validateFilt</text>
  <text x="689" y="362" fill="rgb(255 255 255)">er(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Obje</text>
  <text x="0" y="363" fill="rgb(255 255 255)">ct.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); b</text>
  <text x="119" y="363" fill="rgb(237 28 36)">reak; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;I</text>
  <text x="244" y="363" fill="rgb(255 255 255)">S&amp;quot;: this.validateIS(value); break; defau</text>
  <text x="284" y="363" fill="rgb(24 158 180)">lt: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof va</text>
  <text x="373" y="363" fill="rgb(255 255 255)">lue !== &amp;quot;object&amp;quot;) { throw</text>
  <text x="398" y="363" fill="rgb(24 158 180)"> new InsightError(); } this.validateFilter(value); } private </text>
  <text x="459" y="363" fill="rgb(255 255 255)">validateIS(value: any): voi</text>
  <text x="486" y="363" fill="rgb(24 158 180)">d { if (typeof value !== &amp;quot;object&amp;quot;) { throw new Ins</text>
  <text x="536" y="363" fill="rgb(255 255 255)">ightError(); } if (Ob</text>
  <text x="557" y="363" fill="rgb(24 158 180)">ject.keys(value).</text>
  <text x="574" y="363" fill="rgb(255 255 255)">length !== 1) { throw new InsightError(); } let skey: string[] = O</text>
  <text x="640" y="363" fill="rgb(237 28 36)">bject.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length </text>
  <text x="689" y="363" fill="rgb(255 255 255)">!== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]</text>
  <text x="0" y="364" fill="rgb(255 255 255)">; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.valid</text>
  <text x="119" y="364" fill="rgb(237 28 36)">ateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: an</text>
  <text x="244" y="364" fill="rgb(255 255 255)">y): void { if (typeof value !== &amp;quot;object</text>
  <text x="283" y="364" fill="rgb(24 158 180)">&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Ob</text>
  <text x="374" y="364" fill="rgb(255 255 255)">ject.keys(value)[0].split</text>
  <text x="399" y="364" fill="rgb(24 158 180)">(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } </text>
  <text x="459" y="364" fill="rgb(255 255 255)">else { let idstring: strin</text>
  <text x="485" y="364" fill="rgb(24 158 180)">g = mkey[0]; let mfield: string = mkey[1]; let num</text>
  <text x="535" y="364" fill="rgb(255 255 255)">: any = Object.values</text>
  <text x="556" y="364" fill="rgb(24 158 180)">(value)[0]; if ((t</text>
  <text x="574" y="364" fill="rgb(255 255 255)">ypeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !th</text>
  <text x="640" y="364" fill="rgb(237 28 36)">is.mfields.includes(mfield)) { throw new Insight</text>
  <text x="688" y="364" fill="rgb(255 255 255)">Error(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let in</text>
  <text x="0" y="365" fill="rgb(255 255 255)">nerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (t</text>
  <text x="119" y="365" fill="rgb(237 28 36)">his.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this</text>
  <text x="244" y="365" fill="rgb(255 255 255)">.idInQuery.push(idstring); if (insightD</text>
  <text x="283" y="365" fill="rgb(24 158 180)">ataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfield</text>
  <text x="375" y="365" fill="rgb(255 255 255)">s = this.coursesfields; }</text>
  <text x="400" y="365" fill="rgb(24 158 180)"> else { this.mfields = this.roommfields; this.sfields = thi</text>
  <text x="459" y="365" fill="rgb(255 255 255)">s.roomsfields; } return t</text>
  <text x="484" y="365" fill="rgb(24 158 180)">rue; } } return false; } else { return this.idInQue</text>
  <text x="535" y="365" fill="rgb(255 255 255)">ry.includes(idstring</text>
  <text x="555" y="365" fill="rgb(24 158 180)">); } } public getId</text>
  <text x="574" y="365" fill="rgb(255 255 255)">InQuery(): string[] { return this.idInQuery; } } import {InsightDa</text>
  <text x="640" y="365" fill="rgb(237 28 36)">taset, InsightDatasetKind, InsightError} from &amp;quot;.</text>
  <text x="688" y="365" fill="rgb(255 255 255)">/IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; priv</text>
  <text x="0" y="366" fill="rgb(255 255 255)">ate readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: str</text>
  <text x="119" y="366" fill="rgb(237 28 36)">ing[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;addre</text>
  <text x="244" y="366" fill="rgb(255 255 255)">ss&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; priv</text>
  <text x="283" y="366" fill="rgb(24 158 180)">ate readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: strin</text>
  <text x="376" y="366" fill="rgb(255 255 255)">g[] = [&amp;quot;COUNT&amp;quot;]; private </text>
  <text x="401" y="366" fill="rgb(24 158 180)">idInQuery: string[]; // make sure the query only has one id</text>
  <text x="460" y="366" fill="rgb(255 255 255)"> private keysInQuery: </text>
  <text x="482" y="366" fill="rgb(24 158 180)">string[]; // all keys appeared in columns after bein</text>
  <text x="534" y="366" fill="rgb(255 255 255)">g validated private </text>
  <text x="554" y="366" fill="rgb(24 158 180)">transformationKey: st</text>
  <text x="575" y="366" fill="rgb(255 255 255)">ring[]; // keys appeared in transformation, if there is a transfo</text>
  <text x="640" y="366" fill="rgb(237 28 36)">rmation private allInsightDataset: InsightDatase</text>
  <text x="688" y="366" fill="rgb(255 255 255)">t[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery</text>
  <text x="0" y="367" fill="rgb(255 255 255)"> = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q </text>
  <text x="119" y="367" fill="rgb(237 28 36)">|| !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;</text>
  <text x="244" y="367" fill="rgb(255 255 255)">WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { </text>
  <text x="283" y="367" fill="rgb(24 158 180)">throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.valida</text>
  <text x="378" y="367" fill="rgb(255 255 255)">teTransformations(q.TRAN</text>
  <text x="402" y="367" fill="rgb(24 158 180)">SFORMATIONS); } this.validateOptions(q.OPTIONS); } public </text>
  <text x="460" y="367" fill="rgb(255 255 255)">validateTransformatio</text>
  <text x="481" y="367" fill="rgb(24 158 180)">ns(q: any): void { if (typeof q.GROUP === &amp;quot;undefined</text>
  <text x="533" y="367" fill="rgb(255 255 255)">&amp;quot; || typeof q.APPLY </text>
  <text x="553" y="367" fill="rgb(24 158 180)">=== &amp;quot;undefined&amp;quot; || Obj</text>
  <text x="575" y="367" fill="rgb(255 255 255)">ect.keys(q).length !== 2) { throw new InsightError(); } this.vali</text>
  <text x="640" y="367" fill="rgb(237 28 36)">dateGROUP(q.GROUP); this.validateAPPLY(q.APPLY);</text>
  <text x="688" y="367" fill="rgb(255 255 255)"> } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should </text>
  <text x="0" y="368" fill="rgb(255 255 255)">has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key </text>
  <text x="119" y="368" fill="rgb(237 28 36)">is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;</text>
  <text x="244" y="368" fill="rgb(255 255 255)">); if (splittedKey.length !== 2) { thro</text>
  <text x="283" y="368" fill="rgb(24 158 180)">w new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(sp</text>
  <text x="379" y="368" fill="rgb(255 255 255)">littedKey[1]) || this.sfi</text>
  <text x="404" y="368" fill="rgb(24 158 180)">elds.includes(splittedKey[1])))) { throw new InsightErro</text>
  <text x="460" y="368" fill="rgb(255 255 255)">r(); } } private val</text>
  <text x="480" y="368" fill="rgb(24 158 180)">idateAPPLY(q: any): void { if (!Array.isArray(q)) { </text>
  <text x="532" y="368" fill="rgb(255 255 255)">throw new InsightErr</text>
  <text x="552" y="368" fill="rgb(24 158 180)">or(); // q should be an</text>
  <text x="575" y="368" fill="rgb(255 255 255)"> array, and should have at least one element } for (let applyrule</text>
  <text x="640" y="368" fill="rgb(237 28 36)"> of q) { if (Array.isArray(applyrule) || Object.</text>
  <text x="688" y="368" fill="rgb(255 255 255)">keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; i</text>
  <text x="0" y="369" fill="rgb(255 255 255)">f (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightErr</text>
  <text x="119" y="369" fill="rgb(237 28 36)">or(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new I</text>
  <text x="244" y="369" fill="rgb(255 255 255)">nsightError(); } let applytoken: string</text>
  <text x="283" y="369" fill="rgb(24 158 180)"> = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(appl</text>
  <text x="380" y="369" fill="rgb(255 255 255)">ytoken)) { throw new Insi</text>
  <text x="405" y="369" fill="rgb(24 158 180)">ghtError(); } let key: string[] = criteria[applytoken].s</text>
  <text x="461" y="369" fill="rgb(255 255 255)">plit(&amp;quot;_&amp;quot;); if (key</text>
  <text x="479" y="369" fill="rgb(24 158 180)">.length !== 2) { throw new InsightError(); } if (thi</text>
  <text x="531" y="369" fill="rgb(255 255 255)">s.mtoken.includes(ap</text>
  <text x="551" y="369" fill="rgb(24 158 180)">plytoken)) { if (!(this.</text>
  <text x="575" y="369" fill="rgb(255 255 255)">validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { thr</text>
  <text x="640" y="369" fill="rgb(237 28 36)">ow new InsightError(); } } else if (this.mstoke</text>
  <text x="687" y="369" fill="rgb(255 255 255)">n.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new In</text>
  <text x="0" y="370" fill="rgb(255 255 255)">sightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { </text>
  <text x="119" y="370" fill="rgb(237 28 36)">if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { thi</text>
  <text x="244" y="370" fill="rgb(255 255 255)">s.validateOrder(q.ORDER); } } private </text>
  <text x="282" y="370" fill="rgb(24 158 180)">validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mske</text>
  <text x="381" y="370" fill="rgb(255 255 255)">y of q) { if (this.transf</text>
  <text x="406" y="370" fill="rgb(24 158 180)">ormationKey.length &amp;gt; 0) { if (!this.transformationKey.i</text>
  <text x="461" y="370" fill="rgb(255 255 255)">ncludes(mskey)) </text>
  <text x="477" y="370" fill="rgb(24 158 180)">{ throw new InsightError(); } } else { this.validateKe</text>
  <text x="531" y="370" fill="rgb(255 255 255)">y(mskey); } this.ke</text>
  <text x="550" y="370" fill="rgb(24 158 180)">ysInQuery.push(mskey); } </text>
  <text x="575" y="370" fill="rgb(255 255 255)">} private validateOrder(q: any): void { if (Array.isArray(q)) { t</text>
  <text x="640" y="370" fill="rgb(237 28 36)">hrow new InsightError(); } else if (typeof q ==</text>
  <text x="687" y="370" fill="rgb(255 255 255)">= &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { th</text>
  <text x="0" y="371" fill="rgb(255 255 255)">row new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys;</text>
  <text x="119" y="371" fill="rgb(237 28 36)"> if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.</text>
  <text x="244" y="371" fill="rgb(255 255 255)">includes(anykey)) { throw new InsightE</text>
  <text x="282" y="371" fill="rgb(24 158 180)">rror(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(</text>
  <text x="382" y="371" fill="rgb(255 255 255)">); } else { if (Object.ke</text>
  <text x="407" y="371" fill="rgb(24 158 180)">ys(q).length !== 0) { this.validateFilter(q); } } } pr</text>
  <text x="461" y="371" fill="rgb(255 255 255)">ivate validateF</text>
  <text x="476" y="371" fill="rgb(24 158 180)">ilter(q: any): void { if (Object.keys(q).length !== 1)</text>
  <text x="530" y="371" fill="rgb(255 255 255)"> { throw new Insigh</text>
  <text x="549" y="371" fill="rgb(24 158 180)">tError(); } else { let key:</text>
  <text x="576" y="371" fill="rgb(255 255 255)"> string = Object.keys(q)[0]; let value: any = Object.values(q)[0</text>
  <text x="640" y="371" fill="rgb(237 28 36)">]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.v</text>
  <text x="687" y="371" fill="rgb(255 255 255)">alidateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;</text>
  <text x="0" y="372" fill="rgb(255 255 255)">IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if</text>
  <text x="119" y="372" fill="rgb(237 28 36)"> (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void</text>
  <text x="244" y="372" fill="rgb(255 255 255)"> { if (typeof value !== &amp;quot;object&amp;quot;) { th</text>
  <text x="282" y="372" fill="rgb(24 158 180)">row new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey</text>
  <text x="383" y="372" fill="rgb(255 255 255)">: string[] = Object.keys(</text>
  <text x="408" y="372" fill="rgb(24 158 180)">value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw </text>
  <text x="461" y="372" fill="rgb(255 255 255)">new InsightErr</text>
  <text x="475" y="372" fill="rgb(24 158 180)">or(); } else { let idstring: string = skey[0]; let sfi</text>
  <text x="529" y="372" fill="rgb(255 255 255)">eld: string = skey[</text>
  <text x="548" y="372" fill="rgb(24 158 180)">1]; let str: any = Object.va</text>
  <text x="576" y="372" fill="rgb(255 255 255)">lues(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new Insight</text>
  <text x="640" y="372" fill="rgb(237 28 36)">Error(); } else { if ((str.slice(1, -1).include</text>
  <text x="687" y="372" fill="rgb(255 255 255)">s(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: a</text>
  <text x="0" y="373" fill="rgb(255 255 255)">ny): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: s</text>
  <text x="119" y="373" fill="rgb(237 28 36)">tring[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string </text>
  <text x="244" y="373" fill="rgb(255 255 255)">= mkey[0]; let mfield: string = mkey[1</text>
  <text x="282" y="373" fill="rgb(24 158 180)">]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(ids</text>
  <text x="384" y="373" fill="rgb(255 255 255)">tring) || !this.mfields.i</text>
  <text x="409" y="373" fill="rgb(24 158 180)">ncludes(mfield)) { throw new InsightError(); } } } pr</text>
  <text x="462" y="373" fill="rgb(255 255 255)">ivate valida</text>
  <text x="474" y="373" fill="rgb(24 158 180)">teANDOR(value: any): void { if (!Array.isArray(value) |</text>
  <text x="529" y="373" fill="rgb(255 255 255)">| value.length &amp;lt; 1</text>
  <text x="547" y="373" fill="rgb(24 158 180)">) { throw new InsightError();</text>
  <text x="576" y="373" fill="rgb(255 255 255)"> } for (let innerObject of value) { this.validateFilter(innerObj</text>
  <text x="640" y="373" fill="rgb(237 28 36)">ect); } } private validateIdstring(idstring: st</text>
  <text x="687" y="373" fill="rgb(255 255 255)">ring): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { thi</text>
  <text x="0" y="374" fill="rgb(255 255 255)">s.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields;</text>
  <text x="120" y="374" fill="rgb(237 28 36)"> this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true</text>
  <text x="244" y="374" fill="rgb(255 255 255)">; } } return false; } else { return th</text>
  <text x="282" y="374" fill="rgb(24 158 180)">is.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } impor</text>
  <text x="385" y="374" fill="rgb(255 255 255)">t {InsightDataset, Insigh</text>
  <text x="410" y="374" fill="rgb(24 158 180)">tDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;;</text>
  <text x="462" y="374" fill="rgb(255 255 255)"> export de</text>
  <text x="472" y="374" fill="rgb(24 158 180)">fault class QueryValidator { private readonly coursemfie</text>
  <text x="528" y="374" fill="rgb(255 255 255)">lds: string[] = [&amp;quot;a</text>
  <text x="547" y="374" fill="rgb(24 158 180)">vg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;,</text>
  <text x="576" y="374" fill="rgb(255 255 255)"> &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;i</text>
  <text x="640" y="374" fill="rgb(237 28 36)">d&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private re</text>
  <text x="686" y="374" fill="rgb(255 255 255)">adonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;addr</text>
  <text x="0" y="375" fill="rgb(255 255 255)">ess&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly m</text>
  <text x="120" y="375" fill="rgb(237 28 36)">stoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: strin</text>
  <text x="244" y="375" fill="rgb(255 255 255)">g[]; // all keys appeared in columns a</text>
  <text x="282" y="375" fill="rgb(24 158 180)">fter being validated private transformationKey: string[]; // keys appeared in transformation, if there i</text>
  <text x="386" y="375" fill="rgb(255 255 255)">s a transformation privat</text>
  <text x="411" y="375" fill="rgb(24 158 180)">e allInsightDataset: InsightDataset[]; private mfie</text>
  <text x="462" y="375" fill="rgb(255 255 255)">lds: stri</text>
  <text x="471" y="375" fill="rgb(24 158 180)">ng[]; private sfields: string[]; constructor(insightData</text>
  <text x="527" y="375" fill="rgb(255 255 255)">sets: InsightDatase</text>
  <text x="546" y="375" fill="rgb(24 158 180)">t[]) { this.idInQuery = []; th</text>
  <text x="576" y="375" fill="rgb(255 255 255)">is.keysInQuery = []; this.transformationKey = []; this.allInsigh</text>
  <text x="640" y="375" fill="rgb(237 28 36)">tDataset = insightDatasets; } public validate(</text>
  <text x="686" y="375" fill="rgb(255 255 255)">q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== </text>
  <text x="0" y="376" fill="rgb(255 255 255)">&amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS</text>
  <text x="120" y="376" fill="rgb(237 28 36)">) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: </text>
  <text x="244" y="376" fill="rgb(255 255 255)">any): void { if (typeof q.GROUP === &amp;quot;u</text>
  <text x="282" y="376" fill="rgb(24 158 180)">ndefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); }</text>
  <text x="387" y="376" fill="rgb(255 255 255)"> this.validateGROUP(q.GRO</text>
  <text x="412" y="376" fill="rgb(24 158 180)">UP); this.validateAPPLY(q.APPLY); } private valida</text>
  <text x="462" y="376" fill="rgb(255 255 255)">teGROUP(</text>
  <text x="470" y="376" fill="rgb(24 158 180)">q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { </text>
  <text x="527" y="376" fill="rgb(255 255 255)">throw new InsightE</text>
  <text x="545" y="376" fill="rgb(24 158 180)">rror(); // q should be an objec</text>
  <text x="576" y="376" fill="rgb(255 255 255)">t, and should has at least one element } for (let key of q) { th</text>
  <text x="640" y="376" fill="rgb(237 28 36)">is.validateKey(key); this.transformationKey.pu</text>
  <text x="686" y="376" fill="rgb(255 255 255)">sh(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_</text>
  <text x="0" y="377" fill="rgb(255 255 255)">&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfi</text>
  <text x="120" y="377" fill="rgb(237 28 36)">elds.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAP</text>
  <text x="244" y="377" fill="rgb(255 255 255)">PLY(q: any): void { if (!Array.isArray</text>
  <text x="282" y="377" fill="rgb(24 158 180)">(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let </text>
  <text x="388" y="377" fill="rgb(255 255 255)">applyrule of q) { if (Arr</text>
  <text x="413" y="377" fill="rgb(24 158 180)">ay.isArray(applyrule) || Object.keys(applyrule).le</text>
  <text x="463" y="377" fill="rgb(255 255 255)">ngth &amp;gt;</text>
  <text x="469" y="377" fill="rgb(24 158 180)"> 1) { throw new InsightError(); } let applykey: string = </text>
  <text x="526" y="377" fill="rgb(255 255 255)">Object.keys(applyr</text>
  <text x="544" y="377" fill="rgb(24 158 180)">ule)[0]; let criteria = applyrul</text>
  <text x="576" y="377" fill="rgb(255 255 255)">e[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) </text>
  <text x="641" y="377" fill="rgb(237 28 36)">|| this.transformationKey.includes(applykey))</text>
  <text x="686" y="377" fill="rgb(255 255 255)"> { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new </text>
  <text x="0" y="378" fill="rgb(255 255 255)">InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.msto</text>
  <text x="120" y="378" fill="rgb(237 28 36)">ken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !</text>
  <text x="245" y="378" fill="rgb(255 255 255)">== 2) { throw new InsightError(); } </text>
  <text x="281" y="378" fill="rgb(24 158 180)">if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1])</text>
  <text x="389" y="378" fill="rgb(255 255 255)">)) { throw new InsightErr</text>
  <text x="414" y="378" fill="rgb(24 158 180)">or(); } } else if (this.mstoken.includes(applytok</text>
  <text x="463" y="378" fill="rgb(255 255 255)">en)) </text>
  <text x="468" y="378" fill="rgb(24 158 180)">{ if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.in</text>
  <text x="525" y="378" fill="rgb(255 255 255)">cludes(key[1]) || t</text>
  <text x="544" y="378" fill="rgb(24 158 180)">his.mfields.includes(key[1])))) </text>
  <text x="576" y="378" fill="rgb(255 255 255)">{ throw new InsightError(); } } } } public validateOptions(q: any</text>
  <text x="641" y="378" fill="rgb(237 28 36)">): void { let keys: any[] = Object.keys(q); f</text>
  <text x="686" y="378" fill="rgb(255 255 255)">or (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { th</text>
  <text x="0" y="379" fill="rgb(255 255 255)">is.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(</text>
  <text x="120" y="379" fill="rgb(237 28 36)">); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new</text>
  <text x="245" y="379" fill="rgb(255 255 255)"> InsightError(); } } else { this.val</text>
  <text x="281" y="379" fill="rgb(24 158 180)">idateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(</text>
  <text x="390" y="379" fill="rgb(255 255 255)">q)) { throw new InsightEr</text>
  <text x="415" y="379" fill="rgb(24 158 180)">ror(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!</text>
  <text x="463" y="379" fill="rgb(255 255 255)">thi</text>
  <text x="466" y="379" fill="rgb(24 158 180)">s.keysInQuery.includes(q)) { throw new InsightError(); } } </text>
  <text x="525" y="379" fill="rgb(255 255 255)">else { if (!q.dir </text>
  <text x="543" y="379" fill="rgb(24 158 180)">|| !q.keys || Object.keys(q).lengt</text>
  <text x="577" y="379" fill="rgb(255 255 255)">h !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.d</text>
  <text x="641" y="379" fill="rgb(237 28 36)">ir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); }</text>
  <text x="685" y="379" fill="rgb(255 255 255)"> let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery</text>
  <text x="0" y="380" fill="rgb(255 255 255)">.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { thro</text>
  <text x="120" y="380" fill="rgb(237 28 36)">w new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any</text>
  <text x="245" y="380" fill="rgb(255 255 255)">): void { if (Object.keys(q).length </text>
  <text x="281" y="380" fill="rgb(24 158 180)">!== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.value</text>
  <text x="391" y="380" fill="rgb(255 255 255)">s(q)[0]; switch (key) { </text>
  <text x="415" y="380" fill="rgb(24 158 180)">case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value)</text>
  <text x="463" y="380" fill="rgb(255 255 255)">; </text>
  <text x="465" y="380" fill="rgb(24 158 180)">break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT</text>
  <text x="524" y="380" fill="rgb(255 255 255)">&amp;quot;: case &amp;quot;LT&amp;quot;: case</text>
  <text x="542" y="380" fill="rgb(24 158 180)"> &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); </text>
  <text x="577" y="380" fill="rgb(255 255 255)">break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw </text>
  <text x="641" y="380" fill="rgb(237 28 36)">new InsightError(); } } } private validateNO</text>
  <text x="685" y="380" fill="rgb(255 255 255)">T(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): voi</text>
  <text x="0" y="381" fill="rgb(255 255 255)">d { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new Insight</text>
  <text x="121" y="381" fill="rgb(237 28 36)">Error(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else </text>
  <text x="245" y="381" fill="rgb(255 255 255)">{ let idstring: string = skey[0]; le</text>
  <text x="281" y="381" fill="rgb(24 158 180)">t sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new In</text>
  <text x="392" y="381" fill="rgb(255 255 255)">sightError(); } else { i</text>
  <text x="416" y="381" fill="rgb(24 158 180)">f ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.va</text>
  <text x="463" y="381" fill="rgb(255 255 255)">l</text>
  <text x="464" y="381" fill="rgb(24 158 180)">idateIdstring(idstring) || !this.sfields.includes(sfield)) </text>
  <text x="523" y="381" fill="rgb(255 255 255)">{ throw new Insight</text>
  <text x="542" y="381" fill="rgb(24 158 180)">Error(); } } } } private validateGT</text>
  <text x="577" y="381" fill="rgb(255 255 255)">LTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object</text>
  <text x="641" y="381" fill="rgb(237 28 36)">.keys(value).length !== 1) { throw new Insig</text>
  <text x="685" y="381" fill="rgb(255 255 255)">htError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string</text>
  <text x="0" y="382" fill="rgb(255 255 255)"> = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.</text>
  <text x="121" y="382" fill="rgb(237 28 36)">validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value:</text>
  <text x="245" y="382" fill="rgb(255 255 255)"> any): void { if (!Array.isArray(val</text>
  <text x="281" y="382" fill="rgb(24 158 180)">ue) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(inne</text>
  <text x="393" y="382" fill="rgb(255 255 255)">rObject); } } private va</text>
  <text x="417" y="382" fill="rgb(24 158 180)">lidateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of </text>
  <text x="523" y="382" fill="rgb(255 255 255)">this.allInsightDat</text>
  <text x="541" y="382" fill="rgb(24 158 180)">aset) { if (insightDataset.id === id</text>
  <text x="577" y="382" fill="rgb(255 255 255)">string) { this.idInQuery.push(idstring); if (insightDataset.kind</text>
  <text x="641" y="382" fill="rgb(237 28 36)"> === InsightDatasetKind.Courses) { this.mfie</text>
  <text x="685" y="382" fill="rgb(255 255 255)">lds = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return tru</text>
  <text x="0" y="383" fill="rgb(255 255 255)">e; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this</text>
  <text x="121" y="383" fill="rgb(237 28 36)">.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class Quer</text>
  <text x="245" y="383" fill="rgb(255 255 255)">yValidator { private readonly course</text>
  <text x="281" y="383" fill="rgb(24 158 180)">mfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;,</text>
  <text x="394" y="383" fill="rgb(255 255 255)"> &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;ti</text>
  <text x="418" y="383" fill="rgb(24 158 180)">tle&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsf</text>
  <text x="522" y="383" fill="rgb(255 255 255)">ields: string[] = [</text>
  <text x="541" y="383" fill="rgb(24 158 180)">&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , </text>
  <text x="577" y="383" fill="rgb(255 255 255)">&amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonl</text>
  <text x="641" y="383" fill="rgb(237 28 36)">y mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, </text>
  <text x="684" y="383" fill="rgb(255 255 255)">&amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: stri</text>
  <text x="0" y="384" fill="rgb(255 255 255)">ng[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in tran</text>
  <text x="121" y="384" fill="rgb(237 28 36)">sformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfi</text>
  <text x="245" y="384" fill="rgb(255 255 255)">elds: string[]; constructor(insightD</text>
  <text x="281" y="384" fill="rgb(24 158 180)">atasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsi</text>
  <text x="395" y="384" fill="rgb(255 255 255)">ghtDataset = insightDat</text>
  <text x="418" y="384" fill="rgb(24 158 180)">asets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); }</text>
  <text x="522" y="384" fill="rgb(255 255 255)"> for (let key of O</text>
  <text x="540" y="384" fill="rgb(24 158 180)">bject.keys(q)) { if (key !== &amp;quot;OPTIONS</text>
  <text x="577" y="384" fill="rgb(255 255 255)">&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new I</text>
  <text x="641" y="384" fill="rgb(237 28 36)">nsightError(); } } this.validateWhere(q.WHE</text>
  <text x="684" y="384" fill="rgb(255 255 255)">RE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q:</text>
  <text x="0" y="385" fill="rgb(255 255 255)"> any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { thro</text>
  <text x="121" y="385" fill="rgb(237 28 36)">w new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if</text>
  <text x="245" y="385" fill="rgb(255 255 255)"> (!Array.isArray(q) || q.length &amp;lt; 1)</text>
  <text x="281" y="385" fill="rgb(24 158 180)"> { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { t</text>
  <text x="396" y="385" fill="rgb(255 255 255)">his.validateKey(key); t</text>
  <text x="419" y="385" fill="rgb(24 158 180)">his.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private vali</text>
  <text x="521" y="385" fill="rgb(255 255 255)">dateKey(key: strin</text>
  <text x="539" y="385" fill="rgb(24 158 180)">g): void { let splittedKey: string[] =</text>
  <text x="577" y="385" fill="rgb(255 255 255)"> key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new Insi</text>
  <text x="640" y="385" fill="rgb(237 28 36)">ghtError(); } if (!(this.validateIdstring(sp</text>
  <text x="684" y="385" fill="rgb(255 255 255)">littedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateA</text>
  <text x="0" y="386" fill="rgb(255 255 255)">PPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least</text>
  <text x="121" y="386" fill="rgb(237 28 36)"> one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new Ins</text>
  <text x="245" y="386" fill="rgb(255 255 255)">ightError(); } let applykey: string </text>
  <text x="281" y="386" fill="rgb(24 158 180)">= Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;)</text>
  <text x="397" y="386" fill="rgb(255 255 255)"> || this.transformation</text>
  <text x="420" y="386" fill="rgb(24 158 180)">Key.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Arr</text>
  <text x="520" y="386" fill="rgb(255 255 255)">ay.isArray(criteria</text>
  <text x="539" y="386" fill="rgb(24 158 180)">) || Object.keys(criteria).length &amp;gt; 1)</text>
  <text x="577" y="386" fill="rgb(255 255 255)"> { throw new InsightError(); } let applytoken: string = Object.</text>
  <text x="640" y="386" fill="rgb(237 28 36)">keys(criteria)[0]; if (!this.mtoken.includes</text>
  <text x="684" y="386" fill="rgb(255 255 255)">(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length</text>
  <text x="0" y="387" fill="rgb(255 255 255)"> !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.</text>
  <text x="122" y="387" fill="rgb(237 28 36)">mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validat</text>
  <text x="245" y="387" fill="rgb(255 255 255)">eIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.i</text>
  <text x="281" y="387" fill="rgb(24 158 180)">ncludes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any</text>
  <text x="398" y="387" fill="rgb(255 255 255)">): void { let keys: an</text>
  <text x="420" y="387" fill="rgb(24 158 180)">y[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new </text>
  <text x="520" y="387" fill="rgb(255 255 255)">InsightError(); } </text>
  <text x="538" y="387" fill="rgb(24 158 180)">} this.validateColumns(q.COLUMNS); if (</text>
  <text x="577" y="387" fill="rgb(255 255 255)">q.ORDER) { this.validateOrder(q.ORDER); } } private validateCol</text>
  <text x="640" y="387" fill="rgb(237 28 36)">umns(q: any): void { if (!q || q.length &amp;lt; 1</text>
  <text x="683" y="387" fill="rgb(255 255 255)">) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw n</text>
  <text x="0" y="388" fill="rgb(255 255 255)">ew InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): </text>
  <text x="122" y="388" fill="rgb(237 28 36)">void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes</text>
  <text x="245" y="388" fill="rgb(255 255 255)">(q)) { throw new InsightError(); } }</text>
  <text x="281" y="388" fill="rgb(24 158 180)"> else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.di</text>
  <text x="399" y="388" fill="rgb(255 255 255)">r !== &amp;quot;DOWN&amp;quot;) { throw </text>
  <text x="421" y="388" fill="rgb(24 158 180)">new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw</text>
  <text x="519" y="388" fill="rgb(255 255 255)"> new InsightError()</text>
  <text x="538" y="388" fill="rgb(24 158 180)">; } for (let anykey of keys) { if (!thi</text>
  <text x="577" y="388" fill="rgb(255 255 255)">s.keysInQuery.includes(anykey)) { throw new InsightError(); } }</text>
  <text x="640" y="388" fill="rgb(237 28 36)"> } } public validateWhere(q: any): void { i</text>
  <text x="683" y="388" fill="rgb(255 255 255)">f (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: a</text>
  <text x="0" y="389" fill="rgb(255 255 255)">ny): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let</text>
  <text x="122" y="389" fill="rgb(237 28 36)"> value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this</text>
  <text x="245" y="389" fill="rgb(255 255 255)">.validateNOT(value); break; case &amp;quot;GT</text>
  <text x="281" y="389" fill="rgb(24 158 180)">&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw ne</text>
  <text x="400" y="389" fill="rgb(255 255 255)">w InsightError(); } }</text>
  <text x="421" y="389" fill="rgb(24 158 180)"> } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError</text>
  <text x="519" y="389" fill="rgb(255 255 255)">(); } this.validat</text>
  <text x="537" y="389" fill="rgb(24 158 180)">eFilter(value); } private validateIS(val</text>
  <text x="577" y="389" fill="rgb(255 255 255)">ue: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new Ins</text>
  <text x="640" y="389" fill="rgb(237 28 36)">ightError(); } if (Object.keys(value).lengt</text>
  <text x="683" y="389" fill="rgb(255 255 255)">h !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } els</text>
  <text x="0" y="390" fill="rgb(255 255 255)">e { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !</text>
  <text x="122" y="390" fill="rgb(237 28 36)">== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) |</text>
  <text x="246" y="390" fill="rgb(255 255 255)">| !this.sfields.includes(sfield)) {</text>
  <text x="281" y="390" fill="rgb(24 158 180)"> throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.k</text>
  <text x="400" y="390" fill="rgb(255 255 255)">eys(value).length !== </text>
  <text x="422" y="390" fill="rgb(24 158 180)">1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey</text>
  <text x="518" y="390" fill="rgb(255 255 255)">.length !== 2) { th</text>
  <text x="537" y="390" fill="rgb(24 158 180)">row new InsightError(); } else { let ids</text>
  <text x="577" y="390" fill="rgb(255 255 255)">tring: string = mkey[0]; let mfield: string = mkey[1]; let num:</text>
  <text x="640" y="390" fill="rgb(237 28 36)"> any = Object.values(value)[0]; if ((typeof</text>
  <text x="683" y="390" fill="rgb(255 255 255)"> num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(valu</text>
  <text x="0" y="391" fill="rgb(255 255 255)">e: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value</text>
  <text x="122" y="391" fill="rgb(237 28 36)">) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length ==</text>
  <text x="246" y="391" fill="rgb(255 255 255)">= 0) { for (let insightDataset of t</text>
  <text x="281" y="391" fill="rgb(24 158 180)">his.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind ==</text>
  <text x="401" y="391" fill="rgb(255 255 255)">= InsightDatasetKind.</text>
  <text x="422" y="391" fill="rgb(24 158 180)">Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.m</text>
  <text x="518" y="391" fill="rgb(255 255 255)">fields = this.room</text>
  <text x="536" y="391" fill="rgb(24 158 180)">mfields; this.sfields = this.roomsfields;</text>
  <text x="577" y="391" fill="rgb(255 255 255)"> } return true; } } return false; } else { return this.idInQuer</text>
  <text x="640" y="391" fill="rgb(237 28 36)">y.includes(idstring); } } public getIdInQu</text>
  <text x="682" y="391" fill="rgb(255 255 255)">ery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class Qu</text>
  <text x="0" y="392" fill="rgb(255 255 255)">eryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly course</text>
  <text x="123" y="392" fill="rgb(237 28 36)">sfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, </text>
  <text x="246" y="392" fill="rgb(255 255 255)">&amp;quot;seats&amp;quot;]; private readonly roomsfie</text>
  <text x="281" y="392" fill="rgb(24 158 180)">lds: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mt</text>
  <text x="402" y="392" fill="rgb(255 255 255)">oken: string[] = [&amp;quot;MA</text>
  <text x="423" y="392" fill="rgb(24 158 180)">X&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: s</text>
  <text x="517" y="392" fill="rgb(255 255 255)">tring[]; // make su</text>
  <text x="536" y="392" fill="rgb(24 158 180)">re the query only has one id private keys</text>
  <text x="577" y="392" fill="rgb(255 255 255)">InQuery: string[]; // all keys appeared in columns after being </text>
  <text x="640" y="392" fill="rgb(237 28 36)">validated private transformationKey: strin</text>
  <text x="682" y="392" fill="rgb(255 255 255)">g[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private s</text>
  <text x="0" y="393" fill="rgb(255 255 255)">fields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transfo</text>
  <text x="123" y="393" fill="rgb(237 28 36)">rmationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIO</text>
  <text x="246" y="393" fill="rgb(255 255 255)">NS) { throw new InsightError(); } f</text>
  <text x="281" y="393" fill="rgb(24 158 180)">or (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new Insigh</text>
  <text x="403" y="393" fill="rgb(255 255 255)">tError(); } } this.v</text>
  <text x="423" y="393" fill="rgb(24 158 180)">alidateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS</text>
  <text x="517" y="393" fill="rgb(255 255 255)">); } this.validateO</text>
  <text x="536" y="393" fill="rgb(24 158 180)">ptions(q.OPTIONS); } public validateTrans</text>
  <text x="577" y="393" fill="rgb(255 255 255)">formations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; |</text>
  <text x="640" y="393" fill="rgb(237 28 36)">| typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object</text>
  <text x="682" y="393" fill="rgb(255 255 255)">.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { </text>
  <text x="0" y="394" fill="rgb(255 255 255)">if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one el</text>
  <text x="123" y="394" fill="rgb(237 28 36)">ement } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to tr</text>
  <text x="246" y="394" fill="rgb(255 255 255)">ansformationKey } } private validat</text>
  <text x="281" y="394" fill="rgb(24 158 180)">eKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightErro</text>
  <text x="404" y="394" fill="rgb(255 255 255)">r(); } if (!(this.va</text>
  <text x="424" y="394" fill="rgb(24 158 180)">lidateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.inc</text>
  <text x="516" y="394" fill="rgb(255 255 255)">ludes(splittedKey[1</text>
  <text x="535" y="394" fill="rgb(24 158 180)">])))) { throw new InsightError(); } } priv</text>
  <text x="577" y="394" fill="rgb(255 255 255)">ate validateAPPLY(q: any): void { if (!Array.isArray(q)) { thro</text>
  <text x="640" y="394" fill="rgb(237 28 36)">w new InsightError(); // q should be an ar</text>
  <text x="682" y="394" fill="rgb(255 255 255)">ray, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new I</text>
  <text x="0" y="395" fill="rgb(255 255 255)">nsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length </text>
  <text x="123" y="395" fill="rgb(237 28 36)">=== 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transforma</text>
  <text x="246" y="395" fill="rgb(255 255 255)">tionKey.push(applykey); if (Array.i</text>
  <text x="281" y="395" fill="rgb(24 158 180)">sArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(cr</text>
  <text x="404" y="395" fill="rgb(255 255 255)">iteria)[0]; if (!thi</text>
  <text x="424" y="395" fill="rgb(24 158 180)">s.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightErro</text>
  <text x="516" y="395" fill="rgb(255 255 255)">r(); } let key: str</text>
  <text x="535" y="395" fill="rgb(24 158 180)">ing[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); i</text>
  <text x="577" y="395" fill="rgb(255 255 255)">f (key.length !== 2) { throw new InsightError(); } if (this.mto</text>
  <text x="640" y="395" fill="rgb(237 28 36)">ken.includes(applytoken)) { if (!(this.va</text>
  <text x="681" y="395" fill="rgb(255 255 255)">lidateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.valid</text>
  <text x="0" y="396" fill="rgb(255 255 255)">ateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } </text>
  <text x="124" y="396" fill="rgb(237 28 36)">} public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;</text>
  <text x="246" y="396" fill="rgb(255 255 255)">&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new Insi</text>
  <text x="281" y="396" fill="rgb(24 158 180)">ghtError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: </text>
  <text x="405" y="396" fill="rgb(255 255 255)">any): void { if (!q</text>
  <text x="424" y="396" fill="rgb(24 158 180)"> || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformat</text>
  <text x="515" y="396" fill="rgb(255 255 255)">ionKey.length &amp;gt; 0) </text>
  <text x="534" y="396" fill="rgb(24 158 180)">{ if (!this.transformationKey.includes(mske</text>
  <text x="577" y="396" fill="rgb(255 255 255)">y)) { throw new InsightError(); } } else { this.validateKey(msk</text>
  <text x="640" y="396" fill="rgb(237 28 36)">ey); } this.keysInQuery.push(mskey); } } </text>
  <text x="681" y="396" fill="rgb(255 255 255)">private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includ</text>
  <text x="0" y="397" fill="rgb(255 255 255)">es(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError</text>
  <text x="124" y="397" fill="rgb(237 28 36)">(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys</text>
  <text x="247" y="397" fill="rgb(255 255 255)">) || keys.length &amp;lt; 1) { throw new </text>
  <text x="281" y="397" fill="rgb(24 158 180)">InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } publ</text>
  <text x="406" y="397" fill="rgb(255 255 255)">ic validateWhere(q:</text>
  <text x="425" y="397" fill="rgb(24 158 180)"> any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q</text>
  <text x="515" y="397" fill="rgb(255 255 255)">).length !== 0) { t</text>
  <text x="534" y="397" fill="rgb(24 158 180)">his.validateFilter(q); } } } private valida</text>
  <text x="577" y="397" fill="rgb(255 255 255)">teFilter(q: any): void { if (Object.keys(q).length !== 1) { thr</text>
  <text x="640" y="397" fill="rgb(237 28 36)">ow new InsightError(); } else { let key: </text>
  <text x="681" y="397" fill="rgb(255 255 255)">string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: th</text>
  <text x="0" y="398" fill="rgb(255 255 255)">is.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS</text>
  <text x="124" y="398" fill="rgb(237 28 36)">(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;obje</text>
  <text x="247" y="398" fill="rgb(255 255 255)">ct&amp;quot;) { throw new InsightError(); }</text>
  <text x="281" y="398" fill="rgb(24 158 180)"> this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(</text>
  <text x="407" y="398" fill="rgb(255 255 255)">); } if (Object.ke</text>
  <text x="425" y="398" fill="rgb(24 158 180)">ys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(va</text>
  <text x="514" y="398" fill="rgb(255 255 255)">lue)[0].split(&amp;quot;_&amp;quot;); </text>
  <text x="534" y="398" fill="rgb(24 158 180)">if (skey.length !== 2) { throw new InsightE</text>
  <text x="577" y="398" fill="rgb(255 255 255)">rror(); } else { let idstring: string = skey[0]; let sfield: st</text>
  <text x="640" y="398" fill="rgb(237 28 36)">ring = skey[1]; let str: any = Object.va</text>
  <text x="680" y="398" fill="rgb(255 255 255)">lues(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring</text>
  <text x="0" y="399" fill="rgb(255 255 255)">) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (type</text>
  <text x="124" y="399" fill="rgb(237 28 36)">of value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(va</text>
  <text x="247" y="399" fill="rgb(255 255 255)">lue)[0].split(&amp;quot;_&amp;quot;); if (mkey.lengt</text>
  <text x="281" y="399" fill="rgb(24 158 180)">h !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Obj</text>
  <text x="407" y="399" fill="rgb(255 255 255)">ect.values(value)[</text>
  <text x="425" y="399" fill="rgb(24 158 180)">0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.in</text>
  <text x="514" y="399" fill="rgb(255 255 255)">cludes(mfield)) { t</text>
  <text x="533" y="399" fill="rgb(24 158 180)">hrow new InsightError(); } } } private valid</text>
  <text x="577" y="399" fill="rgb(255 255 255)">ateANDOR(value: any): void { if (!Array.isArray(value) || value</text>
  <text x="640" y="399" fill="rgb(237 28 36)">.length &amp;lt; 1) { throw new InsightError();</text>
  <text x="680" y="399" fill="rgb(255 255 255)"> } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length</text>
  <text x="0" y="400" fill="rgb(255 255 255)"> === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idst</text>
  <text x="125" y="400" fill="rgb(237 28 36)">ring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.co</text>
  <text x="247" y="400" fill="rgb(255 255 255)">ursesfields; } else { this.mfields</text>
  <text x="281" y="400" fill="rgb(24 158 180)"> = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(</text>
  <text x="408" y="400" fill="rgb(255 255 255)">idstring); } } pub</text>
  <text x="426" y="400" fill="rgb(24 158 180)">lic getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, Insig</text>
  <text x="513" y="400" fill="rgb(255 255 255)">htDatasetKind, Insig</text>
  <text x="533" y="400" fill="rgb(24 158 180)">htError} from &amp;quot;./IInsightFacade&amp;quot;; export def</text>
  <text x="577" y="400" fill="rgb(255 255 255)">ault class QueryValidator { private readonly coursemfields: str</text>
  <text x="640" y="400" fill="rgb(237 28 36)">ing[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;,</text>
  <text x="680" y="400" fill="rgb(255 255 255)"> &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon</text>
  <text x="0" y="401" fill="rgb(255 255 255)">&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furnit</text>
  <text x="125" y="401" fill="rgb(237 28 36)">ure&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;CO</text>
  <text x="247" y="401" fill="rgb(255 255 255)">UNT&amp;quot;]; private idInQuery: string[]</text>
  <text x="281" y="401" fill="rgb(24 158 180)">; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated pr</text>
  <text x="409" y="401" fill="rgb(255 255 255)">ivate transformat</text>
  <text x="426" y="401" fill="rgb(24 158 180)">ionKey: string[]; // keys appeared in transformation, if there is a transformation priv</text>
  <text x="513" y="401" fill="rgb(255 255 255)">ate allInsightDatas</text>
  <text x="532" y="401" fill="rgb(24 158 180)">et: InsightDataset[]; private mfields: string</text>
  <text x="577" y="401" fill="rgb(255 255 255)">[]; private sfields: string[]; constructor(insightDatasets: Ins</text>
  <text x="640" y="401" fill="rgb(237 28 36)">ightDataset[]) { this.idInQuery = []; th</text>
  <text x="680" y="401" fill="rgb(255 255 255)">is.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OP</text>
  <text x="0" y="402" fill="rgb(255 255 255)">TIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;T</text>
  <text x="125" y="402" fill="rgb(237 28 36)">RANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransf</text>
  <text x="247" y="402" fill="rgb(255 255 255)">ormations(q.TRANSFORMATIONS); } th</text>
  <text x="281" y="402" fill="rgb(24 158 180)">is.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.A</text>
  <text x="409" y="402" fill="rgb(255 255 255)">PPLY === &amp;quot;undefin</text>
  <text x="426" y="402" fill="rgb(24 158 180)">ed&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q</text>
  <text x="512" y="402" fill="rgb(255 255 255)">.GROUP); this.valida</text>
  <text x="532" y="402" fill="rgb(24 158 180)">teAPPLY(q.APPLY); } private validateGROUP(q: </text>
  <text x="577" y="402" fill="rgb(255 255 255)">any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new</text>
  <text x="640" y="402" fill="rgb(237 28 36)"> InsightError(); // q should be an obje</text>
  <text x="679" y="402" fill="rgb(255 255 255)">ct, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to</text>
  <text x="0" y="403" fill="rgb(255 255 255)"> transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.le</text>
  <text x="126" y="403" fill="rgb(237 28 36)">ngth !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKe</text>
  <text x="248" y="403" fill="rgb(255 255 255)">y[1]) || this.sfields.includes(sp</text>
  <text x="281" y="403" fill="rgb(24 158 180)">littedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new Insight</text>
  <text x="410" y="403" fill="rgb(255 255 255)">Error(); // q sho</text>
  <text x="427" y="403" fill="rgb(24 158 180)">uld be an array, and should have at least one element } for (let applyrule of q) { if</text>
  <text x="512" y="403" fill="rgb(255 255 255)"> (Array.isArray(appl</text>
  <text x="532" y="403" fill="rgb(24 158 180)">yrule) || Object.keys(applyrule).length &amp;gt; 1) </text>
  <text x="577" y="403" fill="rgb(255 255 255)">{ throw new InsightError(); } let applykey: string = Object.key</text>
  <text x="640" y="403" fill="rgb(237 28 36)">s(applyrule)[0]; let criteria = applyru</text>
  <text x="679" y="403" fill="rgb(255 255 255)">le[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transfo</text>
  <text x="0" y="404" fill="rgb(255 255 255)">rmationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let </text>
  <text x="126" y="404" fill="rgb(237 28 36)">applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)</text>
  <text x="248" y="404" fill="rgb(255 255 255)">) { throw new InsightError(); } le</text>
  <text x="282" y="404" fill="rgb(24 158 180)">t key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(a</text>
  <text x="411" y="404" fill="rgb(255 255 255)">pplytoken)) { if</text>
  <text x="427" y="404" fill="rgb(24 158 180)"> (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new Ins</text>
  <text x="511" y="404" fill="rgb(255 255 255)">ightError(); } } els</text>
  <text x="531" y="404" fill="rgb(24 158 180)">e if (this.mstoken.includes(applytoken)) { if </text>
  <text x="577" y="404" fill="rgb(255 255 255)">(!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[</text>
  <text x="640" y="404" fill="rgb(237 28 36)">1]) || this.mfields.includes(key[1]))))</text>
  <text x="679" y="404" fill="rgb(255 255 255)"> { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS</text>
  <text x="0" y="405" fill="rgb(255 255 255)">&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORD</text>
  <text x="126" y="405" fill="rgb(237 28 36)">ER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q</text>
  <text x="248" y="405" fill="rgb(255 255 255)">) { if (this.transformationKey.len</text>
  <text x="282" y="405" fill="rgb(24 158 180)">gth &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.ke</text>
  <text x="411" y="405" fill="rgb(255 255 255)">ysInQuery.push(m</text>
  <text x="427" y="405" fill="rgb(24 158 180)">skey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new I</text>
  <text x="511" y="405" fill="rgb(255 255 255)">nsightError(); } els</text>
  <text x="531" y="405" fill="rgb(24 158 180)">e if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysI</text>
  <text x="577" y="405" fill="rgb(255 255 255)">nQuery.includes(q)) { throw new InsightError(); } } else { if (</text>
  <text x="640" y="405" fill="rgb(237 28 36)">!q.dir || !q.keys || Object.keys(q).len</text>
  <text x="679" y="405" fill="rgb(255 255 255)">gth !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(</text>
  <text x="0" y="406" fill="rgb(255 255 255)">keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { t</text>
  <text x="126" y="406" fill="rgb(237 28 36)">hrow new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } </text>
  <text x="248" y="406" fill="rgb(255 255 255)">else { if (Object.keys(q).length !</text>
  <text x="282" y="406" fill="rgb(24 158 180)">== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightE</text>
  <text x="412" y="406" fill="rgb(255 255 255)">rror(); } else </text>
  <text x="427" y="406" fill="rgb(24 158 180)">{ let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch</text>
  <text x="510" y="406" fill="rgb(255 255 255)"> (key) { case &amp;quot;AND&amp;quot;:</text>
  <text x="530" y="406" fill="rgb(24 158 180)"> case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; c</text>
  <text x="577" y="406" fill="rgb(255 255 255)">ase &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT</text>
  <text x="639" y="406" fill="rgb(237 28 36)">&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value</text>
  <text x="678" y="406" fill="rgb(255 255 255)">); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;</text>
  <text x="0" y="407" fill="rgb(255 255 255)">object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !=</text>
  <text x="127" y="407" fill="rgb(237 28 36)">= &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: st</text>
  <text x="248" y="407" fill="rgb(255 255 255)">ring[] = Object.keys(value)[0].spl</text>
  <text x="282" y="407" fill="rgb(24 158 180)">it(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1];</text>
  <text x="412" y="407" fill="rgb(255 255 255)"> let str: any =</text>
  <text x="427" y="407" fill="rgb(24 158 180)"> Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); </text>
  <text x="510" y="407" fill="rgb(255 255 255)">} else { if ((str.sl</text>
  <text x="530" y="407" fill="rgb(24 158 180)">ice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIds</text>
  <text x="576" y="407" fill="rgb(255 255 255)">tring(idstring) || !this.sfields.includes(sfield)) { throw new </text>
  <text x="639" y="407" fill="rgb(237 28 36)">InsightError(); } } } } private validat</text>
  <text x="678" y="407" fill="rgb(255 255 255)">eGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.key</text>
  <text x="0" y="408" fill="rgb(255 255 255)">s(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield:</text>
  <text x="127" y="408" fill="rgb(237 28 36)"> string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstri</text>
  <text x="248" y="408" fill="rgb(255 255 255)">ng) || !this.mfields.includes(mfie</text>
  <text x="282" y="408" fill="rgb(24 158 180)">ld)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { t</text>
  <text x="413" y="408" fill="rgb(255 255 255)">hrow new Insig</text>
  <text x="427" y="408" fill="rgb(24 158 180)">htError(); } for (let innerObject of value) { this.validateFilter(innerObject); } </text>
  <text x="509" y="408" fill="rgb(255 255 255)">} private validateId</text>
  <text x="529" y="408" fill="rgb(24 158 180)">string(idstring: string): boolean { if (this.id</text>
  <text x="576" y="408" fill="rgb(255 255 255)">InQuery.length === 0) { for (let insightDataset of this.allInsi</text>
  <text x="639" y="408" fill="rgb(237 28 36)">ghtDataset) { if (insightDataset.id ===</text>
  <text x="678" y="408" fill="rgb(255 255 255)"> idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = thi</text>
  <text x="0" y="409" fill="rgb(255 255 255)">s.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } </text>
  <text x="127" y="409" fill="rgb(237 28 36)">else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {</text>
  <text x="249" y="409" fill="rgb(255 255 255)">InsightDataset, InsightDatasetKin</text>
  <text x="282" y="409" fill="rgb(24 158 180)">d, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;</text>
  <text x="414" y="409" fill="rgb(255 255 255)">pass&amp;quot;, &amp;quot;fail&amp;quot;</text>
  <text x="427" y="409" fill="rgb(24 158 180)">, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;ins</text>
  <text x="509" y="409" fill="rgb(255 255 255)">tructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;</text>
  <text x="529" y="409" fill="rgb(24 158 180)">uuid&amp;quot;]; private readonly roommfields: string[] </text>
  <text x="576" y="409" fill="rgb(255 255 255)">= [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string</text>
  <text x="639" y="409" fill="rgb(237 28 36)">[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number</text>
  <text x="677" y="409" fill="rgb(255 255 255)">&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = </text>
  <text x="0" y="410" fill="rgb(255 255 255)">[&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appear</text>
  <text x="128" y="410" fill="rgb(237 28 36)">ed in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is </text>
  <text x="249" y="410" fill="rgb(255 255 255)">a transformation private allInsig</text>
  <text x="282" y="410" fill="rgb(24 158 180)">htDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { </text>
  <text x="414" y="410" fill="rgb(255 255 255)">this.idInQuery</text>
  <text x="428" y="410" fill="rgb(24 158 180)"> = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDatase</text>
  <text x="508" y="410" fill="rgb(255 255 255)">t = insightDatasets;</text>
  <text x="528" y="410" fill="rgb(24 158 180)"> } public validate(q: any): void { if (!q || !q.</text>
  <text x="576" y="410" fill="rgb(255 255 255)">WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key</text>
  <text x="639" y="410" fill="rgb(237 28 36)"> of Object.keys(q)) { if (key !== &amp;quot;OPT</text>
  <text x="677" y="410" fill="rgb(255 255 255)">IONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTr</text>
  <text x="0" y="411" fill="rgb(255 255 255)">ansformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof</text>
  <text x="128" y="411" fill="rgb(237 28 36)"> q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } </text>
  <text x="249" y="411" fill="rgb(255 255 255)">this.validateGROUP(q.GROUP); this</text>
  <text x="282" y="411" fill="rgb(24 158 180)">.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); /</text>
  <text x="415" y="411" fill="rgb(255 255 255)">/ q should be</text>
  <text x="428" y="411" fill="rgb(24 158 180)"> an object, and should has at least one element } for (let key of q) { this.vali</text>
  <text x="508" y="411" fill="rgb(255 255 255)">dateKey(key); this.t</text>
  <text x="528" y="411" fill="rgb(24 158 180)">ransformationKey.push(key); // if the key is val</text>
  <text x="576" y="411" fill="rgb(255 255 255)">id, push it to transformationKey } } private validateKey(key: s</text>
  <text x="639" y="411" fill="rgb(237 28 36)">tring): void { let splittedKey: string</text>
  <text x="677" y="411" fill="rgb(255 255 255)">[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(split</text>
  <text x="0" y="412" fill="rgb(255 255 255)">tedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if </text>
  <text x="128" y="412" fill="rgb(237 28 36)">(!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let </text>
  <text x="249" y="412" fill="rgb(255 255 255)">applyrule of q) { if (Array.isArr</text>
  <text x="282" y="412" fill="rgb(24 158 180)">ay(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; l</text>
  <text x="415" y="412" fill="rgb(255 255 255)">et criteria </text>
  <text x="427" y="412" fill="rgb(24 158 180)">= applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || thi</text>
  <text x="508" y="412" fill="rgb(255 255 255)">s.transformationKey</text>
  <text x="527" y="412" fill="rgb(24 158 180)">.includes(applykey)) { throw new InsightError(); </text>
  <text x="576" y="412" fill="rgb(255 255 255)">} this.transformationKey.push(applykey); if (Array.isArray(crit</text>
  <text x="639" y="412" fill="rgb(237 28 36)">eria) || Object.keys(criteria).length</text>
  <text x="676" y="412" fill="rgb(255 255 255)"> &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applyt</text>
  <text x="0" y="413" fill="rgb(255 255 255)">oken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new Insig</text>
  <text x="129" y="413" fill="rgb(237 28 36)">htError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]</text>
  <text x="249" y="413" fill="rgb(255 255 255)">))) { throw new InsightError(); } </text>
  <text x="283" y="413" fill="rgb(24 158 180)">} else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields</text>
  <text x="416" y="413" fill="rgb(255 255 255)">.includes(k</text>
  <text x="427" y="413" fill="rgb(24 158 180)">ey[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): vo</text>
  <text x="507" y="413" fill="rgb(255 255 255)">id { let keys: any[]</text>
  <text x="527" y="413" fill="rgb(24 158 180)"> = Object.keys(q); for (let key of keys) { if (ke</text>
  <text x="576" y="413" fill="rgb(255 255 255)">y !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError();</text>
  <text x="639" y="413" fill="rgb(237 28 36)"> } } this.validateColumns(q.COLUMNS);</text>
  <text x="676" y="413" fill="rgb(255 255 255)"> if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey</text>
  <text x="0" y="414" fill="rgb(255 255 255)"> of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } el</text>
  <text x="129" y="414" fill="rgb(237 28 36)">se { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray</text>
  <text x="250" y="414" fill="rgb(255 255 255)">(q)) { throw new InsightError(); </text>
  <text x="283" y="414" fill="rgb(24 158 180)">} else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys |</text>
  <text x="416" y="414" fill="rgb(255 255 255)">| Object.ke</text>
  <text x="427" y="414" fill="rgb(24 158 180)">ys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !=</text>
  <text x="507" y="414" fill="rgb(255 255 255)">= &amp;quot;DOWN&amp;quot;) { throw n</text>
  <text x="526" y="414" fill="rgb(24 158 180)">ew InsightError(); } let keys: any = q.keys; if (</text>
  <text x="575" y="414" fill="rgb(255 255 255)">!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightErro</text>
  <text x="639" y="414" fill="rgb(237 28 36)">r(); } for (let anykey of keys) { if </text>
  <text x="676" y="414" fill="rgb(255 255 255)">(!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(</text>
  <text x="0" y="415" fill="rgb(255 255 255)">); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.key</text>
  <text x="130" y="415" fill="rgb(237 28 36)">s(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.val</text>
  <text x="250" y="415" fill="rgb(255 255 255)">ues(q)[0]; switch (key) { case &amp;quot;A</text>
  <text x="283" y="415" fill="rgb(24 158 180)">ND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.va</text>
  <text x="417" y="415" fill="rgb(255 255 255)">lidateGTLT</text>
  <text x="427" y="415" fill="rgb(24 158 180)">EQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new </text>
  <text x="506" y="415" fill="rgb(255 255 255)">InsightError(); } } </text>
  <text x="526" y="415" fill="rgb(24 158 180)">} private validateNOT(value: any): void { if (typ</text>
  <text x="575" y="415" fill="rgb(255 255 255)">eof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.valid</text>
  <text x="639" y="415" fill="rgb(237 28 36)">ateFilter(value); } private validateI</text>
  <text x="676" y="415" fill="rgb(255 255 255)">S(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let ske</text>
  <text x="0" y="416" fill="rgb(255 255 255)">y: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string =</text>
  <text x="130" y="416" fill="rgb(237 28 36)"> skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new</text>
  <text x="250" y="416" fill="rgb(255 255 255)"> InsightError(); } else { if ((st</text>
  <text x="283" y="416" fill="rgb(24 158 180)">r.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } }</text>
  <text x="417" y="416" fill="rgb(255 255 255)"> } private</text>
  <text x="427" y="416" fill="rgb(24 158 180)"> validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.key</text>
  <text x="506" y="416" fill="rgb(255 255 255)">s(value).length !==</text>
  <text x="525" y="416" fill="rgb(24 158 180)"> 1) { throw new InsightError(); } let mkey: string</text>
  <text x="575" y="416" fill="rgb(255 255 255)">[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { </text>
  <text x="639" y="416" fill="rgb(237 28 36)">throw new InsightError(); } else { l</text>
  <text x="675" y="416" fill="rgb(255 255 255)">et idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(i</text>
  <text x="0" y="417" fill="rgb(255 255 255)">dstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array</text>
  <text x="130" y="417" fill="rgb(237 28 36)">.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(</text>
  <text x="250" y="417" fill="rgb(255 255 255)">innerObject); } } private validat</text>
  <text x="283" y="417" fill="rgb(24 158 180)">eIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insi</text>
  <text x="418" y="417" fill="rgb(255 255 255)">ghtDatase</text>
  <text x="427" y="417" fill="rgb(24 158 180)">t.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind ==</text>
  <text x="505" y="417" fill="rgb(255 255 255)">= InsightDatasetKind</text>
  <text x="525" y="417" fill="rgb(24 158 180)">.Courses) { this.mfields = this.coursemfields; thi</text>
  <text x="575" y="417" fill="rgb(255 255 255)">s.sfields = this.coursesfields; } else { this.mfields = this.roo</text>
  <text x="639" y="417" fill="rgb(237 28 36)">mmfields; this.sfields = this.roomsf</text>
  <text x="675" y="417" fill="rgb(255 255 255)">ields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } im</text>
  <text x="0" y="418" fill="rgb(255 255 255)">port {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private read</text>
  <text x="131" y="418" fill="rgb(237 28 36)">only coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;de</text>
  <text x="251" y="418" fill="rgb(255 255 255)">pt&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;</text>
  <text x="283" y="418" fill="rgb(24 158 180)">, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;sho</text>
  <text x="418" y="418" fill="rgb(255 255 255)">rtname&amp;quot;,</text>
  <text x="426" y="418" fill="rgb(24 158 180)"> &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly </text>
  <text x="504" y="418" fill="rgb(255 255 255)">mtoken: string[] = [</text>
  <text x="524" y="418" fill="rgb(24 158 180)">&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstok</text>
  <text x="575" y="418" fill="rgb(255 255 255)">en: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make s</text>
  <text x="639" y="418" fill="rgb(237 28 36)">ure the query only has one id privat</text>
  <text x="675" y="418" fill="rgb(255 255 255)">e keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if the</text>
  <text x="0" y="419" fill="rgb(255 255 255)">re is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; construct</text>
  <text x="131" y="419" fill="rgb(237 28 36)">or(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.al</text>
  <text x="251" y="419" fill="rgb(255 255 255)">lInsightDataset = insightDatasets</text>
  <text x="284" y="419" fill="rgb(24 158 180)">; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { i</text>
  <text x="419" y="419" fill="rgb(255 255 255)">f (key </text>
  <text x="426" y="419" fill="rgb(24 158 180)">!== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new Ins</text>
  <text x="504" y="419" fill="rgb(255 255 255)">ightError(); } } thi</text>
  <text x="524" y="419" fill="rgb(24 158 180)">s.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { </text>
  <text x="575" y="419" fill="rgb(255 255 255)">this.validateTransformations(q.TRANSFORMATIONS); } this.validate</text>
  <text x="639" y="419" fill="rgb(237 28 36)">Options(q.OPTIONS); } public valida</text>
  <text x="674" y="419" fill="rgb(255 255 255)">teTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError</text>
  <text x="0" y="420" fill="rgb(255 255 255)">(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.</text>
  <text x="131" y="420" fill="rgb(237 28 36)">length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of </text>
  <text x="251" y="420" fill="rgb(255 255 255)">q) { this.validateKey(key); this.</text>
  <text x="284" y="420" fill="rgb(24 158 180)">transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let spli</text>
  <text x="419" y="420" fill="rgb(255 255 255)">ttedKey</text>
  <text x="426" y="420" fill="rgb(24 158 180)">: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new Insigh</text>
  <text x="503" y="420" fill="rgb(255 255 255)">tError(); } if (!(th</text>
  <text x="523" y="420" fill="rgb(24 158 180)">is.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfield</text>
  <text x="574" y="420" fill="rgb(255 255 255)">s.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1</text>
  <text x="639" y="420" fill="rgb(237 28 36)">])))) { throw new InsightError(); }</text>
  <text x="674" y="420" fill="rgb(255 255 255)"> } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for</text>
  <text x="0" y="421" fill="rgb(255 255 255)"> (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applyke</text>
  <text x="132" y="421" fill="rgb(237 28 36)">y: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includ</text>
  <text x="251" y="421" fill="rgb(255 255 255)">es(&amp;quot;_&amp;quot;) || this.transformationKey</text>
  <text x="284" y="421" fill="rgb(24 158 180)">.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(cri</text>
  <text x="420" y="421" fill="rgb(255 255 255)">teria)</text>
  <text x="426" y="421" fill="rgb(24 158 180)">.length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.ke</text>
  <text x="503" y="421" fill="rgb(255 255 255)">ys(criteria)[0]; if</text>
  <text x="522" y="421" fill="rgb(24 158 180)"> (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken</text>
  <text x="574" y="421" fill="rgb(255 255 255)">.includes(applytoken)) { throw new InsightError(); } let key: str</text>
  <text x="639" y="421" fill="rgb(237 28 36)">ing[] = criteria[applytoken].split(</text>
  <text x="674" y="421" fill="rgb(255 255 255)">&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(</text>
  <text x="0" y="422" fill="rgb(255 255 255)">key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this</text>
  <text x="132" y="422" fill="rgb(237 28 36)">.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOption</text>
  <text x="251" y="422" fill="rgb(255 255 255)">s(q: any): void { let keys: any[]</text>
  <text x="284" y="422" fill="rgb(24 158 180)"> = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumn</text>
  <text x="420" y="422" fill="rgb(255 255 255)">s(q.C</text>
  <text x="425" y="422" fill="rgb(24 158 180)">OLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColu</text>
  <text x="502" y="422" fill="rgb(255 255 255)">mns(q: any): void { </text>
  <text x="522" y="422" fill="rgb(24 158 180)">if (!q || q.length &amp;lt; 1) { throw new InsightError(); </text>
  <text x="574" y="422" fill="rgb(255 255 255)">} for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) {</text>
  <text x="639" y="422" fill="rgb(237 28 36)"> if (!this.transformationKey.inclu</text>
  <text x="673" y="422" fill="rgb(255 255 255)">des(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.</text>
  <text x="0" y="423" fill="rgb(255 255 255)">isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightErr</text>
  <text x="133" y="423" fill="rgb(237 28 36)">or(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot;</text>
  <text x="252" y="423" fill="rgb(255 255 255)"> &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw ne</text>
  <text x="284" y="423" fill="rgb(24 158 180)">w InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey o</text>
  <text x="420" y="423" fill="rgb(255 255 255)">f key</text>
  <text x="425" y="423" fill="rgb(24 158 180)">s) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } }</text>
  <text x="501" y="423" fill="rgb(255 255 255)"> } } public validate</text>
  <text x="521" y="423" fill="rgb(24 158 180)">Where(q: any): void { if (Array.isArray(q)) { throw n</text>
  <text x="574" y="423" fill="rgb(255 255 255)">ew InsightError(); } else { if (Object.keys(q).length !== 0) { th</text>
  <text x="639" y="423" fill="rgb(237 28 36)">is.validateFilter(q); } } } privat</text>
  <text x="673" y="423" fill="rgb(255 255 255)">e validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Obj</text>
  <text x="0" y="424" fill="rgb(255 255 255)">ect.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break;</text>
  <text x="133" y="424" fill="rgb(237 28 36)"> case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default:</text>
  <text x="252" y="424" fill="rgb(255 255 255)"> throw new InsightError(); } } } </text>
  <text x="285" y="424" fill="rgb(24 158 180)">private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } priva</text>
  <text x="421" y="424" fill="rgb(255 255 255)">te </text>
  <text x="424" y="424" fill="rgb(24 158 180)">validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new In</text>
  <text x="500" y="424" fill="rgb(255 255 255)">sightError(); } if (</text>
  <text x="520" y="424" fill="rgb(24 158 180)">Object.keys(value).length !== 1) { throw new InsightE</text>
  <text x="573" y="424" fill="rgb(255 255 255)">rror(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); i</text>
  <text x="639" y="424" fill="rgb(237 28 36)">f (skey.length !== 2) { throw new </text>
  <text x="673" y="424" fill="rgb(255 255 255)">InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { th</text>
  <text x="0" y="425" fill="rgb(255 255 255)">row new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sf</text>
  <text x="134" y="425" fill="rgb(237 28 36)">ield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; ||</text>
  <text x="252" y="425" fill="rgb(255 255 255)"> Object.keys(value).length !== 1)</text>
  <text x="285" y="425" fill="rgb(24 158 180)"> { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError();</text>
  <text x="421" y="425" fill="rgb(255 255 255)"> } </text>
  <text x="424" y="425" fill="rgb(24 158 180)">else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num</text>
  <text x="500" y="425" fill="rgb(255 255 255)">: any = Object.value</text>
  <text x="520" y="425" fill="rgb(24 158 180)">s(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.v</text>
  <text x="573" y="425" fill="rgb(255 255 255)">alidateIdstring(idstring) || !this.mfields.includes(mfield)) { thr</text>
  <text x="639" y="425" fill="rgb(237 28 36)">ow new InsightError(); } } } priv</text>
  <text x="672" y="425" fill="rgb(255 255 255)">ate validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validate</text>
  <text x="0" y="426" fill="rgb(255 255 255)">Filter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightData</text>
  <text x="134" y="426" fill="rgb(237 28 36)">set of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDatas</text>
  <text x="252" y="426" fill="rgb(255 255 255)">et.kind === InsightDatasetKind.Co</text>
  <text x="285" y="426" fill="rgb(24 158 180)">urses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = t</text>
  <text x="422" y="426" fill="rgb(255 255 255)">h</text>
  <text x="423" y="426" fill="rgb(24 158 180)">is.roomsfields; } return true; } } return false; } else { return this.idInQu</text>
  <text x="499" y="426" fill="rgb(255 255 255)">ery.includes(idstrin</text>
  <text x="519" y="426" fill="rgb(24 158 180)">g); } } public getIdInQuery(): string[] { return this.</text>
  <text x="573" y="426" fill="rgb(255 255 255)">idInQuery; } } import {InsightDataset, InsightDatasetKind, Insigh</text>
  <text x="638" y="426" fill="rgb(237 28 36)">tError} from &amp;quot;./IInsightFacade&amp;quot;; e</text>
  <text x="672" y="426" fill="rgb(255 255 255)">xport default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[</text>
  <text x="0" y="427" fill="rgb(255 255 255)">] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly </text>
  <text x="134" y="427" fill="rgb(237 28 36)">roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private r</text>
  <text x="253" y="427" fill="rgb(255 255 255)">eadonly mtoken: string[] = [&amp;quot;MAX</text>
  <text x="285" y="427" fill="rgb(24 158 180)">&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one</text>
  <text x="422" y="427" fill="rgb(255 255 255)"/>
  <text x="423" y="427" fill="rgb(24 158 180)">id private keysInQuery: string[]; // all keys appeared in columns after bei</text>
  <text x="498" y="427" fill="rgb(255 255 255)">ng validated private</text>
  <text x="518" y="427" fill="rgb(24 158 180)"> transformationKey: string[]; // keys appeared in trans</text>
  <text x="573" y="427" fill="rgb(255 255 255)">formation, if there is a transformation p</text>
  <text x="614" y="427" fill="rgb(237 28 36)">r</text>
  <text x="615" y="427" fill="rgb(255 255 255)">ivate allInsightDataset</text>
  <text x="638" y="427" fill="rgb(237 28 36)">: InsightDataset[]; private mfield</text>
  <text x="672" y="427" fill="rgb(255 255 255)">s: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = [];</text>
  <text x="0" y="428" fill="rgb(255 255 255)"> this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError</text>
  <text x="135" y="428" fill="rgb(237 28 36)">(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw</text>
  <text x="253" y="428" fill="rgb(255 255 255)"> new InsightError(); } } this.val</text>
  <text x="286" y="428" fill="rgb(24 158 180)">idateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefine</text>
  <text x="497" y="428" fill="rgb(255 255 255)">d&amp;quot; || typeof q.APPLY </text>
  <text x="518" y="428" fill="rgb(24 158 180)">=== &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { thro</text>
  <text x="572" y="428" fill="rgb(255 255 255)">w new InsightError(); } this.validateGROU</text>
  <text x="613" y="428" fill="rgb(237 28 36)">P(</text>
  <text x="615" y="428" fill="rgb(255 255 255)">q.GROUP); this.validate</text>
  <text x="638" y="428" fill="rgb(237 28 36)">APPLY(q.APPLY); } private validat</text>
  <text x="671" y="428" fill="rgb(255 255 255)">eGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let</text>
  <text x="0" y="429" fill="rgb(255 255 255)"> key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private </text>
  <text x="135" y="429" fill="rgb(237 28 36)">validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new</text>
  <text x="253" y="429" fill="rgb(255 255 255)"> InsightError(); } if (!(this.val</text>
  <text x="286" y="429" fill="rgb(24 158 180)">idateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) {</text>
  <text x="496" y="429" fill="rgb(255 255 255)"> throw new InsightErr</text>
  <text x="517" y="429" fill="rgb(24 158 180)">or(); // q should be an array, and should have at least</text>
  <text x="572" y="429" fill="rgb(255 255 255)"> one element } for (let applyrule of q) </text>
  <text x="612" y="429" fill="rgb(237 28 36)">{ i</text>
  <text x="615" y="429" fill="rgb(255 255 255)">f (Array.isArray(applyr</text>
  <text x="638" y="429" fill="rgb(237 28 36)">ule) || Object.keys(applyrule).le</text>
  <text x="671" y="429" fill="rgb(255 255 255)">ngth &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applyke</text>
  <text x="0" y="430" fill="rgb(255 255 255)">y.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (A</text>
  <text x="136" y="430" fill="rgb(237 28 36)">rray.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Ob</text>
  <text x="253" y="430" fill="rgb(255 255 255)">ject.keys(criteria)[0]; if (!this</text>
  <text x="286" y="430" fill="rgb(24 158 180)">.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (thi</text>
  <text x="496" y="430" fill="rgb(255 255 255)">s.mtoken.includes(ap</text>
  <text x="516" y="430" fill="rgb(24 158 180)">plytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this</text>
  <text x="572" y="430" fill="rgb(255 255 255)">.mfields.includes(key[1]))) { throw new </text>
  <text x="612" y="430" fill="rgb(237 28 36)">Ins</text>
  <text x="615" y="430" fill="rgb(255 255 255)">ightError(); } } else i</text>
  <text x="638" y="430" fill="rgb(237 28 36)">f (this.mstoken.includes(applytok</text>
  <text x="671" y="430" fill="rgb(255 255 255)">en)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public valida</text>
  <text x="0" y="431" fill="rgb(255 255 255)">teOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw ne</text>
  <text x="136" y="431" fill="rgb(237 28 36)">w InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validat</text>
  <text x="254" y="431" fill="rgb(255 255 255)">eColumns(q: any): void { if (!q </text>
  <text x="286" y="431" fill="rgb(24 158 180)">|| q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateK</text>
  <text x="495" y="431" fill="rgb(255 255 255)">ey(mskey); } this.ke</text>
  <text x="515" y="431" fill="rgb(24 158 180)">ysInQuery.push(mskey); } } private validateOrder(q: any):</text>
  <text x="572" y="431" fill="rgb(255 255 255)"> void { if (Array.isArray(q)) { throw n</text>
  <text x="611" y="431" fill="rgb(237 28 36)">ew I</text>
  <text x="615" y="431" fill="rgb(255 255 255)">nsightError(); } else i</text>
  <text x="638" y="431" fill="rgb(237 28 36)">f (typeof q === &amp;quot;string&amp;quot;) { if (</text>
  <text x="670" y="431" fill="rgb(255 255 255)">!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir</text>
  <text x="0" y="432" fill="rgb(255 255 255)"> !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw</text>
  <text x="137" y="432" fill="rgb(237 28 36)"> new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError();</text>
  <text x="254" y="432" fill="rgb(255 255 255)"> } } } } public validateWhere(q: </text>
  <text x="287" y="432" fill="rgb(24 158 180)">any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1</text>
  <text x="494" y="432" fill="rgb(255 255 255)">) { throw new Insight</text>
  <text x="515" y="432" fill="rgb(24 158 180)">Error(); } else { let key: string = Object.keys(q)[0]; l</text>
  <text x="571" y="432" fill="rgb(255 255 255)">et value: any = Object.values(q)[0]; swi</text>
  <text x="611" y="432" fill="rgb(237 28 36)">tch </text>
  <text x="615" y="432" fill="rgb(255 255 255)">(key) { case &amp;quot;AND&amp;quot;: cas</text>
  <text x="638" y="432" fill="rgb(237 28 36)">e &amp;quot;OR&amp;quot;: this.validateANDOR(value</text>
  <text x="670" y="432" fill="rgb(255 255 255)">); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break;</text>
  <text x="0" y="433" fill="rgb(255 255 255)"> default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError</text>
  <text x="137" y="433" fill="rgb(237 28 36)">(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new</text>
  <text x="254" y="433" fill="rgb(255 255 255)"> InsightError(); } if (Object.key</text>
  <text x="287" y="433" fill="rgb(24 158 180)">s(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sf</text>
  <text x="493" y="433" fill="rgb(255 255 255)">ield: string = skey[1</text>
  <text x="514" y="433" fill="rgb(24 158 180)">]; let str: any = Object.values(value)[0]; if (typeof str</text>
  <text x="571" y="433" fill="rgb(255 255 255)"> !== &amp;quot;string&amp;quot;) { throw new InsightError</text>
  <text x="610" y="433" fill="rgb(237 28 36)">(); }</text>
  <text x="615" y="433" fill="rgb(255 255 255)"> else { if ((str.slice(</text>
  <text x="638" y="433" fill="rgb(237 28 36)">1, -1).includes(&amp;quot;*&amp;quot;)) || !this.v</text>
  <text x="670" y="433" fill="rgb(255 255 255)">alidateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;o</text>
  <text x="0" y="434" fill="rgb(255 255 255)">bject&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.l</text>
  <text x="138" y="434" fill="rgb(237 28 36)">ength !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let n</text>
  <text x="255" y="434" fill="rgb(255 255 255)">um: any = Object.values(value)[0</text>
  <text x="287" y="434" fill="rgb(24 158 180)">]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value)</text>
  <text x="492" y="434" fill="rgb(255 255 255)"> || value.length &amp;lt; 1)</text>
  <text x="513" y="434" fill="rgb(24 158 180)"> { throw new InsightError(); } for (let innerObject of val</text>
  <text x="571" y="434" fill="rgb(255 255 255)">ue) { this.validateFilter(innerObject)</text>
  <text x="609" y="434" fill="rgb(237 28 36)">; } } </text>
  <text x="615" y="434" fill="rgb(255 255 255)">private validateIdstrin</text>
  <text x="638" y="434" fill="rgb(237 28 36)">g(idstring: string): boolean { </text>
  <text x="669" y="434" fill="rgb(255 255 255)">if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (ins</text>
  <text x="0" y="435" fill="rgb(255 255 255)">ightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfi</text>
  <text x="138" y="435" fill="rgb(237 28 36)">elds = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQ</text>
  <text x="255" y="435" fill="rgb(255 255 255)">uery.includes(idstring); } } publ</text>
  <text x="288" y="435" fill="rgb(24 158 180)">ic getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemf</text>
  <text x="491" y="435" fill="rgb(255 255 255)">ields: string[] = [&amp;quot;a</text>
  <text x="512" y="435" fill="rgb(24 158 180)">vg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly co</text>
  <text x="570" y="435" fill="rgb(255 255 255)">ursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, </text>
  <text x="609" y="435" fill="rgb(237 28 36)">&amp;quot;instr</text>
  <text x="615" y="435" fill="rgb(255 255 255)">uctor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;</text>
  <text x="638" y="435" fill="rgb(237 28 36)">]; private readonly roommfields</text>
  <text x="669" y="435" fill="rgb(255 255 255)">: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;];</text>
  <text x="0" y="436" fill="rgb(255 255 255)"> private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: strin</text>
  <text x="139" y="436" fill="rgb(237 28 36)">g[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after bei</text>
  <text x="255" y="436" fill="rgb(255 255 255)">ng validated private transformati</text>
  <text x="288" y="436" fill="rgb(24 158 180)">onKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDa</text>
  <text x="490" y="436" fill="rgb(255 255 255)">tasets: InsightDatase</text>
  <text x="511" y="436" fill="rgb(24 158 180)">t[]) { this.idInQuery = []; this.keysInQuery = []; this.tra</text>
  <text x="570" y="436" fill="rgb(255 255 255)">nsformationKey = []; this.allInsightDa</text>
  <text x="608" y="436" fill="rgb(237 28 36)">taset =</text>
  <text x="615" y="436" fill="rgb(255 255 255)"> insightDatasets; } pub</text>
  <text x="638" y="436" fill="rgb(237 28 36)">lic validate(q: any): void { if</text>
  <text x="669" y="436" fill="rgb(255 255 255)"> (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS</text>
  <text x="0" y="437" fill="rgb(255 255 255)">&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); }</text>
  <text x="139" y="437" fill="rgb(237 28 36)"> this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined</text>
  <text x="255" y="437" fill="rgb(255 255 255)">&amp;quot; || typeof q.APPLY === &amp;quot;undefine</text>
  <text x="288" y="437" fill="rgb(24 158 180)">d&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1</text>
  <text x="488" y="437" fill="rgb(255 255 255)">) { throw new InsightEr</text>
  <text x="511" y="437" fill="rgb(24 158 180)">ror(); // q should be an object, and should has at least on</text>
  <text x="570" y="437" fill="rgb(255 255 255)">e element } for (let key of q) { this</text>
  <text x="607" y="437" fill="rgb(237 28 36)">.validat</text>
  <text x="615" y="437" fill="rgb(255 255 255)">eKey(key); this.transf</text>
  <text x="637" y="437" fill="rgb(237 28 36)">ormationKey.push(key); // if th</text>
  <text x="668" y="437" fill="rgb(255 255 255)">e key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) {</text>
  <text x="0" y="438" fill="rgb(255 255 255)"> throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(</text>
  <text x="140" y="438" fill="rgb(237 28 36)">splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { th</text>
  <text x="256" y="438" fill="rgb(255 255 255)">row new InsightError(); // q shou</text>
  <text x="289" y="438" fill="rgb(24 158 180)">ld be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: strin</text>
  <text x="487" y="438" fill="rgb(255 255 255)">g = Object.keys(applyru</text>
  <text x="510" y="438" fill="rgb(24 158 180)">le)[0]; let criteria = applyrule[applykey]; if (applykey.le</text>
  <text x="569" y="438" fill="rgb(255 255 255)">ngth === 0 || applykey.includes(&amp;quot;_&amp;quot;) |</text>
  <text x="607" y="438" fill="rgb(237 28 36)">| this.t</text>
  <text x="615" y="438" fill="rgb(255 255 255)">ransformationKey.inclu</text>
  <text x="637" y="438" fill="rgb(237 28 36)">des(applykey)) { throw new Insi</text>
  <text x="668" y="438" fill="rgb(255 255 255)">ghtError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: s</text>
  <text x="0" y="439" fill="rgb(255 255 255)">tring = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); }</text>
  <text x="140" y="439" fill="rgb(237 28 36)"> let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.m</text>
  <text x="256" y="439" fill="rgb(255 255 255)">token.includes(applytoken)) { if </text>
  <text x="289" y="439" fill="rgb(24 158 180)">(!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfield</text>
  <text x="486" y="439" fill="rgb(255 255 255)">s.includes(key[1]) || t</text>
  <text x="509" y="439" fill="rgb(24 158 180)">his.mfields.includes(key[1])))) { throw new InsightError(); </text>
  <text x="569" y="439" fill="rgb(255 255 255)">} } } } public validateOptions(q: any</text>
  <text x="606" y="439" fill="rgb(237 28 36)">): void {</text>
  <text x="615" y="439" fill="rgb(255 255 255)"> let keys: any[] = Obj</text>
  <text x="637" y="439" fill="rgb(237 28 36)">ect.keys(q); for (let key of ke</text>
  <text x="668" y="439" fill="rgb(255 255 255)">ys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } priv</text>
  <text x="0" y="440" fill="rgb(255 255 255)">ate validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.l</text>
  <text x="141" y="440" fill="rgb(237 28 36)">ength &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(m</text>
  <text x="256" y="440" fill="rgb(255 255 255)">skey); } this.keysInQuery.push(ms</text>
  <text x="289" y="440" fill="rgb(24 158 180)">key); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError();</text>
  <text x="485" y="440" fill="rgb(255 255 255)"> } } else { if (!q.dir </text>
  <text x="508" y="440" fill="rgb(24 158 180)">|| !q.keys || Object.keys(q).length !== 2) { throw new Insigh</text>
  <text x="569" y="440" fill="rgb(255 255 255)">tError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.d</text>
  <text x="606" y="440" fill="rgb(237 28 36)">ir !== &amp;quot;D</text>
  <text x="615" y="440" fill="rgb(255 255 255)">OWN&amp;quot;) { throw new Insi</text>
  <text x="637" y="440" fill="rgb(237 28 36)">ghtError(); } let keys: any = </text>
  <text x="667" y="440" fill="rgb(255 255 255)">q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new Insi</text>
  <text x="0" y="441" fill="rgb(255 255 255)">ghtError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length</text>
  <text x="141" y="441" fill="rgb(237 28 36)"> !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { th</text>
  <text x="257" y="441" fill="rgb(255 255 255)">row new InsightError(); } else { </text>
  <text x="290" y="441" fill="rgb(24 158 180)">let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; ca</text>
  <text x="483" y="441" fill="rgb(255 255 255)">se &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case</text>
  <text x="507" y="441" fill="rgb(24 158 180)"> &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.val</text>
  <text x="568" y="441" fill="rgb(255 255 255)">idateIS(value); break; default: throw</text>
  <text x="605" y="441" fill="rgb(237 28 36)"> new Insig</text>
  <text x="615" y="441" fill="rgb(255 255 255)">htError(); } } } priva</text>
  <text x="637" y="441" fill="rgb(237 28 36)">te validateNOT(value: any): vo</text>
  <text x="667" y="441" fill="rgb(255 255 255)">id { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) </text>
  <text x="0" y="442" fill="rgb(255 255 255)">{ throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].sp</text>
  <text x="142" y="442" fill="rgb(237 28 36)">lit(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: s</text>
  <text x="257" y="442" fill="rgb(255 255 255)">tring = skey[1]; let str: any = O</text>
  <text x="290" y="442" fill="rgb(24 158 180)">bject.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfi</text>
  <text x="482" y="442" fill="rgb(255 255 255)">eld)) { throw new Insigh</text>
  <text x="506" y="442" fill="rgb(24 158 180)">tError(); } } } } private validateGTLTEQ(value: any): void { i</text>
  <text x="568" y="442" fill="rgb(255 255 255)">f (typeof value !== &amp;quot;object&amp;quot; || Obje</text>
  <text x="604" y="442" fill="rgb(237 28 36)">ct.keys(val</text>
  <text x="615" y="442" fill="rgb(255 255 255)">ue).length !== 1) { th</text>
  <text x="637" y="442" fill="rgb(237 28 36)">row new InsightError(); } let</text>
  <text x="666" y="442" fill="rgb(255 255 255)"> mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mk</text>
  <text x="0" y="443" fill="rgb(255 255 255)">ey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfi</text>
  <text x="142" y="443" fill="rgb(237 28 36)">eld)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || valu</text>
  <text x="257" y="443" fill="rgb(255 255 255)">e.length &amp;lt; 1) { throw new Insight</text>
  <text x="290" y="443" fill="rgb(24 158 180)">Error(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDat</text>
  <text x="480" y="443" fill="rgb(255 255 255)">aset of this.allInsightDa</text>
  <text x="505" y="443" fill="rgb(24 158 180)">taset) { if (insightDataset.id === idstring) { this.idInQuery.p</text>
  <text x="568" y="443" fill="rgb(255 255 255)">ush(idstring); if (insightDataset.ki</text>
  <text x="604" y="443" fill="rgb(237 28 36)">nd === Ins</text>
  <text x="614" y="443" fill="rgb(255 255 255)">ightDatasetKind.Courses</text>
  <text x="637" y="443" fill="rgb(237 28 36)">) { this.mfields = this.cours</text>
  <text x="666" y="443" fill="rgb(255 255 255)">emfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { retur</text>
  <text x="0" y="444" fill="rgb(255 255 255)">n this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKin</text>
  <text x="143" y="444" fill="rgb(237 28 36)">d, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: str</text>
  <text x="258" y="444" fill="rgb(255 255 255)">ing[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;</text>
  <text x="291" y="444" fill="rgb(24 158 180)">audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonl</text>
  <text x="479" y="444" fill="rgb(255 255 255)">y roomsfields: string[] =</text>
  <text x="504" y="444" fill="rgb(24 158 180)"> [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;</text>
  <text x="567" y="444" fill="rgb(255 255 255)">, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private read</text>
  <text x="603" y="444" fill="rgb(237 28 36)">only mtoken</text>
  <text x="614" y="444" fill="rgb(255 255 255)">: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;M</text>
  <text x="637" y="444" fill="rgb(237 28 36)">IN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private r</text>
  <text x="666" y="444" fill="rgb(255 255 255)">eadonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in colum</text>
  <text x="0" y="445" fill="rgb(255 255 255)">ns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsigh</text>
  <text x="144" y="445" fill="rgb(237 28 36)">tDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: Ins</text>
  <text x="258" y="445" fill="rgb(255 255 255)">ightDataset[]) { this.idInQuery =</text>
  <text x="291" y="445" fill="rgb(24 158 180)"> []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new Insight</text>
  <text x="477" y="445" fill="rgb(255 255 255)">Error(); } for (let key of</text>
  <text x="503" y="445" fill="rgb(24 158 180)"> Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; k</text>
  <text x="567" y="445" fill="rgb(255 255 255)">ey !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw n</text>
  <text x="602" y="445" fill="rgb(237 28 36)">ew InsightEr</text>
  <text x="614" y="445" fill="rgb(255 255 255)">ror(); } } this.validat</text>
  <text x="637" y="445" fill="rgb(237 28 36)">eWhere(q.WHERE); if (q.TRANS</text>
  <text x="665" y="445" fill="rgb(255 255 255)">FORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP ==</text>
  <text x="0" y="446" fill="rgb(255 255 255)">= &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.</text>
  <text x="144" y="446" fill="rgb(237 28 36)">validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new</text>
  <text x="258" y="446" fill="rgb(255 255 255)"> InsightError(); // q should be a</text>
  <text x="291" y="446" fill="rgb(24 158 180)">n object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } p</text>
  <text x="475" y="446" fill="rgb(255 255 255)">rivate validateKey(key: str</text>
  <text x="502" y="446" fill="rgb(24 158 180)">ing): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (spl</text>
  <text x="566" y="446" fill="rgb(255 255 255)">ittedKey.length !== 2) { throw new I</text>
  <text x="602" y="446" fill="rgb(237 28 36)">nsightError(</text>
  <text x="614" y="446" fill="rgb(255 255 255)">); } if (!(this.valida</text>
  <text x="636" y="446" fill="rgb(237 28 36)">teIdstring(splittedKey[0]) &amp;amp;&amp;amp;</text>
  <text x="665" y="446" fill="rgb(255 255 255)"> (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isA</text>
  <text x="0" y="447" fill="rgb(255 255 255)">rray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray</text>
  <text x="145" y="447" fill="rgb(237 28 36)">(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys</text>
  <text x="259" y="447" fill="rgb(255 255 255)">(applyrule)[0]; let criteria = ap</text>
  <text x="292" y="447" fill="rgb(24 158 180)">plyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applyk</text>
  <text x="473" y="447" fill="rgb(255 255 255)">ey); if (Array.isArray(crite</text>
  <text x="501" y="447" fill="rgb(24 158 180)">ria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightErro</text>
  <text x="566" y="447" fill="rgb(255 255 255)">r(); } let applytoken: string = Obj</text>
  <text x="601" y="447" fill="rgb(237 28 36)">ect.keys(crit</text>
  <text x="614" y="447" fill="rgb(255 255 255)">eria)[0]; if (!this.mt</text>
  <text x="636" y="447" fill="rgb(237 28 36)">oken.includes(applytoken) &amp;amp;&amp;amp; </text>
  <text x="665" y="447" fill="rgb(255 255 255)">!this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError();</text>
  <text x="0" y="448" fill="rgb(255 255 255)"> } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } }</text>
  <text x="145" y="448" fill="rgb(237 28 36)"> else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1</text>
  <text x="259" y="448" fill="rgb(255 255 255)">]) || this.mfields.includes(key[1</text>
  <text x="292" y="448" fill="rgb(24 158 180)">])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;</text>
  <text x="471" y="448" fill="rgb(255 255 255)">) { throw new InsightError();</text>
  <text x="500" y="448" fill="rgb(24 158 180)"> } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validate</text>
  <text x="566" y="448" fill="rgb(255 255 255)">Order(q.ORDER); } } private valida</text>
  <text x="600" y="448" fill="rgb(237 28 36)">teColumns(q: a</text>
  <text x="614" y="448" fill="rgb(255 255 255)">ny): void { if (!q || </text>
  <text x="636" y="448" fill="rgb(237 28 36)">q.length &amp;lt; 1) { throw new In</text>
  <text x="664" y="448" fill="rgb(255 255 255)">sightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.</text>
  <text x="0" y="449" fill="rgb(255 255 255)">validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } </text>
  <text x="146" y="449" fill="rgb(237 28 36)">else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!</text>
  <text x="259" y="449" fill="rgb(255 255 255)">q.dir || !q.keys || Object.keys(q)</text>
  <text x="293" y="449" fill="rgb(24 158 180)">.length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.leng</text>
  <text x="469" y="449" fill="rgb(255 255 255)">th &amp;lt; 1) { throw new InsightErr</text>
  <text x="499" y="449" fill="rgb(24 158 180)">or(); } for (let anykey of keys) { if (!this.keysInQuery.includes(</text>
  <text x="565" y="449" fill="rgb(255 255 255)">anykey)) { throw new InsightError()</text>
  <text x="600" y="449" fill="rgb(237 28 36)">; } } } } publ</text>
  <text x="614" y="449" fill="rgb(255 255 255)">ic validateWhere(q: an</text>
  <text x="636" y="449" fill="rgb(237 28 36)">y): void { if (Array.isArray</text>
  <text x="664" y="449" fill="rgb(255 255 255)">(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).leng</text>
  <text x="0" y="450" fill="rgb(255 255 255)">th !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND</text>
  <text x="146" y="450" fill="rgb(237 28 36)">&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: </text>
  <text x="260" y="450" fill="rgb(255 255 255)">case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(va</text>
  <text x="293" y="450" fill="rgb(24 158 180)">lue); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw</text>
  <text x="467" y="450" fill="rgb(255 255 255)"> new InsightError(); } this.va</text>
  <text x="497" y="450" fill="rgb(24 158 180)">lidateFilter(value); } private validateIS(value: any): void { if (ty</text>
  <text x="565" y="450" fill="rgb(255 255 255)">peof value !== &amp;quot;object&amp;quot;) { throw n</text>
  <text x="599" y="450" fill="rgb(237 28 36)">ew InsightError</text>
  <text x="614" y="450" fill="rgb(255 255 255)">(); } if (Object.keys(</text>
  <text x="636" y="450" fill="rgb(237 28 36)">value).length !== 1) { thro</text>
  <text x="663" y="450" fill="rgb(255 255 255)">w new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0];</text>
  <text x="0" y="451" fill="rgb(255 255 255)"> let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.s</text>
  <text x="147" y="451" fill="rgb(237 28 36)">lice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new Ins</text>
  <text x="260" y="451" fill="rgb(255 255 255)">ightError(); } } } } private valid</text>
  <text x="294" y="451" fill="rgb(24 158 180)">ateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].sp</text>
  <text x="465" y="451" fill="rgb(255 255 255)">lit(&amp;quot;_&amp;quot;); if (mkey.length !== 2</text>
  <text x="496" y="451" fill="rgb(24 158 180)">) { throw new InsightError(); } else { let idstring: string = mkey[0</text>
  <text x="564" y="451" fill="rgb(255 255 255)">]; let mfield: string = mkey[1]; l</text>
  <text x="598" y="451" fill="rgb(237 28 36)">et num: any = Ob</text>
  <text x="614" y="451" fill="rgb(255 255 255)">ject.values(value)[0];</text>
  <text x="636" y="451" fill="rgb(237 28 36)"> if ((typeof num !== &amp;quot;numbe</text>
  <text x="663" y="451" fill="rgb(255 255 255)">r&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(</text>
  <text x="0" y="452" fill="rgb(255 255 255)">value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIds</text>
  <text x="148" y="452" fill="rgb(237 28 36)">tring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsight</text>
  <text x="260" y="452" fill="rgb(255 255 255)">Dataset) { if (insightDataset.id =</text>
  <text x="294" y="452" fill="rgb(24 158 180)">== idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfi</text>
  <text x="462" y="452" fill="rgb(255 255 255)">elds; } else { this.mfields = thi</text>
  <text x="495" y="452" fill="rgb(24 158 180)">s.roommfields; this.sfields = this.roomsfields; } return true; } } re</text>
  <text x="564" y="452" fill="rgb(255 255 255)">turn false; } else { return this.</text>
  <text x="597" y="452" fill="rgb(237 28 36)">idInQuery.include</text>
  <text x="614" y="452" fill="rgb(255 255 255)">s(idstring); } } publi</text>
  <text x="636" y="452" fill="rgb(237 28 36)">c getIdInQuery(): string[] </text>
  <text x="663" y="452" fill="rgb(255 255 255)">{ return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly cou</text>
  <text x="0" y="453" fill="rgb(255 255 255)">rsemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;u</text>
  <text x="148" y="453" fill="rgb(237 28 36)">uid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] =</text>
  <text x="261" y="453" fill="rgb(255 255 255)"> [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number</text>
  <text x="295" y="453" fill="rgb(24 158 180)">&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]</text>
  <text x="460" y="453" fill="rgb(255 255 255)">; private idInQuery: string[]; // </text>
  <text x="494" y="453" fill="rgb(24 158 180)">make sure the query only has one id private keysInQuery: string[]; //</text>
  <text x="563" y="453" fill="rgb(255 255 255)"> all keys appeared in columns afte</text>
  <text x="597" y="453" fill="rgb(237 28 36)">r being validated</text>
  <text x="614" y="453" fill="rgb(255 255 255)"> private transformati</text>
  <text x="635" y="453" fill="rgb(237 28 36)">onKey: string[]; // keys ap</text>
  <text x="662" y="453" fill="rgb(255 255 255)">peared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insig</text>
  <text x="0" y="454" fill="rgb(255 255 255)">htDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } </text>
  <text x="149" y="454" fill="rgb(237 28 36)">public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of </text>
  <text x="261" y="454" fill="rgb(255 255 255)">Object.keys(q)) { if (key !== &amp;quot;OPT</text>
  <text x="295" y="454" fill="rgb(24 158 180)">IONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransfor</text>
  <text x="457" y="454" fill="rgb(255 255 255)">mations(q.TRANSFORMATIONS); } this.v</text>
  <text x="493" y="454" fill="rgb(24 158 180)">alidateOptions(q.OPTIONS); } public validateTransformations(q: any): v</text>
  <text x="563" y="454" fill="rgb(255 255 255)">oid { if (typeof q.GROUP === &amp;quot;und</text>
  <text x="596" y="454" fill="rgb(237 28 36)">efined&amp;quot; || typeof</text>
  <text x="613" y="454" fill="rgb(255 255 255)"> q.APPLY === &amp;quot;undefine</text>
  <text x="635" y="454" fill="rgb(237 28 36)">d&amp;quot; || Object.keys(q).length</text>
  <text x="662" y="454" fill="rgb(255 255 255)"> !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt;</text>
  <text x="0" y="455" fill="rgb(255 255 255)"> 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.tran</text>
  <text x="149" y="455" fill="rgb(237 28 36)">sformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: strin</text>
  <text x="261" y="455" fill="rgb(255 255 255)">g): void { let splittedKey: string</text>
  <text x="295" y="455" fill="rgb(24 158 180)">[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splitted</text>
  <text x="454" y="455" fill="rgb(255 255 255)">Key[1]) || this.sfields.includes(spli</text>
  <text x="491" y="455" fill="rgb(24 158 180)">ttedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q:</text>
  <text x="562" y="455" fill="rgb(255 255 255)"> any): void { if (!Array.isArray(</text>
  <text x="595" y="455" fill="rgb(237 28 36)">q)) { throw new In</text>
  <text x="613" y="455" fill="rgb(255 255 255)">sightError(); // q sho</text>
  <text x="635" y="455" fill="rgb(237 28 36)">uld be an array, and shoul</text>
  <text x="661" y="455" fill="rgb(255 255 255)">d have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: stri</text>
  <text x="0" y="456" fill="rgb(255 255 255)">ng = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.incl</text>
  <text x="150" y="456" fill="rgb(237 28 36)">udes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria)</text>
  <text x="262" y="456" fill="rgb(255 255 255)"> || Object.keys(criteria).length &amp;gt;</text>
  <text x="296" y="456" fill="rgb(24 158 180)"> 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applyt</text>
  <text x="451" y="456" fill="rgb(255 255 255)">oken)) { throw new InsightError(); } le</text>
  <text x="490" y="456" fill="rgb(24 158 180)">t key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2)</text>
  <text x="562" y="456" fill="rgb(255 255 255)"> { throw new InsightError(); } if</text>
  <text x="595" y="456" fill="rgb(237 28 36)"> (this.mtoken.incl</text>
  <text x="613" y="456" fill="rgb(255 255 255)">udes(applytoken)) { if</text>
  <text x="635" y="456" fill="rgb(237 28 36)"> (!(this.validateIdstring(</text>
  <text x="661" y="456" fill="rgb(255 255 255)">key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfield</text>
  <text x="0" y="457" fill="rgb(255 255 255)">s.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Obj</text>
  <text x="151" y="457" fill="rgb(237 28 36)">ect.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } </text>
  <text x="262" y="457" fill="rgb(255 255 255)">this.validateColumns(q.COLUMNS); i</text>
  <text x="296" y="457" fill="rgb(24 158 180)">f (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let m</text>
  <text x="447" y="457" fill="rgb(255 255 255)">skey of q) { if (this.transformationKey.le</text>
  <text x="489" y="457" fill="rgb(24 158 180)">ngth &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new Insi</text>
  <text x="562" y="457" fill="rgb(255 255 255)">ghtError(); } } else { this.vali</text>
  <text x="594" y="457" fill="rgb(237 28 36)">dateKey(mskey); } t</text>
  <text x="613" y="457" fill="rgb(255 255 255)">his.keysInQuery.push(m</text>
  <text x="635" y="457" fill="rgb(237 28 36)">skey); } } private validat</text>
  <text x="661" y="457" fill="rgb(255 255 255)">eOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); </text>
  <text x="0" y="458" fill="rgb(255 255 255)">} } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new Insi</text>
  <text x="151" y="458" fill="rgb(237 28 36)">ghtError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); </text>
  <text x="262" y="458" fill="rgb(255 255 255)">} for (let anykey of keys) { if (!t</text>
  <text x="297" y="458" fill="rgb(24 158 180)">his.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new Insig</text>
  <text x="443" y="458" fill="rgb(255 255 255)">htError(); } else { if (Object.keys(q).lengt</text>
  <text x="487" y="458" fill="rgb(24 158 180)">h !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): v</text>
  <text x="561" y="458" fill="rgb(255 255 255)">oid { if (Object.keys(q).length </text>
  <text x="593" y="458" fill="rgb(237 28 36)">!== 1) { throw new I</text>
  <text x="613" y="458" fill="rgb(255 255 255)">nsightError(); } else </text>
  <text x="635" y="458" fill="rgb(237 28 36)">{ let key: string = Objec</text>
  <text x="660" y="458" fill="rgb(255 255 255)">t.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case </text>
  <text x="0" y="459" fill="rgb(255 255 255)">&amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } privat</text>
  <text x="152" y="459" fill="rgb(237 28 36)">e validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFil</text>
  <text x="263" y="459" fill="rgb(255 255 255)">ter(value); } private validateIS(v</text>
  <text x="297" y="459" fill="rgb(24 158 180)">alue: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError()</text>
  <text x="440" y="459" fill="rgb(255 255 255)">; } let skey: string[] = Object.keys(value)[0]</text>
  <text x="486" y="459" fill="rgb(24 158 180)">.split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { l</text>
  <text x="560" y="459" fill="rgb(255 255 255)">et idstring: string = skey[0]; le</text>
  <text x="593" y="459" fill="rgb(237 28 36)">t sfield: string = s</text>
  <text x="613" y="459" fill="rgb(255 255 255)">key[1]; let str: any =</text>
  <text x="635" y="459" fill="rgb(237 28 36)"> Object.values(value)[0];</text>
  <text x="660" y="459" fill="rgb(255 255 255)"> if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)</text>
  <text x="0" y="460" fill="rgb(255 255 255)">) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { thro</text>
  <text x="153" y="460" fill="rgb(237 28 36)">w new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw </text>
  <text x="263" y="460" fill="rgb(255 255 255)">new InsightError(); } else { let id</text>
  <text x="298" y="460" fill="rgb(24 158 180)">string: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.val</text>
  <text x="436" y="460" fill="rgb(255 255 255)">idateIdstring(idstring) || !this.mfields.include</text>
  <text x="484" y="460" fill="rgb(24 158 180)">s(mfield)) { throw new InsightError(); } } } private validateANDOR(value: an</text>
  <text x="560" y="460" fill="rgb(255 255 255)">y): void { if (!Array.isArray(va</text>
  <text x="592" y="460" fill="rgb(237 28 36)">lue) || value.length </text>
  <text x="613" y="460" fill="rgb(255 255 255)">&amp;lt; 1) { throw new Insig</text>
  <text x="635" y="460" fill="rgb(237 28 36)">htError(); } for (let in</text>
  <text x="659" y="460" fill="rgb(255 255 255)">nerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset o</text>
  <text x="0" y="461" fill="rgb(255 255 255)">f this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) </text>
  <text x="153" y="461" fill="rgb(237 28 36)">{ this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfiel</text>
  <text x="263" y="461" fill="rgb(255 255 255)">ds; this.sfields = this.roomsfields</text>
  <text x="298" y="461" fill="rgb(24 158 180)">; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this</text>
  <text x="433" y="461" fill="rgb(255 255 255)">.idInQuery; } } import {InsightDataset, InsightDat</text>
  <text x="483" y="461" fill="rgb(24 158 180)">asetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryV</text>
  <text x="559" y="461" fill="rgb(255 255 255)">alidator { private readonly cour</text>
  <text x="591" y="461" fill="rgb(237 28 36)">semfields: string[] = </text>
  <text x="613" y="461" fill="rgb(255 255 255)">[&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail</text>
  <text x="634" y="461" fill="rgb(237 28 36)">&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; priv</text>
  <text x="659" y="461" fill="rgb(255 255 255)">ate readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly rooms</text>
  <text x="0" y="462" fill="rgb(255 255 255)">fields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;</text>
  <text x="154" y="462" fill="rgb(237 28 36)">, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the</text>
  <text x="264" y="462" fill="rgb(255 255 255)"> query only has one id private keys</text>
  <text x="299" y="462" fill="rgb(24 158 180)">InQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in t</text>
  <text x="430" y="462" fill="rgb(255 255 255)">ransformation, if there is a transformation private</text>
  <text x="481" y="462" fill="rgb(24 158 180)"> allInsightDataset: InsightDataset[]; private mfields: string[]; private sfiel</text>
  <text x="559" y="462" fill="rgb(255 255 255)">ds: string[]; constructor(insig</text>
  <text x="590" y="462" fill="rgb(237 28 36)">htDatasets: InsightDat</text>
  <text x="612" y="462" fill="rgb(255 255 255)">aset[]) { this.idInQue</text>
  <text x="634" y="462" fill="rgb(237 28 36)">ry = []; this.keysInQuery</text>
  <text x="659" y="462" fill="rgb(255 255 255)"> = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); </text>
  <text x="0" y="463" fill="rgb(255 255 255)">} for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWh</text>
  <text x="154" y="463" fill="rgb(237 28 36)">ere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions</text>
  <text x="264" y="463" fill="rgb(255 255 255)">(q.OPTIONS); } public validateTransf</text>
  <text x="300" y="463" fill="rgb(24 158 180)">ormations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) </text>
  <text x="427" y="463" fill="rgb(255 255 255)">{ throw new InsightError(); } this.validateGROUP(q.G</text>
  <text x="479" y="463" fill="rgb(24 158 180)">ROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if </text>
  <text x="558" y="463" fill="rgb(255 255 255)">(!Array.isArray(q) || q.length &amp;lt;</text>
  <text x="590" y="463" fill="rgb(237 28 36)"> 1) { throw new Insigh</text>
  <text x="612" y="463" fill="rgb(255 255 255)">tError(); // q should </text>
  <text x="634" y="463" fill="rgb(237 28 36)">be an object, and should</text>
  <text x="658" y="463" fill="rgb(255 255 255)"> has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private vali</text>
  <text x="0" y="464" fill="rgb(255 255 255)">dateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIds</text>
  <text x="155" y="464" fill="rgb(237 28 36)">tring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { </text>
  <text x="265" y="464" fill="rgb(255 255 255)">throw new InsightError(); } } priva</text>
  <text x="300" y="464" fill="rgb(24 158 180)">te validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have</text>
  <text x="424" y="464" fill="rgb(255 255 255)"> at least one element } for (let applyrule of q) { if </text>
  <text x="478" y="464" fill="rgb(24 158 180)">(Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new Insi</text>
  <text x="558" y="464" fill="rgb(255 255 255)">ghtError(); } let applykey: str</text>
  <text x="589" y="464" fill="rgb(237 28 36)">ing = Object.keys(apply</text>
  <text x="612" y="464" fill="rgb(255 255 255)">rule)[0]; let criteria</text>
  <text x="634" y="464" fill="rgb(237 28 36)"> = applyrule[applykey]; </text>
  <text x="658" y="464" fill="rgb(255 255 255)">if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Arra</text>
  <text x="0" y="465" fill="rgb(255 255 255)">y.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.i</text>
  <text x="156" y="465" fill="rgb(237 28 36)">ncludes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = </text>
  <text x="265" y="465" fill="rgb(255 255 255)">criteria[applytoken].split(&amp;quot;_&amp;quot;); if </text>
  <text x="301" y="465" fill="rgb(24 158 180)">(key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key</text>
  <text x="421" y="465" fill="rgb(255 255 255)">[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new Ins</text>
  <text x="476" y="465" fill="rgb(24 158 180)">ightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validat</text>
  <text x="557" y="465" fill="rgb(255 255 255)">eIdstring(key[0]) &amp;amp;&amp;amp; (this.sfie</text>
  <text x="588" y="465" fill="rgb(237 28 36)">lds.includes(key[1]) || </text>
  <text x="612" y="465" fill="rgb(255 255 255)">this.mfields.includes(</text>
  <text x="634" y="465" fill="rgb(237 28 36)">key[1])))) { throw new </text>
  <text x="657" y="465" fill="rgb(255 255 255)">InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new I</text>
  <text x="0" y="466" fill="rgb(255 255 255)">nsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.leng</text>
  <text x="156" y="466" fill="rgb(237 28 36)">th &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!th</text>
  <text x="265" y="466" fill="rgb(255 255 255)">is.transformationKey.includes(mskey)</text>
  <text x="301" y="466" fill="rgb(24 158 180)">) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validat</text>
  <text x="418" y="466" fill="rgb(255 255 255)">eOrder(q: any): void { if (Array.isArray(q)) { throw new</text>
  <text x="474" y="466" fill="rgb(24 158 180)"> InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes</text>
  <text x="557" y="466" fill="rgb(255 255 255)">(q)) { throw new InsightError(</text>
  <text x="587" y="466" fill="rgb(237 28 36)">); } } else { if (!q.dir </text>
  <text x="612" y="466" fill="rgb(255 255 255)">|| !q.keys || Object.k</text>
  <text x="634" y="466" fill="rgb(237 28 36)">eys(q).length !== 2) { </text>
  <text x="657" y="466" fill="rgb(255 255 255)">throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw n</text>
  <text x="0" y="467" fill="rgb(255 255 255)">ew InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): voi</text>
  <text x="157" y="467" fill="rgb(237 28 36)">d { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.valida</text>
  <text x="266" y="467" fill="rgb(255 255 255)">teFilter(q); } } } private validateF</text>
  <text x="302" y="467" fill="rgb(24 158 180)">ilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Obj</text>
  <text x="415" y="467" fill="rgb(255 255 255)">ect.keys(q)[0]; let value: any = Object.values(q)[0]; swi</text>
  <text x="472" y="467" fill="rgb(24 158 180)">tch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: thi</text>
  <text x="556" y="467" fill="rgb(255 255 255)">s.validateNOT(value); break; ca</text>
  <text x="587" y="467" fill="rgb(237 28 36)">se &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case </text>
  <text x="612" y="467" fill="rgb(255 255 255)">&amp;quot;EQ&amp;quot;: this.validateGTL</text>
  <text x="634" y="467" fill="rgb(237 28 36)">TEQ(value); break; cas</text>
  <text x="656" y="467" fill="rgb(255 255 255)">e &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError()</text>
  <text x="0" y="468" fill="rgb(255 255 255)">; } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).l</text>
  <text x="158" y="468" fill="rgb(237 28 36)">ength !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.l</text>
  <text x="266" y="468" fill="rgb(255 255 255)">ength !== 2) { throw new InsightError</text>
  <text x="303" y="468" fill="rgb(24 158 180)">(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)</text>
  <text x="413" y="468" fill="rgb(255 255 255)">[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightErro</text>
  <text x="470" y="468" fill="rgb(24 158 180)">r(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring</text>
  <text x="555" y="468" fill="rgb(255 255 255)">) || !this.sfields.includes(sfi</text>
  <text x="586" y="468" fill="rgb(237 28 36)">eld)) { throw new InsightE</text>
  <text x="612" y="468" fill="rgb(255 255 255)">rror(); } } } } priva</text>
  <text x="633" y="468" fill="rgb(237 28 36)">te validateGTLTEQ(value</text>
  <text x="656" y="468" fill="rgb(255 255 255)">: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.le</text>
  <text x="0" y="469" fill="rgb(255 255 255)">ngth !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((ty</text>
  <text x="158" y="469" fill="rgb(237 28 36)">peof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new In</text>
  <text x="266" y="469" fill="rgb(255 255 255)">sightError(); } } } private validateA</text>
  <text x="303" y="469" fill="rgb(24 158 180)">NDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (</text>
  <text x="410" y="469" fill="rgb(255 255 255)">let innerObject of value) { this.validateFilter(innerObjec</text>
  <text x="468" y="469" fill="rgb(24 158 180)">t); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length</text>
  <text x="555" y="469" fill="rgb(255 255 255)"> === 0) { for (let insightData</text>
  <text x="585" y="469" fill="rgb(237 28 36)">set of this.allInsightData</text>
  <text x="611" y="469" fill="rgb(255 255 255)">set) { if (insightData</text>
  <text x="633" y="469" fill="rgb(237 28 36)">set.id === idstring) { </text>
  <text x="656" y="469" fill="rgb(255 255 255)">this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfie</text>
  <text x="0" y="470" fill="rgb(255 255 255)">lds = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdIn</text>
  <text x="159" y="470" fill="rgb(237 28 36)">Query(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} fro</text>
  <text x="267" y="470" fill="rgb(255 255 255)">m &amp;quot;./IInsightFacade&amp;quot;; export default </text>
  <text x="304" y="470" fill="rgb(24 158 180)">class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year</text>
  <text x="408" y="470" fill="rgb(255 255 255)">&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;i</text>
  <text x="466" y="470" fill="rgb(24 158 180)">d&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lo</text>
  <text x="554" y="470" fill="rgb(255 255 255)">n&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly</text>
  <text x="584" y="470" fill="rgb(237 28 36)"> roomsfields: string[] = [&amp;quot;</text>
  <text x="611" y="470" fill="rgb(255 255 255)">fullname&amp;quot;, &amp;quot;shortname&amp;quot;</text>
  <text x="633" y="470" fill="rgb(237 28 36)">, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;</text>
  <text x="655" y="470" fill="rgb(255 255 255)">address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: strin</text>
  <text x="0" y="471" fill="rgb(255 255 255)">g[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: stri</text>
  <text x="160" y="471" fill="rgb(237 28 36)">ng[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDa</text>
  <text x="267" y="471" fill="rgb(255 255 255)">taset[]; private mfields: string[]; p</text>
  <text x="304" y="471" fill="rgb(24 158 180)">rivate sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.</text>
  <text x="405" y="471" fill="rgb(255 255 255)">keysInQuery = []; this.transformationKey = []; this.allInsi</text>
  <text x="464" y="471" fill="rgb(24 158 180)">ghtDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.O</text>
  <text x="554" y="471" fill="rgb(255 255 255)">PTIONS) { throw new InsightErr</text>
  <text x="584" y="471" fill="rgb(237 28 36)">or(); } for (let key of Obj</text>
  <text x="611" y="471" fill="rgb(255 255 255)">ect.keys(q)) { if (key</text>
  <text x="633" y="471" fill="rgb(237 28 36)"> !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key </text>
  <text x="655" y="471" fill="rgb(255 255 255)">!== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); }</text>
  <text x="0" y="472" fill="rgb(255 255 255)"> this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object</text>
  <text x="161" y="472" fill="rgb(237 28 36)">.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPL</text>
  <text x="268" y="472" fill="rgb(255 255 255)">Y); } private validateGROUP(q: any): </text>
  <text x="305" y="472" fill="rgb(24 158 180)">void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object</text>
  <text x="403" y="472" fill="rgb(255 255 255)">, and should has at least one element } for (let key of q) </text>
  <text x="462" y="472" fill="rgb(24 158 180)">{ this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it </text>
  <text x="553" y="472" fill="rgb(255 255 255)">to transformationKey } } priva</text>
  <text x="583" y="472" fill="rgb(237 28 36)">te validateKey(key: string):</text>
  <text x="611" y="472" fill="rgb(255 255 255)"> void { let splittedKe</text>
  <text x="633" y="472" fill="rgb(237 28 36)">y: string[] = key.spl</text>
  <text x="654" y="472" fill="rgb(255 255 255)">it(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes</text>
  <text x="0" y="473" fill="rgb(255 255 255)">(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an ar</text>
  <text x="161" y="473" fill="rgb(237 28 36)">ray, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Obje</text>
  <text x="268" y="473" fill="rgb(255 255 255)">ct.keys(applyrule).length &amp;gt; 1) { throw</text>
  <text x="306" y="473" fill="rgb(24 158 180)"> new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyru</text>
  <text x="401" y="473" fill="rgb(255 255 255)">le[applykey]; if (applykey.length === 0 || applykey.include</text>
  <text x="460" y="473" fill="rgb(24 158 180)">s(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.tran</text>
  <text x="552" y="473" fill="rgb(255 255 255)">sformationKey.push(applykey); </text>
  <text x="582" y="473" fill="rgb(237 28 36)">if (Array.isArray(criteria) |</text>
  <text x="611" y="473" fill="rgb(255 255 255)">| Object.keys(criteria</text>
  <text x="633" y="473" fill="rgb(237 28 36)">).length &amp;gt; 1) { throw</text>
  <text x="654" y="473" fill="rgb(255 255 255)"> new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); </text>
  <text x="0" y="474" fill="rgb(255 255 255)">} let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.vali</text>
  <text x="162" y="474" fill="rgb(237 28 36)">dateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.msto</text>
  <text x="268" y="474" fill="rgb(255 255 255)">ken.includes(applytoken)) { if (!(this</text>
  <text x="306" y="474" fill="rgb(24 158 180)">.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1]))</text>
  <text x="399" y="474" fill="rgb(255 255 255)">)) { throw new InsightError(); } } } } public validateOpti</text>
  <text x="457" y="474" fill="rgb(24 158 180)">ons(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLU</text>
  <text x="552" y="474" fill="rgb(255 255 255)">MNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { th</text>
  <text x="581" y="474" fill="rgb(237 28 36)">row new InsightError(); } } th</text>
  <text x="611" y="474" fill="rgb(255 255 255)">is.validateColumns(q.</text>
  <text x="632" y="474" fill="rgb(237 28 36)">COLUMNS); if (q.ORDER</text>
  <text x="653" y="474" fill="rgb(255 255 255)">) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey</text>
  <text x="0" y="475" fill="rgb(255 255 255)">.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } pri</text>
  <text x="163" y="475" fill="rgb(237 28 36)">vate validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q =</text>
  <text x="269" y="475" fill="rgb(255 255 255)">== &amp;quot;string&amp;quot;) { if (!this.keysInQuery.i</text>
  <text x="307" y="475" fill="rgb(24 158 180)">ncludes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q)</text>
  <text x="397" y="475" fill="rgb(255 255 255)">.length !== 2) { throw new InsightError(); } if (q.dir !==</text>
  <text x="455" y="475" fill="rgb(24 158 180)"> &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isAr</text>
  <text x="551" y="475" fill="rgb(255 255 255)">ray(keys) || keys.length &amp;lt; 1)</text>
  <text x="580" y="475" fill="rgb(237 28 36)"> { throw new InsightError(); }</text>
  <text x="610" y="475" fill="rgb(255 255 255)"> for (let anykey of ke</text>
  <text x="632" y="475" fill="rgb(237 28 36)">ys) { if (!this.keysI</text>
  <text x="653" y="475" fill="rgb(255 255 255)">nQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).leng</text>
  <text x="0" y="476" fill="rgb(255 255 255)">th !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: str</text>
  <text x="163" y="476" fill="rgb(237 28 36)">ing = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.</text>
  <text x="269" y="476" fill="rgb(255 255 255)">validateANDOR(value); break; case &amp;quot;NOT&amp;quot;</text>
  <text x="308" y="476" fill="rgb(24 158 180)">: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(</text>
  <text x="395" y="476" fill="rgb(255 255 255)">value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; </text>
  <text x="452" y="476" fill="rgb(24 158 180)">default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value </text>
  <text x="550" y="476" fill="rgb(255 255 255)">!== &amp;quot;object&amp;quot;) { throw new Insi</text>
  <text x="580" y="476" fill="rgb(237 28 36)">ghtError(); } this.validateFil</text>
  <text x="610" y="476" fill="rgb(255 255 255)">ter(value); } private </text>
  <text x="632" y="476" fill="rgb(237 28 36)">validateIS(value: an</text>
  <text x="652" y="476" fill="rgb(255 255 255)">y): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0]</text>
  <text x="0" y="477" fill="rgb(255 255 255)">.split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(</text>
  <text x="164" y="477" fill="rgb(237 28 36)">value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includ</text>
  <text x="269" y="477" fill="rgb(255 255 255)">es(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idst</text>
  <text x="308" y="477" fill="rgb(24 158 180)">ring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private </text>
  <text x="393" y="477" fill="rgb(255 255 255)">validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;</text>
  <text x="450" y="477" fill="rgb(24 158 180)">object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Objec</text>
  <text x="550" y="477" fill="rgb(255 255 255)">t.keys(value)[0].split(&amp;quot;_&amp;quot;); </text>
  <text x="579" y="477" fill="rgb(237 28 36)">if (mkey.length !== 2) { throw </text>
  <text x="610" y="477" fill="rgb(255 255 255)">new InsightError(); } </text>
  <text x="632" y="477" fill="rgb(237 28 36)">else { let idstring:</text>
  <text x="652" y="477" fill="rgb(255 255 255)"> string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(</text>
  <text x="0" y="478" fill="rgb(255 255 255)">mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for</text>
  <text x="165" y="478" fill="rgb(237 28 36)"> (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: st</text>
  <text x="270" y="478" fill="rgb(255 255 255)">ring): boolean { if (this.idInQuery.len</text>
  <text x="309" y="478" fill="rgb(24 158 180)">gth === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDatas</text>
  <text x="391" y="478" fill="rgb(255 255 255)">et.id === idstring) { this.idInQuery.push(idstring); if </text>
  <text x="447" y="478" fill="rgb(24 158 180)">(insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields</text>
  <text x="549" y="478" fill="rgb(255 255 255)"> = this.coursesfields; } else</text>
  <text x="578" y="478" fill="rgb(237 28 36)"> { this.mfields = this.roommfiel</text>
  <text x="610" y="478" fill="rgb(255 255 255)">ds; this.sfields = thi</text>
  <text x="632" y="478" fill="rgb(237 28 36)">s.roomsfields; } re</text>
  <text x="651" y="478" fill="rgb(255 255 255)">turn true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatase</text>
  <text x="0" y="479" fill="rgb(255 255 255)">tKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;</text>
  <text x="166" y="479" fill="rgb(237 28 36)">]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private rea</text>
  <text x="270" y="479" fill="rgb(255 255 255)">donly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;l</text>
  <text x="310" y="479" fill="rgb(24 158 180)">on&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;</text>
  <text x="390" y="479" fill="rgb(255 255 255)">, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;</text>
  <text x="444" y="479" fill="rgb(24 158 180)">href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: stri</text>
  <text x="548" y="479" fill="rgb(255 255 255)">ng[] = [&amp;quot;COUNT&amp;quot;]; private idI</text>
  <text x="577" y="479" fill="rgb(237 28 36)">nQuery: string[]; // make sure th</text>
  <text x="610" y="479" fill="rgb(255 255 255)">e query only has one i</text>
  <text x="632" y="479" fill="rgb(237 28 36)">d private keysInQue</text>
  <text x="651" y="479" fill="rgb(255 255 255)">ry: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allI</text>
  <text x="0" y="480" fill="rgb(255 255 255)">nsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysI</text>
  <text x="167" y="480" fill="rgb(237 28 36)">nQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q:</text>
  <text x="271" y="480" fill="rgb(255 255 255)"> any): void { if (!q || !q.WHERE || !q.O</text>
  <text x="311" y="480" fill="rgb(24 158 180)">PTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (k</text>
  <text x="388" y="480" fill="rgb(255 255 255)">ey !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANS</text>
  <text x="441" y="480" fill="rgb(24 158 180)">FORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.va</text>
  <text x="547" y="480" fill="rgb(255 255 255)">lidateTransformations(q.TRANSF</text>
  <text x="577" y="480" fill="rgb(237 28 36)">ORMATIONS); } this.validateOption</text>
  <text x="610" y="480" fill="rgb(255 255 255)">s(q.OPTIONS); } public</text>
  <text x="632" y="480" fill="rgb(237 28 36)"> validateTransform</text>
  <text x="650" y="480" fill="rgb(255 255 255)">ations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); </text>
  <text x="0" y="481" fill="rgb(255 255 255)">this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and sh</text>
  <text x="168" y="481" fill="rgb(237 28 36)">ould has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push</text>
  <text x="271" y="481" fill="rgb(255 255 255)">(key); // if the key is valid, push it t</text>
  <text x="311" y="481" fill="rgb(24 158 180)">o transformationKey } } private validateKey(key: string): void { let splitt</text>
  <text x="386" y="481" fill="rgb(255 255 255)">edKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.le</text>
  <text x="438" y="481" fill="rgb(24 158 180)">ngth !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includ</text>
  <text x="547" y="481" fill="rgb(255 255 255)">es(splittedKey[1]) || this.sf</text>
  <text x="576" y="481" fill="rgb(237 28 36)">ields.includes(splittedKey[1]))))</text>
  <text x="609" y="481" fill="rgb(255 255 255)"> { throw new InsightEr</text>
  <text x="631" y="481" fill="rgb(237 28 36)">ror(); } } private </text>
  <text x="650" y="481" fill="rgb(255 255 255)">validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.i</text>
  <text x="0" y="482" fill="rgb(255 255 255)">sArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applyke</text>
  <text x="168" y="482" fill="rgb(237 28 36)">y]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) {</text>
  <text x="271" y="482" fill="rgb(255 255 255)"> throw new InsightError(); } this.transfo</text>
  <text x="312" y="482" fill="rgb(24 158 180)">rmationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(cri</text>
  <text x="385" y="482" fill="rgb(255 255 255)">teria).length &amp;gt; 1) { throw new InsightError(); } </text>
  <text x="434" y="482" fill="rgb(24 158 180)">let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includ</text>
  <text x="546" y="482" fill="rgb(255 255 255)">es(applytoken)) { throw new I</text>
  <text x="575" y="482" fill="rgb(237 28 36)">nsightError(); } let key: string[]</text>
  <text x="609" y="482" fill="rgb(255 255 255)"> = criteria[applytoken</text>
  <text x="631" y="482" fill="rgb(237 28 36)">].split(&amp;quot;_&amp;quot;); if (</text>
  <text x="649" y="482" fill="rgb(255 255 255)">key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(</text>
  <text x="0" y="483" fill="rgb(255 255 255)">); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw ne</text>
  <text x="169" y="483" fill="rgb(237 28 36)">w InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for </text>
  <text x="272" y="483" fill="rgb(255 255 255)">(let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot;</text>
  <text x="313" y="483" fill="rgb(24 158 180)"> &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColu</text>
  <text x="383" y="483" fill="rgb(255 255 255)">mns(q.COLUMNS); if (q.ORDER) { this.validateOrde</text>
  <text x="431" y="483" fill="rgb(24 158 180)">r(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for </text>
  <text x="545" y="483" fill="rgb(255 255 255)">(let mskey of q) { if (this.t</text>
  <text x="574" y="483" fill="rgb(237 28 36)">ransformationKey.length &amp;gt; 0) { if (</text>
  <text x="609" y="483" fill="rgb(255 255 255)">!this.transformationKe</text>
  <text x="631" y="483" fill="rgb(237 28 36)">y.includes(mskey))</text>
  <text x="649" y="483" fill="rgb(255 255 255)"> { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightErro</text>
  <text x="0" y="484" fill="rgb(255 255 255)">r(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) {</text>
  <text x="170" y="484" fill="rgb(237 28 36)"> throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let</text>
  <text x="272" y="484" fill="rgb(255 255 255)"> keys: any = q.keys; if (!Array.isArray(ke</text>
  <text x="314" y="484" fill="rgb(24 158 180)">ys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anyke</text>
  <text x="382" y="484" fill="rgb(255 255 255)">y of keys) { if (!this.keysInQuery.includes(a</text>
  <text x="427" y="484" fill="rgb(24 158 180)">nykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new In</text>
  <text x="544" y="484" fill="rgb(255 255 255)">sightError(); } else { if (Ob</text>
  <text x="573" y="484" fill="rgb(237 28 36)">ject.keys(q).length !== 0) { this.va</text>
  <text x="609" y="484" fill="rgb(255 255 255)">lidateFilter(q); } } }</text>
  <text x="631" y="484" fill="rgb(237 28 36)"> private validate</text>
  <text x="648" y="484" fill="rgb(255 255 255)">Filter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { ca</text>
  <text x="0" y="485" fill="rgb(255 255 255)">se &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case</text>
  <text x="171" y="485" fill="rgb(237 28 36)"> &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(va</text>
  <text x="272" y="485" fill="rgb(255 255 255)">lue: any): void { if (typeof value !== &amp;quot;obj</text>
  <text x="315" y="485" fill="rgb(24 158 180)">ect&amp;quot;) { throw new InsightError(); } this.validateFilter(value); }</text>
  <text x="380" y="485" fill="rgb(255 255 255)"> private validateIS(value: any): void { if </text>
  <text x="423" y="485" fill="rgb(24 158 180)">(typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError()</text>
  <text x="544" y="485" fill="rgb(255 255 255)">; } let skey: string[] = Obj</text>
  <text x="572" y="485" fill="rgb(237 28 36)">ect.keys(value)[0].split(&amp;quot;_&amp;quot;); if (sk</text>
  <text x="609" y="485" fill="rgb(255 255 255)">ey.length !== 2) { thr</text>
  <text x="631" y="485" fill="rgb(237 28 36)">ow new InsightErr</text>
  <text x="648" y="485" fill="rgb(255 255 255)">or(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if</text>
  <text x="0" y="486" fill="rgb(255 255 255)"> ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: </text>
  <text x="172" y="486" fill="rgb(237 28 36)">any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightErr</text>
  <text x="273" y="486" fill="rgb(255 255 255)">or(); } let mkey: string[] = Object.keys(v</text>
  <text x="315" y="486" fill="rgb(24 158 180)">alue)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightE</text>
  <text x="379" y="486" fill="rgb(255 255 255)">rror(); } else { let idstring: string = m</text>
  <text x="420" y="486" fill="rgb(24 158 180)">key[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.valida</text>
  <text x="543" y="486" fill="rgb(255 255 255)">teIdstring(idstring) || !this</text>
  <text x="572" y="486" fill="rgb(237 28 36)">.mfields.includes(mfield)) { throw n</text>
  <text x="608" y="486" fill="rgb(255 255 255)">ew InsightError(); } } </text>
  <text x="631" y="486" fill="rgb(237 28 36)">} private valida</text>
  <text x="647" y="486" fill="rgb(255 255 255)">teANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private va</text>
  <text x="0" y="487" fill="rgb(255 255 255)">lidateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { thi</text>
  <text x="173" y="487" fill="rgb(237 28 36)">s.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields =</text>
  <text x="273" y="487" fill="rgb(255 255 255)"> this.coursemfields; this.sfields = this.co</text>
  <text x="316" y="487" fill="rgb(24 158 180)">ursesfields; } else { this.mfields = this.roommfields; this.s</text>
  <text x="377" y="487" fill="rgb(255 255 255)">fields = this.roomsfields; } return tru</text>
  <text x="416" y="487" fill="rgb(24 158 180)">e; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idIn</text>
  <text x="542" y="487" fill="rgb(255 255 255)">Query; } } import {InsightDat</text>
  <text x="571" y="487" fill="rgb(237 28 36)">aset, InsightDatasetKind, InsightErro</text>
  <text x="608" y="487" fill="rgb(255 255 255)">r} from &amp;quot;./IInsightFac</text>
  <text x="630" y="487" fill="rgb(237 28 36)">ade&amp;quot;; export defa</text>
  <text x="647" y="487" fill="rgb(255 255 255)">ult class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;t</text>
  <text x="0" y="488" fill="rgb(255 255 255)">itle&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;addre</text>
  <text x="174" y="488" fill="rgb(237 28 36)">ss&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;];</text>
  <text x="274" y="488" fill="rgb(255 255 255)"> private readonly mstoken: string[] = [&amp;quot;COU</text>
  <text x="317" y="488" fill="rgb(24 158 180)">NT&amp;quot;]; private idInQuery: string[]; // make sure the query o</text>
  <text x="376" y="488" fill="rgb(255 255 255)">nly has one id private keysInQuery: s</text>
  <text x="413" y="488" fill="rgb(24 158 180)">tring[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transfor</text>
  <text x="541" y="488" fill="rgb(255 255 255)">mation, if there is a transfo</text>
  <text x="570" y="488" fill="rgb(237 28 36)">rmation private allInsightDataset: Ins</text>
  <text x="608" y="488" fill="rgb(255 255 255)">ightDataset[]; private</text>
  <text x="630" y="488" fill="rgb(237 28 36)"> mfields: string</text>
  <text x="646" y="488" fill="rgb(255 255 255)">[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDa</text>
  <text x="0" y="489" fill="rgb(255 255 255)">tasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;W</text>
  <text x="175" y="489" fill="rgb(237 28 36)">HERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if</text>
  <text x="274" y="489" fill="rgb(255 255 255)"> (q.TRANSFORMATIONS) { this.validateTransfor</text>
  <text x="318" y="489" fill="rgb(24 158 180)">mations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTI</text>
  <text x="375" y="489" fill="rgb(255 255 255)">ONS); } public validateTransformat</text>
  <text x="409" y="489" fill="rgb(24 158 180)">ions(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw n</text>
  <text x="540" y="489" fill="rgb(255 255 255)">ew InsightError(); } this.val</text>
  <text x="569" y="489" fill="rgb(237 28 36)">idateGROUP(q.GROUP); this.validateAPPLY</text>
  <text x="608" y="489" fill="rgb(255 255 255)">(q.APPLY); } private v</text>
  <text x="630" y="489" fill="rgb(237 28 36)">alidateGROUP(q: </text>
  <text x="646" y="489" fill="rgb(255 255 255)">any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key);</text>
  <text x="0" y="490" fill="rgb(255 255 255)"> this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;);</text>
  <text x="176" y="490" fill="rgb(237 28 36)"> if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedK</text>
  <text x="274" y="490" fill="rgb(255 255 255)">ey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[</text>
  <text x="319" y="490" fill="rgb(24 158 180)">1]) || this.sfields.includes(splittedKey[1])))) { throw</text>
  <text x="374" y="490" fill="rgb(255 255 255)"> new InsightError(); } } private</text>
  <text x="406" y="490" fill="rgb(24 158 180)"> validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least o</text>
  <text x="539" y="490" fill="rgb(255 255 255)">ne element } for (let applyru</text>
  <text x="568" y="490" fill="rgb(237 28 36)">le of q) { if (Array.isArray(applyrule) </text>
  <text x="608" y="490" fill="rgb(255 255 255)">|| Object.keys(applyru</text>
  <text x="630" y="490" fill="rgb(237 28 36)">le).length &amp;gt; 1)</text>
  <text x="645" y="490" fill="rgb(255 255 255)"> { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformat</text>
  <text x="0" y="491" fill="rgb(255 255 255)">ionKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new Insig</text>
  <text x="178" y="491" fill="rgb(237 28 36)">htError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applyto</text>
  <text x="275" y="491" fill="rgb(255 255 255)">ken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) {</text>
  <text x="320" y="491" fill="rgb(24 158 180)"> throw new InsightError(); } let key: string[] = cri</text>
  <text x="372" y="491" fill="rgb(255 255 255)">teria[applytoken].split(&amp;quot;_&amp;quot;); </text>
  <text x="402" y="491" fill="rgb(24 158 180)">if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.m</text>
  <text x="539" y="491" fill="rgb(255 255 255)">fields.includes(key[1]))) { </text>
  <text x="567" y="491" fill="rgb(237 28 36)">throw new InsightError(); } } else if (t</text>
  <text x="607" y="491" fill="rgb(255 255 255)">his.mstoken.includes(ap</text>
  <text x="630" y="491" fill="rgb(237 28 36)">plytoken)) { if</text>
  <text x="645" y="491" fill="rgb(255 255 255)"> (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys:</text>
  <text x="0" y="492" fill="rgb(255 255 255)"> any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.val</text>
  <text x="179" y="492" fill="rgb(237 28 36)">idateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw</text>
  <text x="275" y="492" fill="rgb(255 255 255)"> new InsightError(); } for (let mskey of q) { </text>
  <text x="321" y="492" fill="rgb(24 158 180)">if (this.transformationKey.length &amp;gt; 0) { if (!this</text>
  <text x="371" y="492" fill="rgb(255 255 255)">.transformationKey.includes(</text>
  <text x="399" y="492" fill="rgb(24 158 180)">mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): </text>
  <text x="538" y="492" fill="rgb(255 255 255)">void { if (Array.isArray(q)) </text>
  <text x="567" y="492" fill="rgb(237 28 36)">{ throw new InsightError(); } else if (t</text>
  <text x="607" y="492" fill="rgb(255 255 255)">ypeof q === &amp;quot;string&amp;quot;) {</text>
  <text x="630" y="492" fill="rgb(237 28 36)"> if (!this.key</text>
  <text x="644" y="492" fill="rgb(255 255 255)">sInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { th</text>
  <text x="0" y="493" fill="rgb(255 255 255)">row new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includ</text>
  <text x="180" y="493" fill="rgb(237 28 36)">es(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.i</text>
  <text x="276" y="493" fill="rgb(255 255 255)">sArray(q)) { throw new InsightError(); } else </text>
  <text x="322" y="493" fill="rgb(24 158 180)">{ if (Object.keys(q).length !== 0) { this.valida</text>
  <text x="370" y="493" fill="rgb(255 255 255)">teFilter(q); } } } private</text>
  <text x="396" y="493" fill="rgb(24 158 180)"> validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; le</text>
  <text x="537" y="493" fill="rgb(255 255 255)">t value: any = Object.values(</text>
  <text x="566" y="493" fill="rgb(237 28 36)">q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;O</text>
  <text x="607" y="493" fill="rgb(255 255 255)">R&amp;quot;: this.validateANDOR(</text>
  <text x="630" y="493" fill="rgb(237 28 36)">value); break;</text>
  <text x="644" y="493" fill="rgb(255 255 255)"> case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError();</text>
  <text x="0" y="494" fill="rgb(255 255 255)"> } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (</text>
  <text x="181" y="494" fill="rgb(237 28 36)">typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) {</text>
  <text x="276" y="494" fill="rgb(255 255 255)"> throw new InsightError(); } let skey: string[]</text>
  <text x="323" y="494" fill="rgb(24 158 180)"> = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.</text>
  <text x="369" y="494" fill="rgb(255 255 255)">length !== 2) { throw ne</text>
  <text x="393" y="494" fill="rgb(24 158 180)">w InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str</text>
  <text x="536" y="494" fill="rgb(255 255 255)"> !== &amp;quot;string&amp;quot;) { throw new In</text>
  <text x="565" y="494" fill="rgb(237 28 36)">sightError(); } else { if ((str.slice(1, -</text>
  <text x="607" y="494" fill="rgb(255 255 255)">1).includes(&amp;quot;*&amp;quot;)) || !</text>
  <text x="629" y="494" fill="rgb(237 28 36)">this.validateI</text>
  <text x="643" y="494" fill="rgb(255 255 255)">dstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length</text>
  <text x="0" y="495" fill="rgb(255 255 255)"> !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0</text>
  <text x="182" y="495" fill="rgb(237 28 36)">]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;n</text>
  <text x="277" y="495" fill="rgb(255 255 255)">umber&amp;quot;) || !this.validateIdstring(idstring) || </text>
  <text x="324" y="495" fill="rgb(24 158 180)">!this.mfields.includes(mfield)) { throw new I</text>
  <text x="369" y="495" fill="rgb(255 255 255)">nsightError(); } } } p</text>
  <text x="391" y="495" fill="rgb(24 158 180)">rivate validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of va</text>
  <text x="535" y="495" fill="rgb(255 255 255)">lue) { this.validateFilter(in</text>
  <text x="564" y="495" fill="rgb(237 28 36)">nerObject); } } private validateIdstring(id</text>
  <text x="607" y="495" fill="rgb(255 255 255)">string: string): boole</text>
  <text x="629" y="495" fill="rgb(237 28 36)">an { if (this.</text>
  <text x="643" y="495" fill="rgb(255 255 255)">idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDataset</text>
  <text x="0" y="496" fill="rgb(255 255 255)">Kind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } retu</text>
  <text x="184" y="496" fill="rgb(237 28 36)">rn false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): strin</text>
  <text x="277" y="496" fill="rgb(255 255 255)">g[] { return this.idInQuery; } } import {Insight</text>
  <text x="325" y="496" fill="rgb(24 158 180)">Dataset, InsightDatasetKind, InsightError} </text>
  <text x="368" y="496" fill="rgb(255 255 255)">from &amp;quot;./IInsightFaca</text>
  <text x="388" y="496" fill="rgb(24 158 180)">de&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly c</text>
  <text x="534" y="496" fill="rgb(255 255 255)">oursesfields: string[] = [&amp;quot;de</text>
  <text x="563" y="496" fill="rgb(237 28 36)">pt&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; </text>
  <text x="606" y="496" fill="rgb(255 255 255)">private readonly roommf</text>
  <text x="629" y="496" fill="rgb(237 28 36)">ields: string</text>
  <text x="642" y="496" fill="rgb(255 255 255)">[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] </text>
  <text x="0" y="497" fill="rgb(255 255 255)">= [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all</text>
  <text x="185" y="497" fill="rgb(237 28 36)"> keys appeared in columns after being validated private transformationKey: string[]; // keys </text>
  <text x="278" y="497" fill="rgb(255 255 255)">appeared in transformation, if there is a transf</text>
  <text x="326" y="497" fill="rgb(24 158 180)">ormation private allInsightDataset: Insig</text>
  <text x="367" y="497" fill="rgb(255 255 255)">htDataset[]; privat</text>
  <text x="386" y="497" fill="rgb(24 158 180)">e mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.t</text>
  <text x="533" y="497" fill="rgb(255 255 255)">ransformationKey = []; this.a</text>
  <text x="562" y="497" fill="rgb(237 28 36)">llInsightDataset = insightDatasets; } public</text>
  <text x="606" y="497" fill="rgb(255 255 255)"> validate(q: any): void</text>
  <text x="629" y="497" fill="rgb(237 28 36)"> { if (!q ||</text>
  <text x="641" y="497" fill="rgb(255 255 255)"> !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } </text>
  <text x="0" y="498" fill="rgb(255 255 255)">this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void {</text>
  <text x="186" y="498" fill="rgb(237 28 36)"> if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).leng</text>
  <text x="278" y="498" fill="rgb(255 255 255)">th !== 2) { throw new InsightError(); } this.vali</text>
  <text x="327" y="498" fill="rgb(24 158 180)">dateGROUP(q.GROUP); this.validateAPPLY(q</text>
  <text x="367" y="498" fill="rgb(255 255 255)">.APPLY); } priva</text>
  <text x="383" y="498" fill="rgb(24 158 180)">te validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least</text>
  <text x="532" y="498" fill="rgb(255 255 255)"> one element } for (let key o</text>
  <text x="561" y="498" fill="rgb(237 28 36)">f q) { this.validateKey(key); this.transforma</text>
  <text x="606" y="498" fill="rgb(255 255 255)">tionKey.push(key); // i</text>
  <text x="629" y="498" fill="rgb(237 28 36)">f the key is</text>
  <text x="641" y="498" fill="rgb(255 255 255)"> valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(</text>
  <text x="0" y="499" fill="rgb(255 255 255)">this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): </text>
  <text x="187" y="499" fill="rgb(237 28 36)">void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and shoul</text>
  <text x="279" y="499" fill="rgb(255 255 255)">d have at least one element } for (let applyrule </text>
  <text x="328" y="499" fill="rgb(24 158 180)">of q) { if (Array.isArray(applyrule) |</text>
  <text x="366" y="499" fill="rgb(255 255 255)">| Object.keys(a</text>
  <text x="381" y="499" fill="rgb(24 158 180)">pplyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey</text>
  <text x="531" y="499" fill="rgb(255 255 255)">.length === 0 || applykey.incl</text>
  <text x="561" y="499" fill="rgb(237 28 36)">udes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(</text>
  <text x="606" y="499" fill="rgb(255 255 255)">applykey)) { throw new </text>
  <text x="629" y="499" fill="rgb(237 28 36)">InsightErro</text>
  <text x="640" y="499" fill="rgb(255 255 255)">r(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; i</text>
  <text x="0" y="500" fill="rgb(255 255 255)">f (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw </text>
  <text x="189" y="500" fill="rgb(237 28 36)">new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(</text>
  <text x="279" y="500" fill="rgb(255 255 255)">key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw</text>
  <text x="329" y="500" fill="rgb(24 158 180)"> new InsightError(); } } else if (th</text>
  <text x="365" y="500" fill="rgb(255 255 255)">is.mstoken.inc</text>
  <text x="379" y="500" fill="rgb(24 158 180)">ludes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError</text>
  <text x="530" y="500" fill="rgb(255 255 255)">(); } } } } public validateOpt</text>
  <text x="560" y="500" fill="rgb(237 28 36)">ions(q: any): void { let keys: any[] = Object</text>
  <text x="605" y="500" fill="rgb(255 255 255)">.keys(q); for (let key </text>
  <text x="628" y="500" fill="rgb(237 28 36)">of keys) { i</text>
  <text x="640" y="500" fill="rgb(255 255 255)">f (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void {</text>
  <text x="0" y="501" fill="rgb(255 255 255)"> if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError()</text>
  <text x="190" y="501" fill="rgb(237 28 36)">; } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validate</text>
  <text x="280" y="501" fill="rgb(255 255 255)">Order(q: any): void { if (Array.isArray(q)) { thro</text>
  <text x="330" y="501" fill="rgb(24 158 180)">w new InsightError(); } else if (ty</text>
  <text x="365" y="501" fill="rgb(255 255 255)">peof q === </text>
  <text x="376" y="501" fill="rgb(24 158 180)">&amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new I</text>
  <text x="529" y="501" fill="rgb(255 255 255)">nsightError(); } if (q.dir !==</text>
  <text x="559" y="501" fill="rgb(237 28 36)"> &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new Insight</text>
  <text x="605" y="501" fill="rgb(255 255 255)">Error(); } let keys: an</text>
  <text x="628" y="501" fill="rgb(237 28 36)">y = q.keys;</text>
  <text x="639" y="501" fill="rgb(255 255 255)"> if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validate</text>
  <text x="0" y="502" fill="rgb(255 255 255)">Where(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Ob</text>
  <text x="191" y="502" fill="rgb(237 28 36)">ject.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.</text>
  <text x="280" y="502" fill="rgb(255 255 255)">keys(q)[0]; let value: any = Object.values(q)[0]; s</text>
  <text x="331" y="502" fill="rgb(24 158 180)">witch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;O</text>
  <text x="364" y="502" fill="rgb(255 255 255)">R&amp;quot;: this.</text>
  <text x="373" y="502" fill="rgb(24 158 180)">validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: thi</text>
  <text x="528" y="502" fill="rgb(255 255 255)">s.validateIS(value); break; de</text>
  <text x="558" y="502" fill="rgb(237 28 36)">fault: throw new InsightError(); } } } private </text>
  <text x="605" y="502" fill="rgb(255 255 255)">validateNOT(value: any)</text>
  <text x="628" y="502" fill="rgb(237 28 36)">: void { if</text>
  <text x="639" y="502" fill="rgb(255 255 255)"> (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (O</text>
  <text x="0" y="503" fill="rgb(255 255 255)">bject.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: st</text>
  <text x="193" y="503" fill="rgb(237 28 36)">ring = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if</text>
  <text x="281" y="503" fill="rgb(255 255 255)"> (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError</text>
  <text x="332" y="503" fill="rgb(24 158 180)">(); } else { if ((str.slice(1, </text>
  <text x="363" y="503" fill="rgb(255 255 255)">-1).inc</text>
  <text x="370" y="503" fill="rgb(24 158 180)">ludes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): vo</text>
  <text x="527" y="503" fill="rgb(255 255 255)">id { if (typeof value !== &amp;quot;obj</text>
  <text x="557" y="503" fill="rgb(237 28 36)">ect&amp;quot; || Object.keys(value).length !== 1) { throw</text>
  <text x="605" y="503" fill="rgb(255 255 255)"> new InsightError(); } </text>
  <text x="628" y="503" fill="rgb(237 28 36)">let mkey: </text>
  <text x="638" y="503" fill="rgb(255 255 255)">string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values</text>
  <text x="0" y="504" fill="rgb(255 255 255)">(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!</text>
  <text x="194" y="504" fill="rgb(237 28 36)">Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerO</text>
  <text x="281" y="504" fill="rgb(255 255 255)">bject of value) { this.validateFilter(innerObject); </text>
  <text x="333" y="504" fill="rgb(24 158 180)">} } private validateIdstring(</text>
  <text x="362" y="504" fill="rgb(255 255 255)">idstri</text>
  <text x="368" y="504" fill="rgb(24 158 180)">ng: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idI</text>
  <text x="525" y="504" fill="rgb(255 255 255)">nQuery.push(idstring); if (insi</text>
  <text x="556" y="504" fill="rgb(237 28 36)">ghtDataset.kind === InsightDatasetKind.Courses) {</text>
  <text x="605" y="504" fill="rgb(255 255 255)"> this.mfields = this.co</text>
  <text x="628" y="504" fill="rgb(237 28 36)">ursemfield</text>
  <text x="638" y="504" fill="rgb(255 255 255)">s; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring)</text>
  <text x="0" y="505" fill="rgb(255 255 255)">; } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private </text>
  <text x="196" y="505" fill="rgb(237 28 36)">readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private r</text>
  <text x="282" y="505" fill="rgb(255 255 255)">eadonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;ins</text>
  <text x="335" y="505" fill="rgb(24 158 180)">tructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]</text>
  <text x="361" y="505" fill="rgb(255 255 255)">; pri</text>
  <text x="366" y="505" fill="rgb(24 158 180)">vate readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;</text>
  <text x="524" y="505" fill="rgb(255 255 255)">, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;];</text>
  <text x="555" y="505" fill="rgb(237 28 36)"> private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN</text>
  <text x="604" y="505" fill="rgb(255 255 255)">&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; privat</text>
  <text x="628" y="505" fill="rgb(237 28 36)">e readonl</text>
  <text x="637" y="505" fill="rgb(255 255 255)">y mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private tr</text>
  <text x="0" y="506" fill="rgb(255 255 255)">ansformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constr</text>
  <text x="197" y="506" fill="rgb(237 28 36)">uctor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []</text>
  <text x="282" y="506" fill="rgb(255 255 255)">; this.transformationKey = []; this.allInsightDataset </text>
  <text x="336" y="506" fill="rgb(24 158 180)">= insightDatasets; } pub</text>
  <text x="360" y="506" fill="rgb(255 255 255)">lic </text>
  <text x="364" y="506" fill="rgb(24 158 180)">validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WH</text>
  <text x="523" y="506" fill="rgb(255 255 255)">ERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATION</text>
  <text x="554" y="506" fill="rgb(237 28 36)">S&amp;quot;) { throw new InsightError(); } } this.validateW</text>
  <text x="604" y="506" fill="rgb(255 255 255)">here(q.WHERE); if (q.TR</text>
  <text x="627" y="506" fill="rgb(237 28 36)">ANSFORMAT</text>
  <text x="636" y="506" fill="rgb(255 255 255)">IONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY ===</text>
  <text x="0" y="507" fill="rgb(255 255 255)"> &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q</text>
  <text x="199" y="507" fill="rgb(237 28 36)">.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at</text>
  <text x="283" y="507" fill="rgb(255 255 255)"> least one element } for (let key of q) { this.validat</text>
  <text x="337" y="507" fill="rgb(24 158 180)">eKey(key); this.transf</text>
  <text x="359" y="507" fill="rgb(255 255 255)">orm</text>
  <text x="362" y="507" fill="rgb(24 158 180)">ationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;)</text>
  <text x="522" y="507" fill="rgb(255 255 255)">; if (splittedKey.length !== 2)</text>
  <text x="553" y="507" fill="rgb(237 28 36)"> { throw new InsightError(); } if (!(this.validateI</text>
  <text x="604" y="507" fill="rgb(255 255 255)">dstring(splittedKey[0])</text>
  <text x="627" y="507" fill="rgb(237 28 36)"> &amp;amp;&amp;amp; (this</text>
  <text x="636" y="507" fill="rgb(255 255 255)">.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError()</text>
  <text x="0" y="508" fill="rgb(255 255 255)">; // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applyk</text>
  <text x="200" y="508" fill="rgb(237 28 36)">ey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (app</text>
  <text x="283" y="508" fill="rgb(255 255 255)">lykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.tr</text>
  <text x="338" y="508" fill="rgb(24 158 180)">ansformationKey.incl</text>
  <text x="358" y="508" fill="rgb(255 255 255)">ude</text>
  <text x="361" y="508" fill="rgb(24 158 180)">s(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new I</text>
  <text x="521" y="508" fill="rgb(255 255 255)">nsightError(); } let applytoken</text>
  <text x="552" y="508" fill="rgb(237 28 36)">: string = Object.keys(criteria)[0]; if (!this.mtoke</text>
  <text x="604" y="508" fill="rgb(255 255 255)">n.includes(applytoken) </text>
  <text x="627" y="508" fill="rgb(237 28 36)">&amp;amp;&amp;amp; !this</text>
  <text x="635" y="508" fill="rgb(255 255 255)">.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applyto</text>
  <text x="0" y="509" fill="rgb(255 255 255)">ken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.</text>
  <text x="202" y="509" fill="rgb(237 28 36)">sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightEr</text>
  <text x="284" y="509" fill="rgb(255 255 255)">ror(); } } } } public validateOptions(q: any): void { le</text>
  <text x="340" y="509" fill="rgb(24 158 180)">t keys: any[] = Ob</text>
  <text x="358" y="509" fill="rgb(255 255 255)">je</text>
  <text x="360" y="509" fill="rgb(24 158 180)">ct.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { t</text>
  <text x="519" y="509" fill="rgb(255 255 255)">his.validateOrder(q.ORDER); } } </text>
  <text x="551" y="509" fill="rgb(237 28 36)">private validateColumns(q: any): void { if (!q || q.</text>
  <text x="603" y="509" fill="rgb(255 255 255)">length &amp;lt; 1) { throw new </text>
  <text x="627" y="509" fill="rgb(237 28 36)">InsightE</text>
  <text x="635" y="509" fill="rgb(255 255 255)">rror(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQu</text>
  <text x="0" y="510" fill="rgb(255 255 255)">ery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightErro</text>
  <text x="203" y="510" fill="rgb(237 28 36)">r(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new </text>
  <text x="285" y="510" fill="rgb(255 255 255)">InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;</text>
  <text x="341" y="510" fill="rgb(24 158 180)">) { throw new In</text>
  <text x="357" y="510" fill="rgb(255 255 255)">si</text>
  <text x="359" y="510" fill="rgb(24 158 180)">ghtError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQue</text>
  <text x="518" y="510" fill="rgb(255 255 255)">ry.includes(anykey)) { throw new </text>
  <text x="551" y="510" fill="rgb(237 28 36)">InsightError(); } } } } public validateWhere(q: any)</text>
  <text x="603" y="510" fill="rgb(255 255 255)">: void { if (Array.isArr</text>
  <text x="627" y="510" fill="rgb(237 28 36)">ay(q)) </text>
  <text x="634" y="510" fill="rgb(255 255 255)">{ throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(</text>
  <text x="0" y="511" fill="rgb(255 255 255)">); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; ca</text>
  <text x="205" y="511" fill="rgb(237 28 36)">se &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: thi</text>
  <text x="285" y="511" fill="rgb(255 255 255)">s.validateIS(value); break; default: throw new InsightErr</text>
  <text x="342" y="511" fill="rgb(24 158 180)">or(); } } } pr</text>
  <text x="356" y="511" fill="rgb(255 255 255)">i</text>
  <text x="357" y="511" fill="rgb(24 158 180)">vate validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): </text>
  <text x="517" y="511" fill="rgb(255 255 255)">void { if (typeof value !== &amp;quot;obje</text>
  <text x="550" y="511" fill="rgb(237 28 36)">ct&amp;quot;) { throw new InsightError(); } if (Object.keys(va</text>
  <text x="603" y="511" fill="rgb(255 255 255)">lue).length !== 1) { thr</text>
  <text x="627" y="511" fill="rgb(237 28 36)">ow new </text>
  <text x="634" y="511" fill="rgb(255 255 255)">InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let </text>
  <text x="0" y="512" fill="rgb(255 255 255)">str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfiel</text>
  <text x="206" y="512" fill="rgb(237 28 36)">d)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void</text>
  <text x="286" y="512" fill="rgb(255 255 255)"> { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).len</text>
  <text x="344" y="512" fill="rgb(24 158 180)">gth !== 1) </text>
  <text x="355" y="512" fill="rgb(255 255 255)">{</text>
  <text x="356" y="512" fill="rgb(24 158 180)"> throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: s</text>
  <text x="515" y="512" fill="rgb(255 255 255)">tring = mkey[0]; let mfield: strin</text>
  <text x="549" y="512" fill="rgb(237 28 36)">g = mkey[1]; let num: any = Object.values(value)[0]; i</text>
  <text x="603" y="512" fill="rgb(255 255 255)">f ((typeof num !== &amp;quot;num</text>
  <text x="626" y="512" fill="rgb(237 28 36)">ber&amp;quot;) |</text>
  <text x="633" y="512" fill="rgb(255 255 255)">| !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw</text>
  <text x="0" y="513" fill="rgb(255 255 255)"> new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset o</text>
  <text x="208" y="513" fill="rgb(237 28 36)">f this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuer</text>
  <text x="287" y="513" fill="rgb(255 255 255)">y.push(idstring); if (insightDataset.kind === InsightDatas</text>
  <text x="345" y="513" fill="rgb(24 158 180)">etKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } retu</text>
  <text x="514" y="513" fill="rgb(255 255 255)">rn true; } } return false; } else </text>
  <text x="548" y="513" fill="rgb(237 28 36)">{ return this.idInQuery.includes(idstring); } } public</text>
  <text x="602" y="513" fill="rgb(255 255 255)"> getIdInQuery(): string[</text>
  <text x="626" y="513" fill="rgb(237 28 36)">] { ret</text>
  <text x="633" y="513" fill="rgb(255 255 255)">urn this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pas</text>
  <text x="0" y="514" fill="rgb(255 255 255)">s&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfi</text>
  <text x="210" y="514" fill="rgb(237 28 36)">elds: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;typ</text>
  <text x="287" y="514" fill="rgb(255 255 255)">e&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] </text>
  <text x="347" y="514" fill="rgb(24 158 180)">= [&amp;quot;MA</text>
  <text x="353" y="514" fill="rgb(255 255 255)">X</text>
  <text x="354" y="514" fill="rgb(24 158 180)">&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQue</text>
  <text x="512" y="514" fill="rgb(255 255 255)">ry: string[]; // all keys appeared </text>
  <text x="547" y="514" fill="rgb(237 28 36)">in columns after being validated private transformation</text>
  <text x="602" y="514" fill="rgb(255 255 255)">Key: string[]; // keys a</text>
  <text x="626" y="514" fill="rgb(237 28 36)">ppeare</text>
  <text x="632" y="514" fill="rgb(255 255 255)">d in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { thi</text>
  <text x="0" y="515" fill="rgb(255 255 255)">s.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } fo</text>
  <text x="212" y="515" fill="rgb(237 28 36)">r (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; </text>
  <text x="288" y="515" fill="rgb(255 255 255)">key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } t</text>
  <text x="348" y="515" fill="rgb(24 158 180)">his.</text>
  <text x="352" y="515" fill="rgb(255 255 255)">v</text>
  <text x="353" y="515" fill="rgb(24 158 180)">alidateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransform</text>
  <text x="511" y="515" fill="rgb(255 255 255)">ations(q: any): void { if (typeof q</text>
  <text x="546" y="515" fill="rgb(237 28 36)">.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot;</text>
  <text x="602" y="515" fill="rgb(255 255 255)"> || Object.keys(q).lengt</text>
  <text x="626" y="515" fill="rgb(237 28 36)">h !==</text>
  <text x="631" y="515" fill="rgb(255 255 255)"> 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // </text>
  <text x="0" y="516" fill="rgb(255 255 255)">q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateK</text>
  <text x="213" y="516" fill="rgb(237 28 36)">ey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (spl</text>
  <text x="288" y="516" fill="rgb(255 255 255)">ittedKey.length !== 2) { throw new InsightError(); } if (!(this.v</text>
  <text x="353" y="516" fill="rgb(24 158 180)">alidateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } privat</text>
  <text x="509" y="516" fill="rgb(255 255 255)">e validateAPPLY(q: any): void { if (</text>
  <text x="545" y="516" fill="rgb(237 28 36)">!Array.isArray(q)) { throw new InsightError(); // q shoul</text>
  <text x="602" y="516" fill="rgb(255 255 255)">d be an array, and shoul</text>
  <text x="626" y="516" fill="rgb(237 28 36)">d hav</text>
  <text x="631" y="516" fill="rgb(255 255 255)">e at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let</text>
  <text x="0" y="517" fill="rgb(255 255 255)"> criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArr</text>
  <text x="215" y="517" fill="rgb(237 28 36)">ay(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError</text>
  <text x="289" y="517" fill="rgb(255 255 255)">(); } let applytoken: string = Object.keys(criteria)[0]; if (!th</text>
  <text x="353" y="517" fill="rgb(24 158 180)">is.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if</text>
  <text x="508" y="517" fill="rgb(255 255 255)"> (key.length !== 2) { throw new Insi</text>
  <text x="544" y="517" fill="rgb(237 28 36)">ghtError(); } if (this.mtoken.includes(applytoken)) { if </text>
  <text x="601" y="517" fill="rgb(255 255 255)">(!(this.validateIdstring</text>
  <text x="625" y="517" fill="rgb(237 28 36)">(key[</text>
  <text x="630" y="517" fill="rgb(255 255 255)">0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.</text>
  <text x="0" y="518" fill="rgb(255 255 255)">includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightErr</text>
  <text x="217" y="518" fill="rgb(237 28 36)">or(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOr</text>
  <text x="290" y="518" fill="rgb(255 255 255)">der(q.ORDER); } } private validateColumns(q: any): void { if (!</text>
  <text x="353" y="518" fill="rgb(24 158 180)">q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(msk</text>
  <text x="506" y="518" fill="rgb(255 255 255)">ey)) { throw new InsightError(); } } </text>
  <text x="543" y="518" fill="rgb(237 28 36)">else { this.validateKey(mskey); } this.keysInQuery.push(ms</text>
  <text x="601" y="518" fill="rgb(255 255 255)">key); } } private valida</text>
  <text x="625" y="518" fill="rgb(237 28 36)">teOrd</text>
  <text x="630" y="518" fill="rgb(255 255 255)">er(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys ||</text>
  <text x="0" y="519" fill="rgb(255 255 255)"> Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightE</text>
  <text x="219" y="519" fill="rgb(237 28 36)">rror(); } for (let anykey of keys) { if (!this.keysInQuery.includes(any</text>
  <text x="290" y="519" fill="rgb(255 255 255)">key)) { throw new InsightError(); } } } } public validateWhere(q</text>
  <text x="354" y="519" fill="rgb(24 158 180)">: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private val</text>
  <text x="504" y="519" fill="rgb(255 255 255)">idateFilter(q: any): void { if (Object</text>
  <text x="542" y="519" fill="rgb(237 28 36)">.keys(q).length !== 1) { throw new InsightError(); } else {</text>
  <text x="601" y="519" fill="rgb(255 255 255)"> let key: string = Objec</text>
  <text x="625" y="519" fill="rgb(237 28 36)">t.ke</text>
  <text x="629" y="519" fill="rgb(255 255 255)">ys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.va</text>
  <text x="0" y="520" fill="rgb(255 255 255)">lidateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.val</text>
  <text x="220" y="520" fill="rgb(237 28 36)">idateFilter(value); } private validateIS(value: any): void { if (typeof</text>
  <text x="291" y="520" fill="rgb(255 255 255)"> value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.key</text>
  <text x="356" y="520" fill="rgb(24 158 180)">s(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new Insi</text>
  <text x="503" y="520" fill="rgb(255 255 255)">ghtError(); } else { let idstring: str</text>
  <text x="541" y="520" fill="rgb(237 28 36)">ing = skey[0]; let sfield: string = skey[1]; let str: any = </text>
  <text x="601" y="520" fill="rgb(255 255 255)">Object.values(value)[0];</text>
  <text x="625" y="520" fill="rgb(237 28 36)"> if </text>
  <text x="629" y="520" fill="rgb(255 255 255)">(typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } }</text>
  <text x="0" y="521" fill="rgb(255 255 255)"> } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { </text>
  <text x="222" y="521" fill="rgb(237 28 36)">throw new InsightError(); } else { let idstring: string = mkey[0]; let</text>
  <text x="292" y="521" fill="rgb(255 255 255)"> mfield: string = mkey[1]; let num: any = Object.values(value)[0];</text>
  <text x="358" y="521" fill="rgb(24 158 180)"> if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private</text>
  <text x="501" y="521" fill="rgb(255 255 255)"> validateANDOR(value: any): void { if (</text>
  <text x="540" y="521" fill="rgb(237 28 36)">!Array.isArray(value) || value.length &amp;lt; 1) { throw new Insig</text>
  <text x="600" y="521" fill="rgb(255 255 255)">htError(); } for (let inn</text>
  <text x="625" y="521" fill="rgb(237 28 36)">erO</text>
  <text x="628" y="521" fill="rgb(255 255 255)">bject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (ins</text>
  <text x="0" y="522" fill="rgb(255 255 255)">ightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roomm</text>
  <text x="224" y="522" fill="rgb(237 28 36)">fields; this.sfields = this.roomsfields; } return true; } } return fa</text>
  <text x="293" y="522" fill="rgb(255 255 255)">lse; } else { return this.idInQuery.includes(idstring); } } public </text>
  <text x="360" y="522" fill="rgb(24 158 180)">getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; ex</text>
  <text x="499" y="522" fill="rgb(255 255 255)">port default class QueryValidator { priv</text>
  <text x="539" y="522" fill="rgb(237 28 36)">ate readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;</text>
  <text x="600" y="522" fill="rgb(255 255 255)">, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; priva</text>
  <text x="625" y="522" fill="rgb(237 28 36)">te</text>
  <text x="627" y="522" fill="rgb(255 255 255)"> readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;sh</text>
  <text x="0" y="523" fill="rgb(255 255 255)">ortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure </text>
  <text x="226" y="523" fill="rgb(237 28 36)">the query only has one id private keysInQuery: string[]; // all key</text>
  <text x="293" y="523" fill="rgb(255 255 255)">s appeared in columns after being validated private transformationKey</text>
  <text x="362" y="523" fill="rgb(24 158 180)">: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfiel</text>
  <text x="497" y="523" fill="rgb(255 255 255)">ds: string[]; private sfields: string[]; </text>
  <text x="538" y="523" fill="rgb(237 28 36)">constructor(insightDatasets: InsightDataset[]) { this.idInQuer</text>
  <text x="600" y="523" fill="rgb(255 255 255)">y = []; this.keysInQuery</text>
  <text x="624" y="523" fill="rgb(237 28 36)"> = </text>
  <text x="627" y="523" fill="rgb(255 255 255)">[]; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) {</text>
  <text x="0" y="524" fill="rgb(255 255 255)"> if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOption</text>
  <text x="228" y="524" fill="rgb(237 28 36)">s(q.OPTIONS); } public validateTransformations(q: any): void { if </text>
  <text x="294" y="524" fill="rgb(255 255 255)">(typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || O</text>
  <text x="364" y="524" fill="rgb(24 158 180)">bject.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private valid</text>
  <text x="495" y="524" fill="rgb(255 255 255)">ateGROUP(q: any): void { if (!Array.isArra</text>
  <text x="537" y="524" fill="rgb(237 28 36)">y(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should b</text>
  <text x="600" y="524" fill="rgb(255 255 255)">e an object, and should </text>
  <text x="624" y="524" fill="rgb(237 28 36)">ha</text>
  <text x="626" y="524" fill="rgb(255 255 255)">s at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let sp</text>
  <text x="0" y="525" fill="rgb(255 255 255)">littedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { </text>
  <text x="230" y="525" fill="rgb(237 28 36)">throw new InsightError(); } } private validateAPPLY(q: any): void</text>
  <text x="295" y="525" fill="rgb(255 255 255)"> { if (!Array.isArray(q)) { throw new InsightError(); // q should be an</text>
  <text x="366" y="525" fill="rgb(24 158 180)"> array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule</text>
  <text x="493" y="525" fill="rgb(255 255 255)">).length &amp;gt; 1) { throw new InsightError(); }</text>
  <text x="536" y="525" fill="rgb(237 28 36)"> let applykey: string = Object.keys(applyrule)[0]; let criteria</text>
  <text x="599" y="525" fill="rgb(255 255 255)"> = applyrule[applykey]; i</text>
  <text x="624" y="525" fill="rgb(237 28 36)">f </text>
  <text x="626" y="525" fill="rgb(255 255 255)">(applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(</text>
  <text x="0" y="526" fill="rgb(255 255 255)">criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = cr</text>
  <text x="232" y="526" fill="rgb(237 28 36)">iteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw ne</text>
  <text x="295" y="526" fill="rgb(255 255 255)">w InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.va</text>
  <text x="368" y="526" fill="rgb(24 158 180)">lidateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(ap</text>
  <text x="491" y="526" fill="rgb(255 255 255)">plytoken)) { if (!(this.validateIdstring(key</text>
  <text x="535" y="526" fill="rgb(237 28 36)">[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(</text>
  <text x="599" y="526" fill="rgb(255 255 255)">key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateCol</text>
  <text x="0" y="527" fill="rgb(255 255 255)">umns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.t</text>
  <text x="234" y="527" fill="rgb(237 28 36)">ransformationKey.includes(mskey)) { throw new InsightError(); </text>
  <text x="296" y="527" fill="rgb(255 255 255)">} } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } pr</text>
  <text x="370" y="527" fill="rgb(24 158 180)">ivate validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;</text>
  <text x="488" y="527" fill="rgb(255 255 255)">) { if (!this.keysInQuery.includes(q)) { throw</text>
  <text x="534" y="527" fill="rgb(237 28 36)"> new InsightError(); } } else { if (!q.dir || !q.keys || Object.k</text>
  <text x="599" y="527" fill="rgb(255 255 255)">eys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anyke</text>
  <text x="0" y="528" fill="rgb(255 255 255)">y of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFil</text>
  <text x="236" y="528" fill="rgb(237 28 36)">ter(q); } } } private validateFilter(q: any): void { if (Obje</text>
  <text x="297" y="528" fill="rgb(255 255 255)">ct.keys(q).length !== 1) { throw new InsightError(); } else { let key: strin</text>
  <text x="373" y="528" fill="rgb(24 158 180)">g = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateA</text>
  <text x="486" y="528" fill="rgb(255 255 255)">NDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNO</text>
  <text x="533" y="528" fill="rgb(237 28 36)">T(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGT</text>
  <text x="598" y="528" fill="rgb(255 255 255)">LTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } p</text>
  <text x="0" y="529" fill="rgb(255 255 255)">rivate validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !</text>
  <text x="238" y="529" fill="rgb(237 28 36)">== 2) { throw new InsightError(); } else { let idstring: str</text>
  <text x="298" y="529" fill="rgb(255 255 255)">ing = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(val</text>
  <text x="375" y="529" fill="rgb(24 158 180)">ue)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)</text>
  <text x="484" y="529" fill="rgb(255 255 255)">) || !this.validateIdstring(idstring) || !this.s</text>
  <text x="532" y="529" fill="rgb(237 28 36)">fields.includes(sfield)) { throw new InsightError(); } } } } priva</text>
  <text x="598" y="529" fill="rgb(255 255 255)">te validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightErro</text>
  <text x="0" y="530" fill="rgb(255 255 255)">r(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightErro</text>
  <text x="240" y="530" fill="rgb(237 28 36)">r(); } } } private validateANDOR(value: any): void { if (!</text>
  <text x="298" y="530" fill="rgb(255 255 255)">Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let</text>
  <text x="378" y="530" fill="rgb(24 158 180)"> innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: strin</text>
  <text x="481" y="530" fill="rgb(255 255 255)">g): boolean { if (this.idInQuery.length === 0) { f</text>
  <text x="531" y="530" fill="rgb(237 28 36)">or (let insightDataset of this.allInsightDataset) { if (insightData</text>
  <text x="598" y="530" fill="rgb(255 255 255)">set.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfield</text>
  <text x="0" y="531" fill="rgb(255 255 255)">s = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsi</text>
  <text x="242" y="531" fill="rgb(237 28 36)">ghtFacade&amp;quot;; export default class QueryValidator { private</text>
  <text x="299" y="531" fill="rgb(255 255 255)"> readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; pri</text>
  <text x="380" y="531" fill="rgb(24 158 180)">vate readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private rea</text>
  <text x="478" y="531" fill="rgb(255 255 255)">donly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;</text>
  <text x="530" y="531" fill="rgb(237 28 36)">]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;</text>
  <text x="598" y="531" fill="rgb(255 255 255)">, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only ha</text>
  <text x="0" y="532" fill="rgb(255 255 255)">s one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; pri</text>
  <text x="244" y="532" fill="rgb(237 28 36)">vate mfields: string[]; private sfields: string[]; const</text>
  <text x="300" y="532" fill="rgb(255 255 255)">ructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery =</text>
  <text x="383" y="532" fill="rgb(24 158 180)"> []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validat</text>
  <text x="475" y="532" fill="rgb(255 255 255)">e(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { </text>
  <text x="529" y="532" fill="rgb(237 28 36)">throw new InsightError(); } for (let key of Object.keys(q)) { if (ke</text>
  <text x="597" y="532" fill="rgb(255 255 255)">y !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); }</text>
  <text x="0" y="533" fill="rgb(255 255 255)"> public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private</text>
  <text x="246" y="533" fill="rgb(237 28 36)"> validateGROUP(q: any): void { if (!Array.isArray(q) ||</text>
  <text x="301" y="533" fill="rgb(255 255 255)"> q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at</text>
  <text x="387" y="533" fill="rgb(24 158 180)"> least one element } for (let key of q) { this.validateKey(key); this.transformationK</text>
  <text x="472" y="533" fill="rgb(255 255 255)">ey.push(key); // if the key is valid, push it to transfo</text>
  <text x="528" y="533" fill="rgb(237 28 36)">rmationKey } } private validateKey(key: string): void { let splittedK</text>
  <text x="597" y="533" fill="rgb(255 255 255)">ey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new Ins</text>
  <text x="0" y="534" fill="rgb(255 255 255)">ightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one e</text>
  <text x="161" y="534" fill="rgb(237 28 36)">le</text>
  <text x="163" y="534" fill="rgb(255 255 255)">ment } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrul</text>
  <text x="249" y="534" fill="rgb(237 28 36)">e).length &amp;gt; 1) { throw new InsightError(); } let app</text>
  <text x="301" y="534" fill="rgb(255 255 255)">lykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applyk</text>
  <text x="390" y="534" fill="rgb(24 158 180)">ey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(a</text>
  <text x="468" y="534" fill="rgb(255 255 255)">pplykey)) { throw new InsightError(); } this.transformatio</text>
  <text x="526" y="534" fill="rgb(237 28 36)">nKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteri</text>
  <text x="597" y="534" fill="rgb(255 255 255)">a).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[appl</text>
  <text x="0" y="535" fill="rgb(255 255 255)">ytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfield</text>
  <text x="162" y="535" fill="rgb(237 28 36)">s</text>
  <text x="163" y="535" fill="rgb(255 255 255)">.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(apply</text>
  <text x="251" y="535" fill="rgb(237 28 36)">token)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (t</text>
  <text x="302" y="535" fill="rgb(255 255 255)">his.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError();</text>
  <text x="394" y="535" fill="rgb(24 158 180)"> } } } } public validateOptions(q: any): void { let keys: any[] = Objec</text>
  <text x="465" y="535" fill="rgb(255 255 255)">t.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; </text>
  <text x="525" y="535" fill="rgb(237 28 36)">key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.</text>
  <text x="597" y="535" fill="rgb(255 255 255)">COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transforma</text>
  <text x="0" y="536" fill="rgb(255 255 255)">tionKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void {</text>
  <text x="162" y="536" fill="rgb(237 28 36)"> i</text>
  <text x="164" y="536" fill="rgb(255 255 255)">f (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (</text>
  <text x="253" y="536" fill="rgb(237 28 36)">!this.keysInQuery.includes(q)) { throw new Insight</text>
  <text x="303" y="536" fill="rgb(255 255 255)">Error(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightErr</text>
  <text x="399" y="536" fill="rgb(24 158 180)">or(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new I</text>
  <text x="460" y="536" fill="rgb(255 255 255)">nsightError(); } let keys: any = q.keys; if (!Array.isArray(keys</text>
  <text x="524" y="536" fill="rgb(237 28 36)">) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of k</text>
  <text x="596" y="536" fill="rgb(255 255 255)">eys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q);</text>
  <text x="0" y="537" fill="rgb(255 255 255)"> } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value:</text>
  <text x="163" y="537" fill="rgb(237 28 36)"> a</text>
  <text x="165" y="537" fill="rgb(255 255 255)">ny = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value);</text>
  <text x="255" y="537" fill="rgb(237 28 36)"> break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); brea</text>
  <text x="304" y="537" fill="rgb(255 255 255)">k; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(va</text>
  <text x="404" y="537" fill="rgb(24 158 180)">lue); break; default: throw new InsightError(); } }</text>
  <text x="455" y="537" fill="rgb(255 255 255)"> } private validateNOT(value: any): void { if (typeof value !== &amp;quot;obj</text>
  <text x="523" y="537" fill="rgb(237 28 36)">ect&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private</text>
  <text x="596" y="537" fill="rgb(255 255 255)"> validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2)</text>
  <text x="0" y="538" fill="rgb(255 255 255)"> { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;str</text>
  <text x="163" y="538" fill="rgb(237 28 36)">ing</text>
  <text x="166" y="538" fill="rgb(255 255 255)">&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.valida</text>
  <text x="258" y="538" fill="rgb(237 28 36)">teIdstring(idstring) || !this.sfields.includes</text>
  <text x="304" y="538" fill="rgb(255 255 255)">(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !</text>
  <text x="411" y="538" fill="rgb(24 158 180)">== &amp;quot;object&amp;quot; || Object.keys(value).len</text>
  <text x="448" y="538" fill="rgb(255 255 255)">gth !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(</text>
  <text x="522" y="538" fill="rgb(237 28 36)">value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); }</text>
  <text x="596" y="538" fill="rgb(255 255 255)"> else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError()</text>
  <text x="0" y="539" fill="rgb(255 255 255)">; } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this</text>
  <text x="164" y="539" fill="rgb(237 28 36)">.v</text>
  <text x="166" y="539" fill="rgb(255 255 255)">alidateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this</text>
  <text x="260" y="539" fill="rgb(237 28 36)">.idInQuery.length === 0) { for (let insightDa</text>
  <text x="305" y="539" fill="rgb(255 255 255)">taset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDat</text>
  <text x="423" y="539" fill="rgb(24 158 180)">aset.kind ==</text>
  <text x="435" y="539" fill="rgb(255 255 255)">= InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this</text>
  <text x="521" y="539" fill="rgb(237 28 36)">.coursesfields; } else { this.mfields = this.roommfields; this.sfields = t</text>
  <text x="595" y="539" fill="rgb(255 255 255)">his.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsig</text>
  <text x="0" y="540" fill="rgb(255 255 255)">htFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields</text>
  <text x="164" y="540" fill="rgb(237 28 36)">: s</text>
  <text x="167" y="540" fill="rgb(255 255 255)">tring[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[]</text>
  <text x="262" y="540" fill="rgb(237 28 36)"> = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly</text>
  <text x="306" y="540" fill="rgb(255 255 255)"> roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = </text>
  <text x="520" y="540" fill="rgb(237 28 36)">[&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one</text>
  <text x="595" y="540" fill="rgb(255 255 255)"> id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; pr</text>
  <text x="0" y="541" fill="rgb(255 255 255)">ivate mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationK</text>
  <text x="165" y="541" fill="rgb(237 28 36)">ey </text>
  <text x="168" y="541" fill="rgb(255 255 255)">= []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WH</text>
  <text x="265" y="541" fill="rgb(237 28 36)">ERE || !q.OPTIONS) { throw new InsightErro</text>
  <text x="307" y="541" fill="rgb(255 255 255)">r(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateT</text>
  <text x="519" y="541" fill="rgb(237 28 36)">ransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } publ</text>
  <text x="595" y="541" fill="rgb(255 255 255)">ic validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } priv</text>
  <text x="0" y="542" fill="rgb(255 255 255)">ate validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } </text>
  <text x="165" y="542" fill="rgb(237 28 36)">for </text>
  <text x="169" y="542" fill="rgb(255 255 255)">(let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, </text>
  <text x="267" y="542" fill="rgb(237 28 36)">push it to transformationKey } } private </text>
  <text x="308" y="542" fill="rgb(255 255 255)">validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(spl</text>
  <text x="518" y="542" fill="rgb(237 28 36)">ittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new Insight</text>
  <text x="594" y="542" fill="rgb(255 255 255)">Error(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(ap</text>
  <text x="0" y="543" fill="rgb(255 255 255)">plyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || </text>
  <text x="166" y="543" fill="rgb(237 28 36)">appl</text>
  <text x="170" y="543" fill="rgb(255 255 255)">ykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.</text>
  <text x="270" y="543" fill="rgb(237 28 36)">transformationKey.push(applykey); if (</text>
  <text x="308" y="543" fill="rgb(255 255 255)">Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(ap</text>
  <text x="516" y="543" fill="rgb(237 28 36)">plytoken)) { throw new InsightError(); } let key: string[] = criteria[applytok</text>
  <text x="594" y="543" fill="rgb(255 255 255)">en].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includ</text>
  <text x="0" y="544" fill="rgb(255 255 255)">es(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public </text>
  <text x="167" y="544" fill="rgb(237 28 36)">vali</text>
  <text x="171" y="544" fill="rgb(255 255 255)">dateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;CO</text>
  <text x="272" y="544" fill="rgb(237 28 36)">LUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw ne</text>
  <text x="309" y="544" fill="rgb(255 255 255)">w InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let </text>
  <text x="515" y="544" fill="rgb(237 28 36)">mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformation</text>
  <text x="594" y="544" fill="rgb(255 255 255)">Key.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;strin</text>
  <text x="0" y="545" fill="rgb(255 255 255)">g&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if </text>
  <text x="167" y="545" fill="rgb(237 28 36)">(q.di</text>
  <text x="172" y="545" fill="rgb(255 255 255)">r !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArra</text>
  <text x="275" y="545" fill="rgb(237 28 36)">y(keys) || keys.length &amp;lt; 1) { throw</text>
  <text x="310" y="545" fill="rgb(255 255 255)"> new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new Insight</text>
  <text x="514" y="545" fill="rgb(237 28 36)">Error(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } }</text>
  <text x="594" y="545" fill="rgb(255 255 255)"> } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateA</text>
  <text x="0" y="546" fill="rgb(255 255 255)">NDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); b</text>
  <text x="168" y="546" fill="rgb(237 28 36)">reak;</text>
  <text x="173" y="546" fill="rgb(255 255 255)"> default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;</text>
  <text x="277" y="546" fill="rgb(237 28 36)">object&amp;quot;) { throw new InsightError(</text>
  <text x="311" y="546" fill="rgb(255 255 255)">); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } </text>
  <text x="513" y="546" fill="rgb(237 28 36)">let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { </text>
  <text x="593" y="546" fill="rgb(255 255 255)">throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) </text>
  <text x="0" y="547" fill="rgb(255 255 255)">|| !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !</text>
  <text x="168" y="547" fill="rgb(237 28 36)">== &amp;quot;ob</text>
  <text x="174" y="547" fill="rgb(255 255 255)">ject&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(v</text>
  <text x="280" y="547" fill="rgb(237 28 36)">alue)[0].split(&amp;quot;_&amp;quot;); if (mkey.le</text>
  <text x="312" y="547" fill="rgb(255 255 255)">ngth !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateId</text>
  <text x="512" y="547" fill="rgb(237 28 36)">string(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); }</text>
  <text x="593" y="547" fill="rgb(255 255 255)"> } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): b</text>
  <text x="0" y="548" fill="rgb(255 255 255)">oolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if </text>
  <text x="169" y="548" fill="rgb(237 28 36)">(insig</text>
  <text x="175" y="548" fill="rgb(255 255 255)">htDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.cou</text>
  <text x="282" y="548" fill="rgb(237 28 36)">rsesfields; } else { this.mfiel</text>
  <text x="313" y="548" fill="rgb(255 255 255)">ds = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQue</text>
  <text x="510" y="548" fill="rgb(237 28 36)">ry; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightF</text>
  <text x="593" y="548" fill="rgb(255 255 255)">acade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly ro</text>
  <text x="0" y="549" fill="rgb(255 255 255)">ommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href</text>
  <text x="170" y="549" fill="rgb(237 28 36)">&amp;quot;]; pr</text>
  <text x="176" y="549" fill="rgb(255 255 255)">ivate readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;</text>
  <text x="285" y="549" fill="rgb(237 28 36)">]; private idInQuery: string[</text>
  <text x="314" y="549" fill="rgb(255 255 255)">]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformat</text>
  <text x="509" y="549" fill="rgb(237 28 36)">ion, if there is a transformation private allInsightDataset: InsightDataset[]; priv</text>
  <text x="592" y="549" fill="rgb(255 255 255)">ate mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): </text>
  <text x="0" y="550" fill="rgb(255 255 255)">void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATI</text>
  <text x="170" y="550" fill="rgb(237 28 36)">ONS&amp;quot;) {</text>
  <text x="177" y="550" fill="rgb(255 255 255)"> throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformatio</text>
  <text x="288" y="550" fill="rgb(237 28 36)">ns(q.TRANSFORMATIONS); } t</text>
  <text x="314" y="550" fill="rgb(255 255 255)">his.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new </text>
  <text x="508" y="550" fill="rgb(237 28 36)">InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } privat</text>
  <text x="592" y="550" fill="rgb(255 255 255)">e validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); </text>
  <text x="0" y="551" fill="rgb(255 255 255)">// if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2)</text>
  <text x="171" y="551" fill="rgb(237 28 36)"> { throw</text>
  <text x="179" y="551" fill="rgb(255 255 255)"> new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) ||</text>
  <text x="290" y="551" fill="rgb(237 28 36)"> this.sfields.includes(sp</text>
  <text x="315" y="551" fill="rgb(255 255 255)">littedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one </text>
  <text x="507" y="551" fill="rgb(237 28 36)">element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(appl</text>
  <text x="592" y="551" fill="rgb(255 255 255)">yrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw </text>
  <text x="0" y="552" fill="rgb(255 255 255)">new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: </text>
  <text x="172" y="552" fill="rgb(237 28 36)">string =</text>
  <text x="180" y="552" fill="rgb(255 255 255)"> Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw n</text>
  <text x="293" y="552" fill="rgb(237 28 36)">ew InsightError(); } le</text>
  <text x="316" y="552" fill="rgb(255 255 255)">t key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mf</text>
  <text x="505" y="552" fill="rgb(237 28 36)">ields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.include</text>
  <text x="591" y="552" fill="rgb(255 255 255)">s(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let k</text>
  <text x="0" y="553" fill="rgb(255 255 255)">ey of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } pri</text>
  <text x="172" y="553" fill="rgb(237 28 36)">vate vali</text>
  <text x="181" y="553" fill="rgb(255 255 255)">dateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.t</text>
  <text x="296" y="553" fill="rgb(237 28 36)">ransformationKey.leng</text>
  <text x="317" y="553" fill="rgb(255 255 255)">th &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): v</text>
  <text x="504" y="553" fill="rgb(237 28 36)">oid { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string</text>
  <text x="591" y="553" fill="rgb(255 255 255)">&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys:</text>
  <text x="0" y="554" fill="rgb(255 255 255)"> any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new Insi</text>
  <text x="173" y="554" fill="rgb(237 28 36)">ghtError(</text>
  <text x="182" y="554" fill="rgb(255 255 255)">); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object</text>
  <text x="299" y="554" fill="rgb(237 28 36)">.keys(q).length !==</text>
  <text x="318" y="554" fill="rgb(255 255 255)"> 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let</text>
  <text x="503" y="554" fill="rgb(237 28 36)"> value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateAN</text>
  <text x="591" y="554" fill="rgb(255 255 255)">DOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: a</text>
  <text x="0" y="555" fill="rgb(255 255 255)">ny): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) {</text>
  <text x="174" y="555" fill="rgb(237 28 36)"> throw ne</text>
  <text x="183" y="555" fill="rgb(255 255 255)">w InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys</text>
  <text x="302" y="555" fill="rgb(237 28 36)">(value)[0].split(</text>
  <text x="319" y="555" fill="rgb(255 255 255)">&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str </text>
  <text x="502" y="555" fill="rgb(237 28 36)">!== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) </text>
  <text x="590" y="555" fill="rgb(255 255 255)">|| !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError();</text>
  <text x="0" y="556" fill="rgb(255 255 255)"> } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mke</text>
  <text x="174" y="556" fill="rgb(237 28 36)">y[1]; let n</text>
  <text x="185" y="556" fill="rgb(255 255 255)">um: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.in</text>
  <text x="305" y="556" fill="rgb(237 28 36)">cludes(mfield))</text>
  <text x="320" y="556" fill="rgb(255 255 255)"> { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of va</text>
  <text x="500" y="556" fill="rgb(237 28 36)">lue) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): b</text>
  <text x="590" y="556" fill="rgb(255 255 255)">oolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this</text>
  <text x="0" y="557" fill="rgb(255 255 255)">.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return </text>
  <text x="175" y="557" fill="rgb(237 28 36)">this.idInQu</text>
  <text x="186" y="557" fill="rgb(255 255 255)">ery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightD</text>
  <text x="307" y="557" fill="rgb(237 28 36)">atasetKind, In</text>
  <text x="321" y="557" fill="rgb(255 255 255)">sightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly c</text>
  <text x="499" y="557" fill="rgb(237 28 36)">oursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly ro</text>
  <text x="590" y="557" fill="rgb(255 255 255)">ommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; pri</text>
  <text x="0" y="558" fill="rgb(255 255 255)">vate readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns </text>
  <text x="176" y="558" fill="rgb(237 28 36)">after being</text>
  <text x="187" y="558" fill="rgb(255 255 255)"> validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private all</text>
  <text x="311" y="558" fill="rgb(237 28 36)">InsightData</text>
  <text x="322" y="558" fill="rgb(255 255 255)">set: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.t</text>
  <text x="498" y="558" fill="rgb(237 28 36)">ransformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): </text>
  <text x="590" y="558" fill="rgb(255 255 255)">void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.</text>
  <text x="0" y="559" fill="rgb(255 255 255)">TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;</text>
  <text x="176" y="559" fill="rgb(237 28 36)">undefined&amp;quot; ||</text>
  <text x="189" y="559" fill="rgb(255 255 255)"> typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); th</text>
  <text x="314" y="559" fill="rgb(237 28 36)">is.valida</text>
  <text x="323" y="559" fill="rgb(255 255 255)">teAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at leas</text>
  <text x="496" y="559" fill="rgb(237 28 36)">t one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key);</text>
  <text x="589" y="559" fill="rgb(255 255 255)"> // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0</text>
  <text x="0" y="560" fill="rgb(255 255 255)">]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray</text>
  <text x="177" y="560" fill="rgb(237 28 36)">(q)) { throw </text>
  <text x="190" y="560" fill="rgb(255 255 255)">new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArra</text>
  <text x="317" y="560" fill="rgb(237 28 36)">y(appl</text>
  <text x="323" y="560" fill="rgb(255 255 255)">yrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applyke</text>
  <text x="495" y="560" fill="rgb(237 28 36)">y.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw</text>
  <text x="589" y="560" fill="rgb(255 255 255)"> new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken</text>
  <text x="0" y="561" fill="rgb(255 255 255)">) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if</text>
  <text x="178" y="561" fill="rgb(237 28 36)"> (this.mtoken.</text>
  <text x="192" y="561" fill="rgb(255 255 255)">includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } e</text>
  <text x="320" y="561" fill="rgb(237 28 36)">lse </text>
  <text x="324" y="561" fill="rgb(255 255 255)">if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightErr</text>
  <text x="493" y="561" fill="rgb(237 28 36)">or(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let </text>
  <text x="589" y="561" fill="rgb(255 255 255)">key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw ne</text>
  <text x="0" y="562" fill="rgb(255 255 255)">w InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.valid</text>
  <text x="178" y="562" fill="rgb(237 28 36)">ateKey(mskey); </text>
  <text x="193" y="562" fill="rgb(255 255 255)">} this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else</text>
  <text x="323" y="562" fill="rgb(237 28 36)"/>
  <text x="324" y="562" fill="rgb(255 255 255)">if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new</text>
  <text x="492" y="562" fill="rgb(237 28 36)"> InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let key</text>
  <text x="588" y="562" fill="rgb(255 255 255)">s: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isA</text>
  <text x="0" y="563" fill="rgb(255 255 255)">rray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !==</text>
  <text x="179" y="563" fill="rgb(237 28 36)"> 1) { throw new </text>
  <text x="195" y="563" fill="rgb(255 255 255)">InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: </text>
  <text x="490" y="563" fill="rgb(237 28 36)">this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value:</text>
  <text x="588" y="563" fill="rgb(255 255 255)"> any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { t</text>
  <text x="0" y="564" fill="rgb(255 255 255)">hrow new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sf</text>
  <text x="180" y="564" fill="rgb(237 28 36)">ield: string = s</text>
  <text x="196" y="564" fill="rgb(255 255 255)">key[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any):</text>
  <text x="489" y="564" fill="rgb(237 28 36)"> void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(</text>
  <text x="588" y="564" fill="rgb(255 255 255)">); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;nu</text>
  <text x="0" y="565" fill="rgb(255 255 255)">mber&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) |</text>
  <text x="181" y="565" fill="rgb(237 28 36)">| value.length &amp;lt; </text>
  <text x="198" y="565" fill="rgb(255 255 255)">1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.</text>
  <text x="487" y="565" fill="rgb(237 28 36)">idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = t</text>
  <text x="587" y="565" fill="rgb(255 255 255)">his.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string</text>
  <text x="0" y="566" fill="rgb(255 255 255)">[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfiel</text>
  <text x="181" y="566" fill="rgb(237 28 36)">ds: string[] = [&amp;quot;av</text>
  <text x="200" y="566" fill="rgb(255 255 255)">g&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;addre</text>
  <text x="486" y="566" fill="rgb(237 28 36)">ss&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; </text>
  <text x="587" y="566" fill="rgb(255 255 255)">private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys </text>
  <text x="0" y="567" fill="rgb(255 255 255)">appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDataset</text>
  <text x="182" y="567" fill="rgb(237 28 36)">s: InsightDataset[]</text>
  <text x="201" y="567" fill="rgb(255 255 255)">) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !==</text>
  <text x="484" y="567" fill="rgb(237 28 36)"> &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if </text>
  <text x="587" y="567" fill="rgb(255 255 255)">(q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).leng</text>
  <text x="0" y="568" fill="rgb(255 255 255)">th !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { thro</text>
  <text x="183" y="568" fill="rgb(237 28 36)">w new InsightError()</text>
  <text x="203" y="568" fill="rgb(255 255 255)">; // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(</text>
  <text x="483" y="568" fill="rgb(237 28 36)">&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedK</text>
  <text x="586" y="568" fill="rgb(255 255 255)">ey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and shou</text>
  <text x="0" y="569" fill="rgb(255 255 255)">ld have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object</text>
  <text x="184" y="569" fill="rgb(237 28 36)">.keys(applyrule)[0]; </text>
  <text x="205" y="569" fill="rgb(255 255 255)">let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw </text>
  <text x="481" y="569" fill="rgb(237 28 36)">new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applyt</text>
  <text x="586" y="569" fill="rgb(255 255 255)">oken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring</text>
  <text x="0" y="570" fill="rgb(255 255 255)">(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(</text>
  <text x="184" y="570" fill="rgb(237 28 36)">key[1]) || this.mfields</text>
  <text x="207" y="570" fill="rgb(255 255 255)">.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER</text>
  <text x="479" y="570" fill="rgb(237 28 36)">) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { thro</text>
  <text x="586" y="570" fill="rgb(255 255 255)">w new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private valida</text>
  <text x="0" y="571" fill="rgb(255 255 255)">teOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { i</text>
  <text x="185" y="571" fill="rgb(237 28 36)">f (!q.dir || !q.keys || </text>
  <text x="209" y="571" fill="rgb(255 255 255)">Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keys</text>
  <text x="478" y="571" fill="rgb(237 28 36)">InQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Arra</text>
  <text x="585" y="571" fill="rgb(255 255 255)">y.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Objec</text>
  <text x="0" y="572" fill="rgb(255 255 255)">t.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;L</text>
  <text x="186" y="572" fill="rgb(237 28 36)">T&amp;quot;: case &amp;quot;EQ&amp;quot;: this.valid</text>
  <text x="211" y="572" fill="rgb(255 255 255)">ateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: </text>
  <text x="476" y="572" fill="rgb(237 28 36)">any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1</text>
  <text x="585" y="572" fill="rgb(255 255 255)">) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0];</text>
  <text x="0" y="573" fill="rgb(255 255 255)"> if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new </text>
  <text x="187" y="573" fill="rgb(237 28 36)">InsightError(); } } } } pr</text>
  <text x="213" y="573" fill="rgb(255 255 255)">ivate validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstr</text>
  <text x="474" y="573" fill="rgb(237 28 36)">ing: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !=</text>
  <text x="585" y="573" fill="rgb(255 255 255)">= &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let inn</text>
  <text x="0" y="574" fill="rgb(255 255 255)">erObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsi</text>
  <text x="187" y="574" fill="rgb(237 28 36)">ghtDataset) { if (insightDat</text>
  <text x="215" y="574" fill="rgb(255 255 255)">aset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields;</text>
  <text x="472" y="574" fill="rgb(237 28 36)"> } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): </text>
  <text x="584" y="574" fill="rgb(255 255 255)">string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; priva</text>
  <text x="0" y="575" fill="rgb(255 255 255)">te readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[</text>
  <text x="188" y="575" fill="rgb(237 28 36)">] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;,</text>
  <text x="217" y="575" fill="rgb(255 255 255)"> &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private key</text>
  <text x="471" y="575" fill="rgb(237 28 36)">sInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; //</text>
  <text x="584" y="575" fill="rgb(255 255 255)"> keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery </text>
  <text x="0" y="576" fill="rgb(255 255 255)">= []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key o</text>
  <text x="189" y="576" fill="rgb(237 28 36)">f Object.keys(q)) { if (key !=</text>
  <text x="219" y="576" fill="rgb(255 255 255)">= &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTr</text>
  <text x="469" y="576" fill="rgb(237 28 36)">ansformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q</text>
  <text x="584" y="576" fill="rgb(255 255 255)">).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should h</text>
  <text x="0" y="577" fill="rgb(255 255 255)">as at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: stri</text>
  <text x="190" y="577" fill="rgb(237 28 36)">ng): void { let splittedKey: st</text>
  <text x="221" y="577" fill="rgb(255 255 255)">ring[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } }</text>
  <text x="467" y="577" fill="rgb(237 28 36)"> private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, a</text>
  <text x="583" y="577" fill="rgb(255 255 255)">nd should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if</text>
  <text x="0" y="578" fill="rgb(255 255 255)"> (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteri</text>
  <text x="190" y="578" fill="rgb(237 28 36)">a) || Object.keys(criteria).length</text>
  <text x="224" y="578" fill="rgb(255 255 255)"> &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(</text>
  <text x="465" y="578" fill="rgb(237 28 36)">&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateI</text>
  <text x="583" y="578" fill="rgb(255 255 255)">dstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new Ins</text>
  <text x="0" y="579" fill="rgb(255 255 255)">ightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } }</text>
  <text x="191" y="579" fill="rgb(237 28 36)"> this.validateColumns(q.COLUMNS); i</text>
  <text x="226" y="579" fill="rgb(255 255 255)">f (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.inc</text>
  <text x="462" y="579" fill="rgb(237 28 36)">ludes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } privat</text>
  <text x="582" y="579" fill="rgb(255 255 255)">e validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { thr</text>
  <text x="0" y="580" fill="rgb(255 255 255)">ow new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); </text>
  <text x="192" y="580" fill="rgb(237 28 36)">} for (let anykey of keys) { if (!thi</text>
  <text x="229" y="580" fill="rgb(255 255 255)">s.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } pr</text>
  <text x="460" y="580" fill="rgb(237 28 36)">ivate validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string</text>
  <text x="582" y="580" fill="rgb(255 255 255)"> = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;I</text>
  <text x="0" y="581" fill="rgb(255 255 255)">S&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFil</text>
  <text x="193" y="581" fill="rgb(237 28 36)">ter(value); } private validateIS(value</text>
  <text x="231" y="581" fill="rgb(255 255 255)">: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { thro</text>
  <text x="458" y="581" fill="rgb(237 28 36)">w new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(va</text>
  <text x="582" y="581" fill="rgb(255 255 255)">lue)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: an</text>
  <text x="0" y="582" fill="rgb(255 255 255)">y): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw n</text>
  <text x="194" y="582" fill="rgb(237 28 36)">ew InsightError(); } else { let idstring</text>
  <text x="234" y="582" fill="rgb(255 255 255)">: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } }</text>
  <text x="456" y="582" fill="rgb(237 28 36)"> } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for</text>
  <text x="581" y="582" fill="rgb(255 255 255)"> (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this</text>
  <text x="0" y="583" fill="rgb(255 255 255)">.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields</text>
  <text x="195" y="583" fill="rgb(237 28 36)">; this.sfields = this.roomsfields; } retur</text>
  <text x="237" y="583" fill="rgb(255 255 255)">n true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsight</text>
  <text x="453" y="583" fill="rgb(237 28 36)">Facade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year</text>
  <text x="581" y="583" fill="rgb(255 255 255)">&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;addre</text>
  <text x="0" y="584" fill="rgb(255 255 255)">ss&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the </text>
  <text x="195" y="584" fill="rgb(237 28 36)">query only has one id private keysInQuery: st</text>
  <text x="240" y="584" fill="rgb(255 255 255)">ring[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; pr</text>
  <text x="451" y="584" fill="rgb(237 28 36)">ivate mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.key</text>
  <text x="581" y="584" fill="rgb(255 255 255)">sInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;</text>
  <text x="0" y="585" fill="rgb(255 255 255)">WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q</text>
  <text x="196" y="585" fill="rgb(237 28 36)">.OPTIONS); } public validateTransformations(q: </text>
  <text x="243" y="585" fill="rgb(255 255 255)">any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } p</text>
  <text x="448" y="585" fill="rgb(237 28 36)">rivate validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, an</text>
  <text x="580" y="585" fill="rgb(255 255 255)">d should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;</text>
  <text x="0" y="586" fill="rgb(255 255 255)">); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { th</text>
  <text x="197" y="586" fill="rgb(237 28 36)">row new InsightError(); } } private validateAPPLY</text>
  <text x="246" y="586" fill="rgb(255 255 255)">(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.k</text>
  <text x="445" y="586" fill="rgb(237 28 36)">eys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[app</text>
  <text x="580" y="586" fill="rgb(255 255 255)">lykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new I</text>
  <text x="0" y="587" fill="rgb(255 255 255)">nsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = cri</text>
  <text x="198" y="587" fill="rgb(237 28 36)">teria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) </text>
  <text x="250" y="587" fill="rgb(255 255 255)">{ throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstok</text>
  <text x="442" y="587" fill="rgb(237 28 36)">en.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { thr</text>
  <text x="580" y="587" fill="rgb(255 255 255)">ow new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { thi</text>
  <text x="0" y="588" fill="rgb(255 255 255)">s.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.t</text>
  <text x="199" y="588" fill="rgb(237 28 36)">ransformationKey.includes(mskey)) { throw new InsightE</text>
  <text x="253" y="588" fill="rgb(255 255 255)">rror(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof </text>
  <text x="439" y="588" fill="rgb(237 28 36)">q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !</text>
  <text x="579" y="588" fill="rgb(255 255 255)">== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.</text>
  <text x="0" y="589" fill="rgb(255 255 255)">includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFi</text>
  <text x="200" y="589" fill="rgb(237 28 36)">lter(q); } } } private validateFilter(q: any): void { if </text>
  <text x="257" y="589" fill="rgb(255 255 255)">(Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;:</text>
  <text x="436" y="589" fill="rgb(237 28 36)"> this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); bre</text>
  <text x="579" y="589" fill="rgb(255 255 255)">ak; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void</text>
  <text x="0" y="590" fill="rgb(255 255 255)"> { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length</text>
  <text x="201" y="590" fill="rgb(237 28 36)"> !== 2) { throw new InsightError(); } else { let idstring: s</text>
  <text x="261" y="590" fill="rgb(255 255 255)">tring = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -</text>
  <text x="433" y="590" fill="rgb(237 28 36)">1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTE</text>
  <text x="579" y="590" fill="rgb(255 255 255)">Q(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string </text>
  <text x="0" y="591" fill="rgb(255 255 255)">= mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new Insight</text>
  <text x="201" y="591" fill="rgb(237 28 36)">Error(); } } } private validateANDOR(value: any): void { if (!Ar</text>
  <text x="265" y="591" fill="rgb(255 255 255)">ray.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstrin</text>
  <text x="429" y="591" fill="rgb(237 28 36)">g(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idst</text>
  <text x="578" y="591" fill="rgb(255 255 255)">ring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true</text>
  <text x="0" y="592" fill="rgb(255 255 255)">; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./</text>
  <text x="202" y="592" fill="rgb(237 28 36)">IInsightFacade&amp;quot;; export default class QueryValidator { private reado</text>
  <text x="270" y="592" fill="rgb(255 255 255)">nly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;u</text>
  <text x="425" y="592" fill="rgb(237 28 36)">uid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;n</text>
  <text x="578" y="592" fill="rgb(255 255 255)">ame&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: strin</text>
  <text x="0" y="593" fill="rgb(255 255 255)">g[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[</text>
  <text x="203" y="593" fill="rgb(237 28 36)">]; private mfields: string[]; private sfields: string[]; constructor(ins</text>
  <text x="275" y="593" fill="rgb(255 255 255)">ightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatase</text>
  <text x="420" y="593" fill="rgb(237 28 36)">ts; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot;</text>
  <text x="577" y="593" fill="rgb(255 255 255)"> &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: </text>
  <text x="0" y="594" fill="rgb(255 255 255)">any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } </text>
  <text x="204" y="594" fill="rgb(237 28 36)">private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) </text>
  <text x="281" y="594" fill="rgb(255 255 255)">{ throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key)</text>
  <text x="415" y="594" fill="rgb(237 28 36)">; this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = </text>
  <text x="577" y="594" fill="rgb(255 255 255)">key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAP</text>
  <text x="0" y="595" fill="rgb(255 255 255)">PLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys</text>
  <text x="205" y="595" fill="rgb(237 28 36)">(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Objec</text>
  <text x="287" y="595" fill="rgb(255 255 255)">t.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.tran</text>
  <text x="409" y="595" fill="rgb(237 28 36)">sformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) </text>
  <text x="577" y="595" fill="rgb(255 255 255)">{ throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length </text>
  <text x="0" y="596" fill="rgb(255 255 255)">!== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.incl</text>
  <text x="206" y="596" fill="rgb(237 28 36)">udes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]</text>
  <text x="294" y="596" fill="rgb(255 255 255)">) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): v</text>
  <text x="401" y="596" fill="rgb(237 28 36)">oid { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (</text>
  <text x="576" y="596" fill="rgb(255 255 255)">q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw ne</text>
  <text x="0" y="597" fill="rgb(255 255 255)">w InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;stri</text>
  <text x="207" y="597" fill="rgb(237 28 36)">ng&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !</text>
  <text x="303" y="597" fill="rgb(255 255 255)">q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;</text>
  <text x="392" y="597" fill="rgb(237 28 36)">&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!thi</text>
  <text x="576" y="597" fill="rgb(255 255 255)">s.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: an</text>
  <text x="0" y="598" fill="rgb(255 255 255)">y): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateA</text>
  <text x="208" y="598" fill="rgb(237 28 36)">NDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.valid</text>
  <text x="315" y="598" fill="rgb(255 255 255)">ateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); brea</text>
  <text x="379" y="598" fill="rgb(237 28 36)">k; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(va</text>
  <text x="575" y="598" fill="rgb(255 255 255)">lue: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else</text>
  <text x="0" y="599" fill="rgb(255 255 255)"> { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) |</text>
  <text x="209" y="599" fill="rgb(237 28 36)">| !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(va</text>
  <text x="340" y="599" fill="rgb(255 255 255)">lue: any</text>
  <text x="348" y="599" fill="rgb(237 28 36)">): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let id</text>
  <text x="575" y="599" fill="rgb(255 255 255)">string: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value</text>
  <text x="0" y="600" fill="rgb(255 255 255)">: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boo</text>
  <text x="210" y="600" fill="rgb(237 28 36)">lean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields</text>
  <text x="575" y="600" fill="rgb(255 255 255)">; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class Que</text>
  <text x="0" y="601" fill="rgb(255 255 255)">ryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly room</text>
  <text x="210" y="601" fill="rgb(237 28 36)">mfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private ke</text>
  <text x="574" y="601" fill="rgb(255 255 255)">ysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sf</text>
  <text x="0" y="602" fill="rgb(255 255 255)">ields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): voi</text>
  <text x="211" y="602" fill="rgb(237 28 36)">d { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTra</text>
  <text x="574" y="602" fill="rgb(255 255 255)">nsformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { i</text>
  <text x="0" y="603" fill="rgb(255 255 255)">f (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // i</text>
  <text x="212" y="603" fill="rgb(237 28 36)">f the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } p</text>
  <text x="573" y="603" fill="rgb(255 255 255)">rivate validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new In</text>
  <text x="0" y="604" fill="rgb(255 255 255)">sightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new I</text>
  <text x="213" y="604" fill="rgb(237 28 36)">nsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;)</text>
  <text x="573" y="604" fill="rgb(255 255 255)">; if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.valida</text>
  <text x="0" y="605" fill="rgb(255 255 255)">teIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of </text>
  <text x="214" y="605" fill="rgb(237 28 36)">keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(m</text>
  <text x="573" y="605" fill="rgb(255 255 255)">skey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.include</text>
  <text x="0" y="606" fill="rgb(255 255 255)">s(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = </text>
  <text x="215" y="606" fill="rgb(237 28 36)">q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private va</text>
  <text x="572" y="606" fill="rgb(255 255 255)">lidateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: thi</text>
  <text x="0" y="607" fill="rgb(255 255 255)">s.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): voi</text>
  <text x="216" y="607" fill="rgb(237 28 36)">d { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new Insi</text>
  <text x="572" y="607" fill="rgb(255 255 255)">ghtError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring)</text>
  <text x="0" y="608" fill="rgb(255 255 255)"> || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mk</text>
  <text x="217" y="608" fill="rgb(237 28 36)">ey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private </text>
  <text x="571" y="608" fill="rgb(255 255 255)">validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length </text>
  <text x="0" y="609" fill="rgb(255 255 255)">=== 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfi</text>
  <text x="218" y="609" fill="rgb(237 28 36)">elds; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; expor</text>
  <text x="571" y="609" fill="rgb(255 255 255)">t default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;</text>
  <text x="0" y="610" fill="rgb(255 255 255)">, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readon</text>
  <text x="219" y="610" fill="rgb(237 28 36)">ly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: </text>
  <text x="570" y="610" fill="rgb(255 255 255)">string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPT</text>
  <text x="0" y="611" fill="rgb(255 255 255)">IONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATI</text>
  <text x="220" y="611" fill="rgb(237 28 36)">ONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGRO</text>
  <text x="570" y="611" fill="rgb(255 255 255)">UP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to </text>
  <text x="0" y="612" fill="rgb(255 255 255)">transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.m</text>
  <text x="221" y="612" fill="rgb(237 28 36)">fields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length</text>
  <text x="570" y="612" fill="rgb(255 255 255)"> &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transfor</text>
  <text x="0" y="613" fill="rgb(255 255 255)">mationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mst</text>
  <text x="222" y="613" fill="rgb(237 28 36)">oken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)</text>
  <text x="569" y="613" fill="rgb(255 255 255)">) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot;</text>
  <text x="0" y="614" fill="rgb(255 255 255)"> &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(</text>
  <text x="223" y="614" fill="rgb(237 28 36)">); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!thi</text>
  <text x="569" y="614" fill="rgb(255 255 255)">s.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(k</text>
  <text x="0" y="615" fill="rgb(255 255 255)">eys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw</text>
  <text x="224" y="615" fill="rgb(237 28 36)"> new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); </text>
  <text x="568" y="615" fill="rgb(255 255 255)">break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;o</text>
  <text x="0" y="616" fill="rgb(255 255 255)">bject&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightE</text>
  <text x="225" y="616" fill="rgb(237 28 36)">rror(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.vali</text>
  <text x="568" y="616" fill="rgb(255 255 255)">dateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys</text>
  <text x="0" y="617" fill="rgb(255 255 255)">(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.va</text>
  <text x="226" y="617" fill="rgb(237 28 36)">lidateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if </text>
  <text x="567" y="617" fill="rgb(255 255 255)">(this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this</text>
  <text x="0" y="618" fill="rgb(255 255 255)">.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.id</text>
  <text x="227" y="618" fill="rgb(237 28 36)">InQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: s</text>
  <text x="567" y="618" fill="rgb(255 255 255)">tring[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [</text>
  <text x="0" y="619" fill="rgb(255 255 255)">&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transfor</text>
  <text x="228" y="619" fill="rgb(237 28 36)">mation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (</text>
  <text x="566" y="619" fill="rgb(255 255 255)">!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTra</text>
  <text x="0" y="620" fill="rgb(255 255 255)">nsformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new</text>
  <text x="229" y="620" fill="rgb(237 28 36)"> InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the k</text>
  <text x="566" y="620" fill="rgb(255 255 255)">ey is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splitt</text>
  <text x="0" y="621" fill="rgb(255 255 255)">edKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one e</text>
  <text x="230" y="621" fill="rgb(237 28 36)">lement } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new Insigh</text>
  <text x="565" y="621" fill="rgb(255 255 255)">tError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applyto</text>
  <text x="0" y="622" fill="rgb(255 255 255)">ken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfield</text>
  <text x="231" y="622" fill="rgb(237 28 36)">s.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys</text>
  <text x="565" y="622" fill="rgb(255 255 255)">) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey </text>
  <text x="0" y="623" fill="rgb(255 255 255)">of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { </text>
  <text x="232" y="623" fill="rgb(237 28 36)">if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.</text>
  <text x="564" y="623" fill="rgb(255 255 255)">keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError()</text>
  <text x="0" y="624" fill="rgb(255 255 255)">; } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: a</text>
  <text x="234" y="624" fill="rgb(237 28 36)">ny = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void</text>
  <text x="564" y="624" fill="rgb(255 255 255)"> { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey</text>
  <text x="0" y="625" fill="rgb(255 255 255)">: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string</text>
  <text x="235" y="625" fill="rgb(237 28 36)">&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let m</text>
  <text x="563" y="625" fill="rgb(255 255 255)">key: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(id</text>
  <text x="0" y="626" fill="rgb(255 255 255)">string) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.va</text>
  <text x="236" y="626" fill="rgb(237 28 36)">lidateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursem</text>
  <text x="563" y="626" fill="rgb(255 255 255)">fields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } imp</text>
  <text x="0" y="627" fill="rgb(255 255 255)">ort {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: st</text>
  <text x="237" y="627" fill="rgb(237 28 36)">ring[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private re</text>
  <text x="562" y="627" fill="rgb(255 255 255)">adonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if ther</text>
  <text x="0" y="628" fill="rgb(255 255 255)">e is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey =</text>
  <text x="238" y="628" fill="rgb(237 28 36)"> []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFO</text>
  <text x="562" y="628" fill="rgb(255 255 255)">RMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(</text>
  <text x="0" y="629" fill="rgb(255 255 255)">); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (</text>
  <text x="239" y="629" fill="rgb(237 28 36)">let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; </text>
  <text x="561" y="629" fill="rgb(255 255 255)">(this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for </text>
  <text x="0" y="630" fill="rgb(255 255 255)">(let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || apply</text>
  <text x="240" y="630" fill="rgb(237 28 36)">key.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !</text>
  <text x="561" y="630" fill="rgb(255 255 255)">this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(k</text>
  <text x="0" y="631" fill="rgb(255 255 255)">ey[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public valid</text>
  <text x="241" y="631" fill="rgb(237 28 36)">ateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new Ins</text>
  <text x="560" y="631" fill="rgb(255 255 255)">ightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.i</text>
  <text x="0" y="632" fill="rgb(255 255 255)">sArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir</text>
  <text x="242" y="632" fill="rgb(237 28 36)"> !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(</text>
  <text x="560" y="632" fill="rgb(255 255 255)">q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Obje</text>
  <text x="0" y="633" fill="rgb(255 255 255)">ct.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; d</text>
  <text x="244" y="633" fill="rgb(237 28 36)">efault: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw</text>
  <text x="559" y="633" fill="rgb(255 255 255)"> new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { thr</text>
  <text x="0" y="634" fill="rgb(255 255 255)">ow new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;obje</text>
  <text x="245" y="634" fill="rgb(237 28 36)">ct&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;numbe</text>
  <text x="558" y="634" fill="rgb(255 255 255)">r&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateF</text>
  <text x="0" y="635" fill="rgb(255 255 255)">ilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insight</text>
  <text x="246" y="635" fill="rgb(237 28 36)">Dataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] </text>
  <text x="558" y="635" fill="rgb(255 255 255)">{ return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[]</text>
  <text x="0" y="636" fill="rgb(255 255 255)"> = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; priv</text>
  <text x="247" y="636" fill="rgb(237 28 36)">ate readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys ap</text>
  <text x="557" y="636" fill="rgb(255 255 255)">peared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; </text>
  <text x="0" y="637" fill="rgb(255 255 255)">this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { t</text>
  <text x="248" y="637" fill="rgb(237 28 36)">hrow new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length</text>
  <text x="557" y="637" fill="rgb(255 255 255)"> !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let </text>
  <text x="0" y="638" fill="rgb(255 255 255)">key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw </text>
  <text x="249" y="638" fill="rgb(237 28 36)">new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and shoul</text>
  <text x="556" y="638" fill="rgb(255 255 255)">d have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey</text>
  <text x="0" y="639" fill="rgb(255 255 255)">.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = O</text>
  <text x="251" y="639" fill="rgb(237 28 36)">bject.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(</text>
  <text x="556" y="639" fill="rgb(255 255 255)">key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validat</text>
  <text x="0" y="640" fill="rgb(255 255 255)">eOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private valida</text>
  <text x="252" y="640" fill="rgb(237 28 36)">teColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private valida</text>
  <text x="555" y="640" fill="rgb(255 255 255)">teOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir </text>
  <text x="0" y="641" fill="rgb(255 255 255)">!== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError();</text>
  <text x="253" y="641" fill="rgb(237 28 36)"> } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Obje</text>
  <text x="554" y="641" fill="rgb(255 255 255)">ct.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; </text>
  <text x="0" y="642" fill="rgb(255 255 255)">default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new </text>
  <text x="254" y="642" fill="rgb(237 28 36)">InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]</text>
  <text x="554" y="642" fill="rgb(255 255 255)">; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;ob</text>
  <text x="0" y="643" fill="rgb(255 255 255)">ject&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let nu</text>
  <text x="255" y="643" fill="rgb(237 28 36)">m: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let i</text>
  <text x="553" y="643" fill="rgb(255 255 255)">nnerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insi</text>
  <text x="0" y="644" fill="rgb(255 255 255)">ghtDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuer</text>
  <text x="257" y="644" fill="rgb(237 28 36)">y.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; pri</text>
  <text x="553" y="644" fill="rgb(255 255 255)">vate readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; </text>
  <text x="0" y="645" fill="rgb(255 255 255)">private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being v</text>
  <text x="258" y="645" fill="rgb(237 28 36)">alidated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQue</text>
  <text x="552" y="645" fill="rgb(255 255 255)">ry = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;</text>
  <text x="0" y="646" fill="rgb(255 255 255)">) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || </text>
  <text x="259" y="646" fill="rgb(237 28 36)">typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and shou</text>
  <text x="551" y="646" fill="rgb(255 255 255)">ld has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { </text>
  <text x="0" y="647" fill="rgb(255 255 255)">throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw n</text>
  <text x="260" y="647" fill="rgb(237 28 36)">ew InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]</text>
  <text x="551" y="647" fill="rgb(255 255 255)">; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: st</text>
  <text x="0" y="648" fill="rgb(255 255 255)">ring = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.i</text>
  <text x="262" y="648" fill="rgb(237 28 36)">ncludes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw ne</text>
  <text x="550" y="648" fill="rgb(255 255 255)">w InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } priva</text>
  <text x="0" y="649" fill="rgb(255 255 255)">te validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); }</text>
  <text x="263" y="649" fill="rgb(237 28 36)"> this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2)</text>
  <text x="549" y="649" fill="rgb(255 255 255)"> { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new Insig</text>
  <text x="0" y="650" fill="rgb(255 255 255)">htError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new </text>
  <text x="264" y="650" fill="rgb(237 28 36)">InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; c</text>
  <text x="549" y="650" fill="rgb(255 255 255)">ase &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) {</text>
  <text x="0" y="651" fill="rgb(255 255 255)"> throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = s</text>
  <text x="265" y="651" fill="rgb(237 28 36)">key[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(va</text>
  <text x="548" y="651" fill="rgb(255 255 255)">lue: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mke</text>
  <text x="0" y="652" fill="rgb(255 255 255)">y[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; </text>
  <text x="267" y="652" fill="rgb(237 28 36)">1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring</text>
  <text x="547" y="652" fill="rgb(255 255 255)">) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return</text>
  <text x="0" y="653" fill="rgb(255 255 255)"> this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;a</text>
  <text x="268" y="653" fill="rgb(237 28 36)">vg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;</text>
  <text x="547" y="653" fill="rgb(255 255 255)">, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in column</text>
  <text x="0" y="654" fill="rgb(255 255 255)">s after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[</text>
  <text x="269" y="654" fill="rgb(237 28 36)">]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; </text>
  <text x="546" y="654" fill="rgb(255 255 255)">key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP ===</text>
  <text x="0" y="655" fill="rgb(255 255 255)"> &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(</text>
  <text x="271" y="655" fill="rgb(237 28 36)">); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key</text>
  <text x="545" y="655" fill="rgb(255 255 255)">.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isAr</text>
  <text x="0" y="656" fill="rgb(255 255 255)">ray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]</text>
  <text x="272" y="656" fill="rgb(237 28 36)">; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { </text>
  <text x="544" y="656" fill="rgb(255 255 255)">throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); </text>
  <text x="0" y="657" fill="rgb(255 255 255)">} if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfie</text>
  <text x="273" y="657" fill="rgb(237 28 36)">lds.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.O</text>
  <text x="544" y="657" fill="rgb(255 255 255)">RDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.v</text>
  <text x="0" y="658" fill="rgb(255 255 255)">alidateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys </text>
  <text x="275" y="658" fill="rgb(237 28 36)">|| Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.</text>
  <text x="543" y="658" fill="rgb(255 255 255)">keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).lengt</text>
  <text x="0" y="659" fill="rgb(255 255 255)">h !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.v</text>
  <text x="276" y="659" fill="rgb(237 28 36)">alidateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(valu</text>
  <text x="542" y="659" fill="rgb(255 255 255)">e: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; </text>
  <text x="0" y="660" fill="rgb(255 255 255)">let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } </text>
  <text x="278" y="660" fill="rgb(237 28 36)">} private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let ids</text>
  <text x="541" y="660" fill="rgb(255 255 255)">tring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(v</text>
  <text x="0" y="661" fill="rgb(255 255 255)">alue) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insig</text>
  <text x="279" y="661" fill="rgb(237 28 36)">htDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields;</text>
  <text x="541" y="661" fill="rgb(255 255 255)"> } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly cour</text>
  <text x="0" y="662" fill="rgb(255 255 255)">semfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;short</text>
  <text x="280" y="662" fill="rgb(237 28 36)">name&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private key</text>
  <text x="540" y="662" fill="rgb(255 255 255)">sInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insigh</text>
  <text x="0" y="663" fill="rgb(255 255 255)">tDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (</text>
  <text x="282" y="663" fill="rgb(237 28 36)">key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTra</text>
  <text x="539" y="663" fill="rgb(255 255 255)">nsformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; </text>
  <text x="0" y="664" fill="rgb(255 255 255)">1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splitted</text>
  <text x="283" y="664" fill="rgb(237 28 36)">Key: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } p</text>
  <text x="538" y="664" fill="rgb(255 255 255)">rivate validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: strin</text>
  <text x="0" y="665" fill="rgb(255 255 255)">g = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria</text>
  <text x="285" y="665" fill="rgb(237 28 36)">).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;)</text>
  <text x="538" y="665" fill="rgb(255 255 255)">; if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields</text>
  <text x="0" y="666" fill="rgb(255 255 255)">.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.CO</text>
  <text x="286" y="666" fill="rgb(237 28 36)">LUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(</text>
  <text x="537" y="666" fill="rgb(255 255 255)">mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); }</text>
  <text x="0" y="667" fill="rgb(255 255 255)"> } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) </text>
  <text x="288" y="667" fill="rgb(237 28 36)">{ if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private v</text>
  <text x="536" y="667" fill="rgb(255 255 255)">alidateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;</text>
  <text x="0" y="668" fill="rgb(255 255 255)">GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private valid</text>
  <text x="289" y="668" fill="rgb(237 28 36)">ateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new In</text>
  <text x="535" y="668" fill="rgb(255 255 255)">sightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield))</text>
  <text x="0" y="669" fill="rgb(255 255 255)"> { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { </text>
  <text x="291" y="669" fill="rgb(237 28 36)">let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } privat</text>
  <text x="534" y="669" fill="rgb(255 255 255)">e validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of</text>
  <text x="0" y="670" fill="rgb(255 255 255)"> this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsf</text>
  <text x="292" y="670" fill="rgb(237 28 36)">ields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; ex</text>
  <text x="533" y="670" fill="rgb(255 255 255)">port default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsf</text>
  <text x="0" y="671" fill="rgb(255 255 255)">ields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private </text>
  <text x="294" y="671" fill="rgb(237 28 36)">keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields</text>
  <text x="533" y="671" fill="rgb(255 255 255)">: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); }</text>
  <text x="0" y="672" fill="rgb(255 255 255)"> for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTr</text>
  <text x="295" y="672" fill="rgb(237 28 36)">ansformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validate</text>
  <text x="532" y="672" fill="rgb(255 255 255)">GROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private valid</text>
  <text x="0" y="673" fill="rgb(255 255 255)">ateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } pri</text>
  <text x="297" y="673" fill="rgb(237 28 36)">vate validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).le</text>
  <text x="531" y="673" fill="rgb(255 255 255)">ngth &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array</text>
  <text x="0" y="674" fill="rgb(255 255 255)">.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); i</text>
  <text x="298" y="674" fill="rgb(237 28 36)">f (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applyto</text>
  <text x="530" y="674" fill="rgb(255 255 255)">ken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new In</text>
  <text x="0" y="675" fill="rgb(255 255 255)">sightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)</text>
  <text x="300" y="675" fill="rgb(237 28 36)">) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if </text>
  <text x="529" y="675" fill="rgb(255 255 255)">(!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw ne</text>
  <text x="0" y="676" fill="rgb(255 255 255)">w InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFi</text>
  <text x="302" y="676" fill="rgb(237 28 36)">lter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(val</text>
  <text x="528" y="676" fill="rgb(255 255 255)">ue); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError();</text>
  <text x="0" y="677" fill="rgb(255 255 255)"> } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(</text>
  <text x="303" y="677" fill="rgb(237 28 36)">); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !thi</text>
  <text x="527" y="677" fill="rgb(255 255 255)">s.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.len</text>
  <text x="0" y="678" fill="rgb(255 255 255)">gth !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDO</text>
  <text x="305" y="678" fill="rgb(237 28 36)">R(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean</text>
  <text x="526" y="678" fill="rgb(255 255 255)"> { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfiel</text>
  <text x="0" y="679" fill="rgb(255 255 255)">ds = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default clas</text>
  <text x="307" y="679" fill="rgb(237 28 36)">s QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfi</text>
  <text x="525" y="679" fill="rgb(255 255 255)">elds: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string</text>
  <text x="0" y="680" fill="rgb(255 255 255)">[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; privat</text>
  <text x="308" y="680" fill="rgb(237 28 36)">e sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void</text>
  <text x="524" y="680" fill="rgb(255 255 255)"> { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } </text>
  <text x="0" y="681" fill="rgb(255 255 255)">this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void {</text>
  <text x="310" y="681" fill="rgb(237 28 36)"> if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // </text>
  <text x="523" y="681" fill="rgb(255 255 255)">if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(</text>
  <text x="0" y="682" fill="rgb(255 255 255)">splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new In</text>
  <text x="312" y="682" fill="rgb(237 28 36)">sightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw ne</text>
  <text x="522" y="682" fill="rgb(255 255 255)">w InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); }</text>
  <text x="0" y="683" fill="rgb(255 255 255)"> let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validat</text>
  <text x="313" y="683" fill="rgb(237 28 36)">eIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let ke</text>
  <text x="521" y="683" fill="rgb(255 255 255)">y of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.</text>
  <text x="0" y="684" fill="rgb(255 255 255)">length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q</text>
  <text x="315" y="684" fill="rgb(237 28 36)">)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys:</text>
  <text x="520" y="684" fill="rgb(255 255 255)"> any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).lengt</text>
  <text x="0" y="685" fill="rgb(255 255 255)">h !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.val</text>
  <text x="317" y="685" fill="rgb(237 28 36)">idateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: </text>
  <text x="519" y="685" fill="rgb(255 255 255)">any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].</text>
  <text x="0" y="686" fill="rgb(255 255 255)">split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !th</text>
  <text x="319" y="686" fill="rgb(237 28 36)">is.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(</text>
  <text x="518" y="686" fill="rgb(255 255 255)">); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(m</text>
  <text x="0" y="687" fill="rgb(255 255 255)">field)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { </text>
  <text x="321" y="687" fill="rgb(237 28 36)">for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = </text>
  <text x="516" y="687" fill="rgb(255 255 255)">this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDataset</text>
  <text x="0" y="688" fill="rgb(255 255 255)">Kind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]</text>
  <text x="322" y="688" fill="rgb(237 28 36)">; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]</text>
  <text x="515" y="688" fill="rgb(255 255 255)">; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allIn</text>
  <text x="0" y="689" fill="rgb(255 255 255)">sightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { thro</text>
  <text x="324" y="689" fill="rgb(237 28 36)">w new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); </text>
  <text x="514" y="689" fill="rgb(255 255 255)">if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); t</text>
  <text x="0" y="690" fill="rgb(255 255 255)">his.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformation</text>
  <text x="326" y="690" fill="rgb(237 28 36)">Key } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splitt</text>
  <text x="513" y="690" fill="rgb(255 255 255)">edKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.is</text>
  <text x="0" y="691" fill="rgb(255 255 255)">Array(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(a</text>
  <text x="328" y="691" fill="rgb(237 28 36)">pplykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(ap</text>
  <text x="512" y="691" fill="rgb(255 255 255)">plytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError()</text>
  <text x="0" y="692" fill="rgb(255 255 255)">; } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER</text>
  <text x="330" y="692" fill="rgb(237 28 36)">&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) </text>
  <text x="510" y="692" fill="rgb(255 255 255)">{ throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError</text>
  <text x="0" y="693" fill="rgb(255 255 255)">(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length </text>
  <text x="332" y="693" fill="rgb(237 28 36)">&amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if</text>
  <text x="509" y="693" fill="rgb(255 255 255)"> (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { cas</text>
  <text x="0" y="694" fill="rgb(255 255 255)">e &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new In</text>
  <text x="334" y="694" fill="rgb(237 28 36)">sightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).lengt</text>
  <text x="508" y="694" fill="rgb(255 255 255)">h !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if </text>
  <text x="0" y="695" fill="rgb(255 255 255)">((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); i</text>
  <text x="336" y="695" fill="rgb(237 28 36)">f (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((type</text>
  <text x="506" y="695" fill="rgb(255 255 255)">of num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private val</text>
  <text x="0" y="696" fill="rgb(255 255 255)">idateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { t</text>
  <text x="338" y="696" fill="rgb(237 28 36)">his.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdIn</text>
  <text x="505" y="696" fill="rgb(255 255 255)">Query(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;ti</text>
  <text x="0" y="697" fill="rgb(255 255 255)">tle&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: </text>
  <text x="341" y="697" fill="rgb(237 28 36)">string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: st</text>
  <text x="504" y="697" fill="rgb(255 255 255)">ring[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDat</text>
  <text x="0" y="698" fill="rgb(255 255 255)">asets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS)</text>
  <text x="343" y="698" fill="rgb(237 28 36)">; } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || O</text>
  <text x="502" y="698" fill="rgb(255 255 255)">bject.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); </text>
  <text x="0" y="699" fill="rgb(255 255 255)">this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.include</text>
  <text x="345" y="699" fill="rgb(237 28 36)">s(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be</text>
  <text x="501" y="699" fill="rgb(255 255 255)"> an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformati</text>
  <text x="0" y="700" fill="rgb(255 255 255)">onKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); }</text>
  <text x="347" y="700" fill="rgb(237 28 36)"> let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(</text>
  <text x="499" y="700" fill="rgb(255 255 255)">this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: </text>
  <text x="0" y="701" fill="rgb(255 255 255)">any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.len</text>
  <text x="350" y="701" fill="rgb(237 28 36)">gth &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(msk</text>
  <text x="497" y="701" fill="rgb(255 255 255)">ey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { thr</text>
  <text x="0" y="702" fill="rgb(255 255 255)">ow new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !==</text>
  <text x="352" y="702" fill="rgb(237 28 36)"> 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else {</text>
  <text x="496" y="702" fill="rgb(255 255 255)"> let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); </text>
  <text x="0" y="703" fill="rgb(255 255 255)">} } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_</text>
  <text x="355" y="703" fill="rgb(237 28 36)">&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any </text>
  <text x="494" y="703" fill="rgb(255 255 255)">= Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length </text>
  <text x="0" y="704" fill="rgb(255 255 255)">!== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { </text>
  <text x="357" y="704" fill="rgb(237 28 36)">throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new In</text>
  <text x="492" y="704" fill="rgb(255 255 255)">sightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetK</text>
  <text x="0" y="705" fill="rgb(255 255 255)">ind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, Insight</text>
  <text x="360" y="705" fill="rgb(237 28 36)">Error} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;</text>
  <text x="490" y="705" fill="rgb(255 255 255)">fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] =</text>
  <text x="0" y="706" fill="rgb(255 255 255)"> [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: In</text>
  <text x="363" y="706" fill="rgb(237 28 36)">sightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.id</text>
  <text x="489" y="706" fill="rgb(255 255 255)">InQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } t</text>
  <text x="0" y="707" fill="rgb(255 255 255)">his.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q</text>
  <text x="366" y="707" fill="rgb(237 28 36)">.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q </text>
  <text x="487" y="707" fill="rgb(255 255 255)">should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(t</text>
  <text x="0" y="708" fill="rgb(255 255 255)">his.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || O</text>
  <text x="368" y="708" fill="rgb(237 28 36)">bject.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; le</text>
  <text x="484" y="708" fill="rgb(255 255 255)">t criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if</text>
  <text x="0" y="709" fill="rgb(255 255 255)"> (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.msto</text>
  <text x="371" y="709" fill="rgb(237 28 36)">ken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfiel</text>
  <text x="482" y="709" fill="rgb(255 255 255)">ds.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { </text>
  <text x="0" y="710" fill="rgb(255 255 255)">if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === </text>
  <text x="375" y="710" fill="rgb(237 28 36)">&amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.ke</text>
  <text x="480" y="710" fill="rgb(255 255 255)">ys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateW</text>
  <text x="0" y="711" fill="rgb(255 255 255)">here(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.valida</text>
  <text x="378" y="711" fill="rgb(237 28 36)">teANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: </text>
  <text x="478" y="711" fill="rgb(255 255 255)">this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Ob</text>
  <text x="0" y="712" fill="rgb(255 255 255)">ject.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) |</text>
  <text x="382" y="712" fill="rgb(237 28 36)">| !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightErro</text>
  <text x="475" y="712" fill="rgb(255 255 255)">r(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(</text>
  <text x="0" y="713" fill="rgb(255 255 255)">value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boole</text>
  <text x="385" y="713" fill="rgb(237 28 36)">an { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDatas</text>
  <text x="472" y="713" fill="rgb(255 255 255)">et) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring);</text>
  <text x="0" y="714" fill="rgb(255 255 255)"> } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields</text>
  <text x="390" y="714" fill="rgb(237 28 36)">: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = </text>
  <text x="469" y="714" fill="rgb(255 255 255)">[&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private tra</text>
  <text x="0" y="715" fill="rgb(255 255 255)">nsformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q</text>
  <text x="394" y="715" fill="rgb(237 28 36)"> || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key o</text>
  <text x="466" y="715" fill="rgb(255 255 255)">f Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === </text>
  <text x="0" y="716" fill="rgb(255 255 255)">&amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is v</text>
  <text x="399" y="716" fill="rgb(237 28 36)">alid, push it to transformationKey } } private validateKey(key:</text>
  <text x="462" y="716" fill="rgb(255 255 255)"> string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError();</text>
  <text x="0" y="717" fill="rgb(255 255 255)"> // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } th</text>
  <text x="405" y="717" fill="rgb(237 28 36)">is.transformationKey.push(applykey); if (Array.isArr</text>
  <text x="457" y="717" fill="rgb(255 255 255)">ay(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytok</text>
  <text x="0" y="718" fill="rgb(255 255 255)">en)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUM</text>
  <text x="413" y="718" fill="rgb(237 28 36)">NS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new I</text>
  <text x="450" y="718" fill="rgb(255 255 255)">nsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQue</text>
  <text x="0" y="719" fill="rgb(255 255 255)">ry.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || key</text>
  <text x="427" y="719" fill="rgb(237 28 36)">s.length </text>
  <text x="436" y="719" fill="rgb(255 255 255)">&amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError()</text>
  <text x="0" y="720" fill="rgb(255 255 255)">; } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let s</text>
  <text x="0" y="721" fill="rgb(255 255 255)">tr: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw </text>
  <text x="0" y="722" fill="rgb(255 255 255)">new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass</text>
  <text x="0" y="723" fill="rgb(255 255 255)">&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this</text>
  <text x="0" y="724" fill="rgb(255 255 255)">.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q</text>
  <text x="0" y="725" fill="rgb(255 255 255)"> should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let </text>
  <text x="0" y="726" fill="rgb(255 255 255)">criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.i</text>
  <text x="0" y="727" fill="rgb(255 255 255)">ncludes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || </text>
  <text x="0" y="728" fill="rgb(255 255 255)">Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.val</text>
  <text x="0" y="729" fill="rgb(255 255 255)">idateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } </text>
  <text x="0" y="730" fill="rgb(255 255 255)">} private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insi</text>
  <text x="0" y="731" fill="rgb(255 255 255)">ghtDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;sho</text>
  <text x="0" y="732" fill="rgb(255 255 255)">rtname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { </text>
  <text x="0" y="733" fill="rgb(255 255 255)">if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let spl</text>
  <text x="0" y="734" fill="rgb(255 255 255)">ittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(c</text>
  <text x="0" y="735" fill="rgb(255 255 255)">riteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColu</text>
  <text x="0" y="736" fill="rgb(255 255 255)">mns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey</text>
  <text x="0" y="737" fill="rgb(255 255 255)"> of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } pr</text>
  <text x="0" y="738" fill="rgb(255 255 255)">ivate validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError</text>
  <text x="0" y="739" fill="rgb(255 255 255)">(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields</text>
  <text x="0" y="740" fill="rgb(255 255 255)"> = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has</text>
  <text x="0" y="741" fill="rgb(255 255 255)"> one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } </text>
  <text x="0" y="742" fill="rgb(255 255 255)">public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new Insi</text>
  <text x="0" y="743" fill="rgb(255 255 255)">ghtError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[apply</text>
  <text x="0" y="744" fill="rgb(255 255 255)">token].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformat</text>
  <text x="0" y="745" fill="rgb(255 255 255)">ionKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); </text>
  <text x="0" y="746" fill="rgb(255 255 255)">} } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) </text>
  <text x="0" y="747" fill="rgb(255 255 255)">{ throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError();</text>
  <text x="0" y="748" fill="rgb(255 255 255)"> } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsigh</text>
  <text x="0" y="749" fill="rgb(255 255 255)">tFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; pri</text>
  <text x="0" y="750" fill="rgb(255 255 255)">vate mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } priva</text>
  <text x="0" y="751" fill="rgb(255 255 255)">te validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(app</text>
  <text x="0" y="752" fill="rgb(255 255 255)">lyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.include</text>
  <text x="0" y="753" fill="rgb(255 255 255)">s(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string</text>
  <text x="0" y="754" fill="rgb(255 255 255)">&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateAN</text>
  <text x="0" y="755" fill="rgb(255 255 255)">DOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) |</text>
  <text x="0" y="756" fill="rgb(255 255 255)">| !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): bo</text>
  <text x="0" y="757" fill="rgb(255 255 255)">olean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roo</text>
  <text x="0" y="758" fill="rgb(255 255 255)">mmfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): v</text>
  <text x="0" y="759" fill="rgb(255 255 255)">oid { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); /</text>
  <text x="0" y="760" fill="rgb(255 255 255)">/ if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw n</text>
  <text x="0" y="761" fill="rgb(255 255 255)">ew InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let ke</text>
  <text x="0" y="762" fill="rgb(255 255 255)">y of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: </text>
  <text x="0" y="763" fill="rgb(255 255 255)">any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: an</text>
  <text x="0" y="764" fill="rgb(255 255 255)">y): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); </text>
  <text x="0" y="765" fill="rgb(255 255 255)">} let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.</text>
  <text x="0" y="766" fill="rgb(255 255 255)">coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; priv</text>
  <text x="0" y="767" fill="rgb(255 255 255)">ate readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.T</text>
  <text x="0" y="768" fill="rgb(255 255 255)">RANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]</text>
  <text x="0" y="769" fill="rgb(255 255 255)">) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken)</text>
  <text x="0" y="770" fill="rgb(255 255 255)"> &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new</text>
  <text x="0" y="771" fill="rgb(255 255 255)"> InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isAr</text>
  <text x="0" y="772" fill="rgb(255 255 255)">ray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { th</text>
  <text x="0" y="773" fill="rgb(255 255 255)">row new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;num</text>
  <text x="0" y="774" fill="rgb(255 255 255)">ber&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[</text>
  <text x="0" y="775" fill="rgb(255 255 255)">] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys a</text>
  <text x="0" y="776" fill="rgb(255 255 255)">ppeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).lengt</text>
  <text x="0" y="777" fill="rgb(255 255 255)">h !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and shoul</text>
  <text x="0" y="778" fill="rgb(255 255 255)">d have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(</text>
  <text x="0" y="779" fill="rgb(255 255 255)">key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validat</text>
  <text x="0" y="780" fill="rgb(255 255 255)">eOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object</text>
  <text x="0" y="781" fill="rgb(255 255 255)">.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; </text>
  <text x="0" y="782" fill="rgb(255 255 255)">if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let inne</text>
  <text x="0" y="783" fill="rgb(255 255 255)">rObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; privat</text>
  <text x="0" y="784" fill="rgb(255 255 255)">e readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery =</text>
  <text x="0" y="785" fill="rgb(255 255 255)"> []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should ha</text>
  <text x="0" y="786" fill="rgb(255 255 255)">s at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if </text>
  <text x="0" y="787" fill="rgb(255 255 255)">(applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new Insi</text>
  <text x="0" y="788" fill="rgb(255 255 255)">ghtError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { thro</text>
  <text x="0" y="789" fill="rgb(255 255 255)">w new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS</text>
  <text x="0" y="790" fill="rgb(255 255 255)">&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any</text>
  <text x="0" y="791" fill="rgb(255 255 255)">): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.</text>
  <text x="0" y="792" fill="rgb(255 255 255)">idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;addres</text>
  <text x="0" y="793" fill="rgb(255 255 255)">s&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;W</text>
  <text x="0" y="794" fill="rgb(255 255 255)">HERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;)</text>
  <text x="0" y="795" fill="rgb(255 255 255)">; if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new In</text>
  <text x="0" y="796" fill="rgb(255 255 255)">sightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this</text>
  <text x="0" y="797" fill="rgb(255 255 255)">.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.i</text>
  <text x="0" y="798" fill="rgb(255 255 255)">ncludes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void </text>
  <text x="0" y="799" fill="rgb(255 255 255)">{ if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string =</text>
  <text x="0" y="800" fill="rgb(255 255 255)"> mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true;</text>
  <text x="0" y="801" fill="rgb(255 255 255)"> } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string</text>
  <text x="0" y="802" fill="rgb(255 255 255)">[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: a</text>
  <text x="0" y="803" fill="rgb(255 255 255)">ny): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPP</text>
  <text x="0" y="804" fill="rgb(255 255 255)">LY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !</text>
  <text x="0" y="805" fill="rgb(255 255 255)">== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new</text>
  <text x="0" y="806" fill="rgb(255 255 255)"> InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any</text>
  <text x="0" y="807" fill="rgb(255 255 255)">): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else </text>
  <text x="0" y="808" fill="rgb(255 255 255)">{ let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value:</text>
  <text x="0" y="809" fill="rgb(255 255 255)"> any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class Quer</text>
  <text x="0" y="810" fill="rgb(255 255 255)">yValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfi</text>
  <text x="0" y="811" fill="rgb(255 255 255)">elds: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if</text>
  <text x="0" y="812" fill="rgb(255 255 255)"> (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new Ins</text>
  <text x="0" y="813" fill="rgb(255 255 255)">ightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validat</text>
  <text x="0" y="814" fill="rgb(255 255 255)">eIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes</text>
  <text x="0" y="815" fill="rgb(255 255 255)">(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this</text>
  <text x="0" y="816" fill="rgb(255 255 255)">.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) </text>
  <text x="0" y="817" fill="rgb(255 255 255)">|| !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length =</text>
  <text x="0" y="818" fill="rgb(255 255 255)">== 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;,</text>
  <text x="0" y="819" fill="rgb(255 255 255)"> &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTI</text>
  <text x="0" y="820" fill="rgb(255 255 255)">ONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to t</text>
  <text x="0" y="821" fill="rgb(255 255 255)">ransformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transform</text>
  <text x="0" y="822" fill="rgb(255 255 255)">ationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; </text>
  <text x="0" y="823" fill="rgb(255 255 255)">&amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(ke</text>
  <text x="0" y="824" fill="rgb(255 255 255)">ys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &amp;quot;AND&amp;quot;: case &amp;quot;OR&amp;quot;: this.validateANDOR(value); break; case &amp;quot;NOT&amp;quot;: this.validateNOT(value); break; case &amp;quot;GT&amp;quot;: case &amp;quot;LT&amp;quot;: case &amp;quot;EQ&amp;quot;: this.validateGTLTEQ(value); break; case &amp;quot;IS&amp;quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &amp;quot;ob</text>
  <text x="0" y="825" fill="rgb(255 255 255)">ject&amp;quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &amp;quot;object&amp;quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&amp;quot;_&amp;quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &amp;quot;string&amp;quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&amp;quot;*&amp;quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &amp;quot;object&amp;quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(</text>
  <text x="0" y="826" fill="rgb(255 255 255)">value)[0].split(&amp;quot;_&amp;quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &amp;quot;number&amp;quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &amp;lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.</text>
  <text x="0" y="827" fill="rgb(255 255 255)">coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &amp;quot;./IInsightFacade&amp;quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&amp;quot;avg&amp;quot;, &amp;quot;pass&amp;quot;, &amp;quot;fail&amp;quot;, &amp;quot;audit&amp;quot;, &amp;quot;year&amp;quot;]; private readonly coursesfields: string[] = [&amp;quot;dept&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;instructor&amp;quot;, &amp;quot;title&amp;quot;, &amp;quot;uuid&amp;quot;]; private readonly roommfields: string[] = [&amp;quot;lat&amp;quot;, &amp;quot;lon&amp;quot;, &amp;quot;seats&amp;quot;]; private readonly roomsfields: string[] = [&amp;quot;fullname&amp;quot;, &amp;quot;shortname&amp;quot;, &amp;quot;number&amp;quot; , &amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;, &amp;quot;type&amp;quot;, &amp;quot;furniture&amp;quot;, &amp;quot;href&amp;quot;]; private readonly mtoken: string[] = [&amp;quot;MAX&amp;quot;, &amp;quot;MIN&amp;quot;, &amp;quot;AVG&amp;quot;, &amp;quot;SUM&amp;quot;]; private readonly mstoken: string[] = [&amp;quot;</text>
  <text x="0" y="828" fill="rgb(255 255 255)">COUNT&amp;quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &amp;quot;OPTIONS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;WHERE&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;TRANSFORMATIONS&amp;quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTran</text>
  <text x="0" y="829" fill="rgb(255 255 255)">sformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &amp;quot;undefined&amp;quot; || typeof q.APPLY === &amp;quot;undefined&amp;quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &amp;lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&amp;quot;_&amp;quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;amp;&amp;amp; (this.mfields.includes(splitte</text>
  <text x="0" y="830" fill="rgb(255 255 255)">dKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &amp;gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&amp;quot;_&amp;quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &amp;gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;amp;&amp;amp; !this.mstoken.includes(applytok</text>
  <text x="0" y="831" fill="rgb(255 255 255)">en)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&amp;quot;_&amp;quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;amp;&amp;amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &amp;quot;COLUMNS&amp;quot; &amp;amp;&amp;amp; key !== &amp;quot;ORDER&amp;quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &amp;lt; 1) { throw new InsightError(); } for (let mskey o</text>
  <text x="0" y="832" fill="rgb(255 255 255)">f q) { if (this.transformationKey.length &amp;gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &amp;quot;string&amp;quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &amp;quot;UP&amp;quot; &amp;amp;&amp;amp; q.dir !== &amp;quot;DOWN&amp;quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &amp;lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError();</text>
</svg>