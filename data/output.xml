<svg version="1.1"
                        viewBox="0 0 83300 83300"
                        width="83300" height="83300"
                        xml:space="preserve"
                        style="font-family: 'Source Code Pro'; font-size: 5px; font-weight: 500; white-space: normal;"
                        xmlns="http://www.w3.org/2000/svg"><text x="0" y="0"  fill="rgb(255 255 255)">import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if t</text><text x="0" y="5"  fill="rgb(255 255 255)">here is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightErr</text><text x="0" y="10"  fill="rgb(255 255 255)">or(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } f</text><text x="0" y="15"  fill="rgb(255 255 255)">or (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.include</text><text x="0" y="20"  fill="rgb(255 255 255)">s(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Arra</text><text x="0" y="25"  fill="rgb(255 255 255)">y.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = O</text><text x="0" y="30"  fill="rgb(255 255 255)">bject.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { </text><text x="0" y="35"  fill="rgb(255 255 255)">throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.valida</text><text x="0" y="40"  fill="rgb(255 255 255)">teFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: strin</text><text x="0" y="45"  fill="rgb(255 255 255)">g[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = [</text><text x="0" y="50"  fill="rgb(255 255 255)">]; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (l</text><text x="0" y="55"  fill="rgb(255 255 255)">et key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || apply</text><text x="0" y="60"  fill="rgb(255 255 255)">key.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public vali</text><text x="0" y="65"  fill="rgb(255 255 255)">dateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.d</text><text x="0" y="70"  fill="rgb(255 255 255)">ir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); brea</text><text x="0" y="75"  fill="rgb(255 255 255)">k; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== </text><text x="0" y="80"  fill="rgb(255 255 255)">&quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (i</text><text x="0" y="85"  fill="rgb(255 255 255)">nsightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;</text><text x="0" y="90"  fill="rgb(255 255 255)">]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIO</text><text x="0" y="95"  fill="rgb(255 255 255)">NS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2)</text><text x="0" y="100"  fill="rgb(255 255 255)"> { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken:</text><text x="0" y="105"  fill="rgb(255 255 255)"> string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } pr</text><text x="0" y="110"  fill="rgb(255 255 255)">ivate validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new In</text><text x="0" y="115"  fill="rgb(255 255 255)">sightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;</text><text x="0" y="120"  fill="rgb(255 255 255)">) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = </text><text x="0" y="125"  fill="rgb(255 255 255)">mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { ret</text><text x="0" y="130"  fill="rgb(255 255 255)">urn this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in col</text><text x="0" y="135"  fill="rgb(255 255 255)">umns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP </text><text x="0" y="140"  fill="rgb(255 255 255)">=== &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.i</text><text x="0" y="145"  fill="rgb(255 255 255)">sArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(</text><text x="0" y="150"  fill="rgb(255 255 255)">); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { thi</text><text x="0" y="155"  fill="rgb(255 255 255)">s.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).le</text><text x="0" y="160"  fill="rgb(255 255 255)">ngth !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0</text><text x="0" y="165"  fill="rgb(255 255 255)">]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArra</text><text x="0" y="170"  fill="rgb(255 255 255)">y(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly c</text><text x="0" y="175"  fill="rgb(255 255 255)">oursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(ins</text><text x="0" y="180"  fill="rgb(255 255 255)">ightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length</text><text x="0" y="185"  fill="rgb(255 255 255)"> &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: st</text><text x="0" y="190"  fill="rgb(255 255 255)">ring = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfie</text><text x="0" y="195"  fill="rgb(255 255 255)">lds.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError()</text><text x="0" y="200"  fill="rgb(255 255 255)">; } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; cas</text><text x="0" y="205"  fill="rgb(255 255 255)">e &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfiel</text><text x="0" y="210"  fill="rgb(255 255 255)">d)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset</text><text x="0" y="215"  fill="rgb(255 255 255)"> of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roo</text><text x="0" y="220"  fill="rgb(255 255 255)">msfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError()</text><text x="0" y="225"  fill="rgb(255 255 255)">; } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private va</text><text x="0" y="230"  fill="rgb(255 255 255)">lidateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Ar</text><text x="0" y="235"  fill="rgb(255 255 255)">ray.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new</text><text x="0" y="240"  fill="rgb(255 255 255)"> InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw</text><text x="0" y="245"  fill="rgb(255 255 255)"> new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError</text><text x="0" y="250"  fill="rgb(255 255 255)">(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.</text><text x="0" y="255"  fill="rgb(255 255 255)">length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mf</text><text x="0" y="260"  fill="rgb(255 255 255)">ields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: str</text><text x="0" y="265"  fill="rgb(255 255 255)">ing[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS);</text><text x="0" y="270"  fill="rgb(255 255 255)"> } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includ</text><text x="0" y="275"  fill="rgb(255 255 255)">es(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError()</text><text x="0" y="280"  fill="rgb(255 255 255)">; } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationK</text><text x="0" y="285"  fill="rgb(255 255 255)">ey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).le</text><text x="0" y="290"  fill="rgb(255 255 255)">ngth !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[</text><text x="0" y="295"  fill="rgb(255 255 255)">0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.include</text><text x="0" y="300"  fill="rgb(255 255 255)">s(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightData</text><text x="0" y="305"  fill="rgb(255 255 255)">setKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private al</text><text x="0" y="310"  fill="rgb(255 255 255)">lInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP)</text><text x="0" y="315"  fill="rgb(255 255 255)">; this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array</text><text x="0" y="320"  fill="rgb(255 255 255)">.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightErro</text><text x="0" y="325"  fill="rgb(255 255 255)">r(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightEr</text><text x="0" y="330"  fill="rgb(255 255 255)">ror(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { </text><text x="0" y="335"  fill="rgb(255 255 255)">case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { </text><text x="0" y="340"  fill="rgb(255 255 255)">if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private </text><text x="0" y="345"  fill="rgb(255 255 255)">validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, </text><text x="0" y="350"  fill="rgb(255 255 255)">&quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insight</text><text x="0" y="355"  fill="rgb(255 255 255)">Datasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key</text><text x="0" y="360"  fill="rgb(255 255 255)">); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transform</text><text x="0" y="365"  fill="rgb(255 255 255)">ationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let key</text><text x="0" y="370"  fill="rgb(255 255 255)">s: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { </text><text x="0" y="375"  fill="rgb(255 255 255)">throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(</text><text x="0" y="380"  fill="rgb(255 255 255)">); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).leng</text><text x="0" y="385"  fill="rgb(255 255 255)">th !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatas</text><text x="0" y="390"  fill="rgb(255 255 255)">etKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[</text><text x="0" y="395"  fill="rgb(255 255 255)">] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } </text><text x="0" y="400"  fill="rgb(255 255 255)">} this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (</text><text x="0" y="405"  fill="rgb(255 255 255)">!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0];</text><text x="0" y="410"  fill="rgb(255 255 255)"> if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void</text><text x="0" y="415"  fill="rgb(255 255 255)"> { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public valida</text><text x="0" y="420"  fill="rgb(255 255 255)">teWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if </text><text x="0" y="425"  fill="rgb(255 255 255)">(Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.valu</text><text x="0" y="430"  fill="rgb(255 255 255)">es(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstrin</text><text x="0" y="435"  fill="rgb(255 255 255)">g); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private </text><text x="0" y="440"  fill="rgb(255 255 255)">transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY =</text><text x="0" y="445"  fill="rgb(255 255 255)">== &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError</text><text x="0" y="450"  fill="rgb(255 255 255)">(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(apply</text><text x="0" y="455"  fill="rgb(255 255 255)">token)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder</text><text x="1614" y="455"  fill="rgb(237 28 36)">(q.ORDER); } } private validat</text><text x="1704" y="455"  fill="rgb(255 255 255)">eColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysIn</text><text x="0" y="460"  fill="rgb(255 255 255)">Query.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.include</text><text x="1590" y="460"  fill="rgb(237 28 36)">s(anykey)) { throw new InsightError(); } } } </text><text x="1725" y="460"  fill="rgb(255 255 255)">} public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightErro</text><text x="0" y="465"  fill="rgb(255 255 255)">r(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void</text><text x="1569" y="465"  fill="rgb(237 28 36)"> { if (typeof value !== &quot;object&quot;) { throw new InsightErro</text><text x="1740" y="465"  fill="rgb(255 255 255)">r(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; le</text><text x="0" y="470"  fill="rgb(255 255 255)">t str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: st</text><text x="1554" y="470"  fill="rgb(237 28 36)">ring = mkey[0]; let mfield: string = mkey[1]; let num: any = Objec</text><text x="1752" y="470"  fill="rgb(255 255 255)">t.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { thr</text><text x="0" y="475"  fill="rgb(255 255 255)">ow new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } re</text><text x="1542" y="475"  fill="rgb(237 28 36)">turn true; } } return false; } else { return this.idInQuery.includes(idst</text><text x="1761" y="475"  fill="rgb(255 255 255)">ring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;p</text><text x="0" y="480"  fill="rgb(255 255 255)">ass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keys</text><text x="1527" y="480"  fill="rgb(237 28 36)">InQuery: string[]; // all keys appeared in columns after being validated private t</text><text x="1773" y="480"  fill="rgb(255 255 255)">ransformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { t</text><text x="0" y="485"  fill="rgb(255 255 255)">his.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTr</text><text x="1518" y="485"  fill="rgb(237 28 36)">ansformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === </text><text x="1779" y="485"  fill="rgb(255 255 255)">&quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); /</text><text x="0" y="490"  fill="rgb(255 255 255)">/ q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } </text><text x="1509" y="490"  fill="rgb(237 28 36)">} private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); //</text><text x="1788" y="490"  fill="rgb(255 255 255)"> q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; l</text><text x="0" y="495"  fill="rgb(255 255 255)">et criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken))</text><text x="1272" y="495"  fill="rgb(237 28 36)"> {</text><text x="1278" y="495"  fill="rgb(255 255 255)"> throw new InsightError(); } let key: string[] = criteria[applytoken].spl</text><text x="1497" y="495"  fill="rgb(237 28 36)">it(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) {</text><text x="1797" y="495"  fill="rgb(255 255 255)"> if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfield</text><text x="0" y="500"  fill="rgb(255 255 255)">s.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey </text><text x="1257" y="500"  fill="rgb(237 28 36)">of q) {</text><text x="1278" y="500"  fill="rgb(255 255 255)"> if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.i</text><text x="1491" y="500"  fill="rgb(237 28 36)">ncludes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(</text><text x="1803" y="500"  fill="rgb(255 255 255)">mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys </text><text x="0" y="505"  fill="rgb(255 255 255)">|| Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightErr</text><text x="1245" y="505"  fill="rgb(237 28 36)">or(); } el</text><text x="1275" y="505"  fill="rgb(255 255 255)">se { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } }</text><text x="1482" y="505"  fill="rgb(237 28 36)"> private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else {</text><text x="1809" y="505"  fill="rgb(255 255 255)"> let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.</text><text x="0" y="510"  fill="rgb(255 255 255)">validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); }</text><text x="1230" y="510"  fill="rgb(237 28 36)"> let skey: str</text><text x="1272" y="510"  fill="rgb(255 255 255)">ing[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { </text><text x="1473" y="510"  fill="rgb(237 28 36)">throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Ob</text><text x="1815" y="510"  fill="rgb(255 255 255)">ject.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } }</text><text x="0" y="515"  fill="rgb(255 255 255)"> } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.valida</text><text x="1218" y="515"  fill="rgb(237 28 36)">teIdstring(idstr</text><text x="1266" y="515"  fill="rgb(255 255 255)">ing) || !this.mfields.includes(mfield)) { throw new InsightError();</text><text x="1467" y="515"  fill="rgb(237 28 36)"> } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightErr</text><text x="1821" y="515"  fill="rgb(255 255 255)">or(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (i</text><text x="0" y="520"  fill="rgb(255 255 255)">nsightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.i</text><text x="1206" y="520"  fill="rgb(237 28 36)">dInQuery; } } impor</text><text x="1263" y="520"  fill="rgb(255 255 255)">t {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsi</text><text x="1461" y="520"  fill="rgb(237 28 36)">ghtFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audi</text><text x="1827" y="520"  fill="rgb(255 255 255)">t&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;</text><text x="0" y="525"  fill="rgb(255 255 255)">shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in tr</text><text x="1194" y="525"  fill="rgb(237 28 36)">ansformation, if there</text><text x="1260" y="525"  fill="rgb(255 255 255)"> is a transformation private allInsightDataset: InsightDataset[]</text><text x="1452" y="525"  fill="rgb(237 28 36)">; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; t</text><text x="1833" y="525"  fill="rgb(255 255 255)">his.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q))</text><text x="0" y="530"  fill="rgb(255 255 255)"> { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) </text><text x="1182" y="530"  fill="rgb(237 28 36)">{ throw new InsightError(</text><text x="1257" y="530"  fill="rgb(255 255 255)">); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); </text><text x="1446" y="530"  fill="rgb(237 28 36)">} private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object</text><text x="1839" y="530"  fill="rgb(255 255 255)">, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let </text><text x="0" y="535"  fill="rgb(255 255 255)">splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should hav</text><text x="1170" y="535"  fill="rgb(237 28 36)">e at least one element } for</text><text x="1254" y="535"  fill="rgb(255 255 255)"> (let applyrule of q) { if (Array.isArray(applyrule) || Object</text><text x="1440" y="535"  fill="rgb(237 28 36)">.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[a</text><text x="1845" y="535"  fill="rgb(255 255 255)">pplykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.key</text><text x="0" y="540"  fill="rgb(255 255 255)">s(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(k</text><text x="1158" y="540"  fill="rgb(237 28 36)">ey[0]) &amp;&amp; this.mfields.includes</text><text x="1251" y="540"  fill="rgb(255 255 255)">(key[1]))) { throw new InsightError(); } } else if (this.msto</text><text x="1434" y="540"  fill="rgb(237 28 36)">ken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { th</text><text x="1848" y="540"  fill="rgb(255 255 255)">row new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateC</text><text x="0" y="545"  fill="rgb(255 255 255)">olumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private vali</text><text x="1146" y="545"  fill="rgb(237 28 36)">dateOrder(q: any): void { if (Arr</text><text x="1245" y="545"  fill="rgb(255 255 255)">ay.isArray(q)) { throw new InsightError(); } else if (typeof </text><text x="1428" y="545"  fill="rgb(237 28 36)">q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !==</text><text x="1854" y="545"  fill="rgb(255 255 255)"> 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let any</text><text x="0" y="550"  fill="rgb(255 255 255)">key of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string =</text><text x="1134" y="550"  fill="rgb(237 28 36)"> Object.keys(q)[0]; let value: any =</text><text x="1242" y="550"  fill="rgb(255 255 255)"> Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: </text><text x="1422" y="550"  fill="rgb(237 28 36)">this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; </text><text x="1860" y="550"  fill="rgb(255 255 255)">case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); }</text><text x="0" y="555"  fill="rgb(255 255 255)"> private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(</text><text x="1122" y="555"  fill="rgb(237 28 36)">value)[0]; if (typeof str !== &quot;string&quot;)</text><text x="1239" y="555"  fill="rgb(255 255 255)"> { throw new InsightError(); } else { if ((str.slice(1, -1)</text><text x="1416" y="555"  fill="rgb(237 28 36)">.includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(val</text><text x="1863" y="555"  fill="rgb(255 255 255)">ue: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightEr</text><text x="0" y="560"  fill="rgb(255 255 255)">ror(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); </text><text x="1110" y="560"  fill="rgb(237 28 36)">} for (let innerObject of value) { this.va</text><text x="1236" y="560"  fill="rgb(255 255 255)">lidateFilter(innerObject); } } private validateIdstring(id</text><text x="1410" y="560"  fill="rgb(237 28 36)">string: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { </text><text x="1869" y="560"  fill="rgb(255 255 255)">this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfie</text><text x="0" y="565"  fill="rgb(255 255 255)">lds = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audi</text><text x="1098" y="565"  fill="rgb(237 28 36)">t&quot;, &quot;year&quot;]; private readonly coursesfields: </text><text x="1233" y="565"  fill="rgb(255 255 255)">string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; </text><text x="1407" y="565"  fill="rgb(237 28 36)">private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;ad</text><text x="1872" y="565"  fill="rgb(255 255 255)">dress&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only </text><text x="0" y="570"  fill="rgb(255 255 255)">has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery =</text><text x="1086" y="570"  fill="rgb(237 28 36)"> []; this.keysInQuery = []; this.transformationK</text><text x="1230" y="570"  fill="rgb(255 255 255)">ey = []; this.allInsightDataset = insightDatasets; } publ</text><text x="1401" y="570"  fill="rgb(237 28 36)">ic validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== </text><text x="1878" y="570"  fill="rgb(255 255 255)">&quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS);</text><text x="0" y="575"  fill="rgb(255 255 255)"> } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should </text><text x="1074" y="575"  fill="rgb(237 28 36)">be an object, and should has at least one element }</text><text x="1227" y="575"  fill="rgb(255 255 255)"> for (let key of q) { this.validateKey(key); this.transf</text><text x="1395" y="575"  fill="rgb(237 28 36)">ormationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;</text><text x="1881" y="575"  fill="rgb(255 255 255)">); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new I</text><text x="0" y="580"  fill="rgb(255 255 255)">nsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let crit</text><text x="1062" y="580"  fill="rgb(237 28 36)">eria = applyrule[applykey]; if (applykey.length === 0</text><text x="1221" y="580"  fill="rgb(255 255 255)"> || applykey.includes(&quot;_&quot;) || this.transformationKey.incl</text><text x="1392" y="580"  fill="rgb(237 28 36)">udes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new In</text><text x="1884" y="580"  fill="rgb(255 255 255)">sightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[ap</text><text x="0" y="585"  fill="rgb(255 255 255)">plytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.in</text><text x="1053" y="585"  fill="rgb(237 28 36)">cludes(key[1])))) { throw new InsightError(); } } } } p</text><text x="1218" y="585"  fill="rgb(255 255 255)">ublic validateOptions(q: any): void { let keys: any[] = </text><text x="1386" y="585"  fill="rgb(237 28 36)">Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.v</text><text x="1890" y="585"  fill="rgb(255 255 255)">alidateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transfor</text><text x="0" y="590"  fill="rgb(255 255 255)">mationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys </text><text x="1041" y="590"  fill="rgb(237 28 36)">|| Object.keys(q).length !== 2) { throw new InsightError()</text><text x="1215" y="590"  fill="rgb(255 255 255)">; } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new</text><text x="1380" y="590"  fill="rgb(237 28 36)"> InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.incl</text><text x="1893" y="590"  fill="rgb(255 255 255)">udes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q</text><text x="0" y="595"  fill="rgb(255 255 255)">); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: t</text><text x="1029" y="595"  fill="rgb(237 28 36)">his.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(</text><text x="1212" y="595"  fill="rgb(255 255 255)">value); break; default: throw new InsightError(); } } }</text><text x="1377" y="595"  fill="rgb(237 28 36)"> private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if</text><text x="1896" y="595"  fill="rgb(255 255 255)"> (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== </text><text x="0" y="600"  fill="rgb(255 255 255)">2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError</text><text x="1020" y="600"  fill="rgb(237 28 36)">(); } } } } private validateGTLTEQ(value: any): void { if (type</text><text x="1209" y="600"  fill="rgb(255 255 255)">of value !== &quot;object&quot; || Object.keys(value).length !==</text><text x="1371" y="600"  fill="rgb(237 28 36)"> 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey</text><text x="1899" y="600"  fill="rgb(255 255 255)">[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError</text><text x="0" y="605"  fill="rgb(255 255 255)">(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDatas</text><text x="1008" y="605"  fill="rgb(237 28 36)">et) { if (insightDataset.id === idstring) { this.idInQuery.push(id</text><text x="1206" y="605"  fill="rgb(255 255 255)">string); if (insightDataset.kind === InsightDatasetKin</text><text x="1368" y="605"  fill="rgb(237 28 36)">d.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } re</text><text x="1905" y="605"  fill="rgb(255 255 255)">turn false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IIns</text><text x="0" y="610"  fill="rgb(255 255 255)">ightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = </text><text x="999" y="610"  fill="rgb(237 28 36)">[&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;fur</text><text x="1203" y="610"  fill="rgb(255 255 255)">niture&quot;, &quot;href&quot;]; private readonly mtoken: string[] =</text><text x="1362" y="610"  fill="rgb(237 28 36)"> [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // a</text><text x="1908" y="610"  fill="rgb(255 255 255)">ll keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; </text><text x="0" y="615"  fill="rgb(255 255 255)">private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key </text><text x="987" y="615"  fill="rgb(237 28 36)">of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !</text><text x="1197" y="615"  fill="rgb(255 255 255)">== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } </text><text x="1359" y="615"  fill="rgb(237 28 36)">this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void</text><text x="1911" y="615"  fill="rgb(255 255 255)"> { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } pr</text><text x="0" y="620"  fill="rgb(255 255 255)">ivate validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key:</text><text x="978" y="620"  fill="rgb(237 28 36)"> string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splitte</text><text x="1194" y="620"  fill="rgb(255 255 255)">dKey.length !== 2) { throw new InsightError(); } if (</text><text x="1353" y="620"  fill="rgb(237 28 36)">!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any)</text><text x="1914" y="620"  fill="rgb(255 255 255)">: void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(</text><text x="0" y="625"  fill="rgb(255 255 255)">applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArra</text><text x="966" y="625"  fill="rgb(237 28 36)">y(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError()</text><text x="1191" y="625"  fill="rgb(255 255 255)">; } let applytoken: string = Object.keys(criteria)[0]</text><text x="1350" y="625"  fill="rgb(237 28 36)">; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { thr</text><text x="1917" y="625"  fill="rgb(255 255 255)">ow new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.incl</text><text x="0" y="630"  fill="rgb(255 255 255)">udes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new Insigh</text><text x="957" y="630"  fill="rgb(237 28 36)">tError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOr</text><text x="1188" y="630"  fill="rgb(255 255 255)">der(q.ORDER); } } private validateColumns(q: any): v</text><text x="1344" y="630"  fill="rgb(237 28 36)">oid { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightErro</text><text x="1920" y="630"  fill="rgb(255 255 255)">r(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;str</text><text x="0" y="635"  fill="rgb(255 255 255)">ing&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw ne</text><text x="945" y="635"  fill="rgb(237 28 36)">w InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(an</text><text x="1185" y="635"  fill="rgb(255 255 255)">ykey)) { throw new InsightError(); } } } } public va</text><text x="1341" y="635"  fill="rgb(237 28 36)">lidateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if </text><text x="1923" y="635"  fill="rgb(255 255 255)">(Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validat</text><text x="0" y="640"  fill="rgb(255 255 255)">eANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError</text><text x="936" y="640"  fill="rgb(237 28 36)">(); } this.validateFilter(value); } private validateIS(value: any): void { if (typ</text><text x="1182" y="640"  fill="rgb(255 255 255)">eof value !== &quot;object&quot;) { throw new InsightError(); </text><text x="1338" y="640"  fill="rgb(237 28 36)">} if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring</text><text x="1926" y="640"  fill="rgb(255 255 255)">: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)</text><text x="0" y="645"  fill="rgb(255 255 255)">) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mk</text><text x="927" y="645"  fill="rgb(237 28 36)">ey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]</text><text x="1179" y="645"  fill="rgb(255 255 255)">; let mfield: string = mkey[1]; let num: any = Obje</text><text x="1332" y="645"  fill="rgb(237 28 36)">ct.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { i</text><text x="1929" y="645"  fill="rgb(255 255 255)">f (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string):</text><text x="0" y="650"  fill="rgb(255 255 255)"> boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { t</text><text x="918" y="650"  fill="rgb(237 28 36)">his.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } r</text><text x="1173" y="650"  fill="rgb(255 255 255)">eturn false; } else { return this.idInQuery.includes</text><text x="1329" y="650"  fill="rgb(237 28 36)">(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { pri</text><text x="1932" y="650"  fill="rgb(255 255 255)">vate readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly </text><text x="0" y="655"  fill="rgb(255 255 255)">roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idIn</text><text x="906" y="655"  fill="rgb(237 28 36)">Query: string[]; // make sure the query only has one id private keysInQuery: string[]; /</text><text x="1170" y="655"  fill="rgb(255 255 255)">/ all keys appeared in columns after being validate</text><text x="1323" y="655"  fill="rgb(237 28 36)">d private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; c</text><text x="1935" y="655"  fill="rgb(255 255 255)">onstructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any)</text><text x="0" y="660"  fill="rgb(255 255 255)">: void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRAN</text><text x="897" y="660"  fill="rgb(237 28 36)">SFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any):</text><text x="1167" y="660"  fill="rgb(255 255 255)"> void { if (typeof q.GROUP === &quot;undefined&quot; || typeo</text><text x="1320" y="660"  fill="rgb(237 28 36)">f q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q</text><text x="1938" y="660"  fill="rgb(255 255 255)">) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key)</text><text x="0" y="665"  fill="rgb(255 255 255)">; // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || thi</text><text x="888" y="665"  fill="rgb(237 28 36)">s.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(</text><text x="1164" y="665"  fill="rgb(255 255 255)">q: any): void { if (!Array.isArray(q)) { throw new </text><text x="1317" y="665"  fill="rgb(237 28 36)">InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let </text><text x="1941" y="665"  fill="rgb(255 255 255)">applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { thro</text><text x="0" y="670"  fill="rgb(255 255 255)">w new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw</text><text x="879" y="670"  fill="rgb(237 28 36)"> new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !==</text><text x="1161" y="670"  fill="rgb(255 255 255)"> 2) { throw new InsightError(); } if (this.mtoken.</text><text x="1311" y="670"  fill="rgb(237 28 36)">includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp;</text><text x="1944" y="670"  fill="rgb(255 255 255)"> (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let</text><text x="0" y="675"  fill="rgb(255 255 255)"> key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if</text><text x="870" y="675"  fill="rgb(237 28 36)"> (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new </text><text x="1158" y="675"  fill="rgb(255 255 255)">InsightError(); } } else { this.validateKey(mskey)</text><text x="1308" y="675"  fill="rgb(237 28 36)">; } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new Insi</text><text x="1947" y="675"  fill="rgb(255 255 255)">ghtError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let key</text><text x="0" y="680"  fill="rgb(255 255 255)">s: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } els</text><text x="861" y="680"  fill="rgb(237 28 36)">e { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any</text><text x="1155" y="680"  fill="rgb(255 255 255)">): void { if (Object.keys(q).length !== 1) { throw</text><text x="1305" y="680"  fill="rgb(237 28 36)"> new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); b</text><text x="1950" y="680"  fill="rgb(255 255 255)">reak; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value:</text><text x="0" y="685"  fill="rgb(255 255 255)"> any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: st</text><text x="852" y="685"  fill="rgb(237 28 36)">ring[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else</text><text x="1152" y="685"  fill="rgb(255 255 255)"> { let idstring: string = skey[0]; let sfield: st</text><text x="1299" y="685"  fill="rgb(237 28 36)">ring = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includ</text><text x="1953" y="685"  fill="rgb(255 255 255)">es(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(</text><text x="0" y="690"  fill="rgb(255 255 255)">); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idst</text><text x="846" y="690"  fill="rgb(237 28 36)">ring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(valu</text><text x="1149" y="690"  fill="rgb(255 255 255)">e: any): void { if (!Array.isArray(value) || valu</text><text x="1296" y="690"  fill="rgb(237 28 36)">e.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insight</text><text x="1956" y="690"  fill="rgb(255 255 255)">Dataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = th</text><text x="0" y="695"  fill="rgb(255 255 255)">is.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } im</text><text x="837" y="695"  fill="rgb(237 28 36)">port {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class Q</text><text x="1146" y="695"  fill="rgb(255 255 255)">ueryValidator { private readonly coursemfields: s</text><text x="1293" y="695"  fill="rgb(237 28 36)">tring[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readon</text><text x="1959" y="695"  fill="rgb(255 255 255)">ly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; p</text><text x="0" y="700"  fill="rgb(255 255 255)">rivate readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if </text><text x="828" y="700"  fill="rgb(237 28 36)">there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private</text><text x="1143" y="700"  fill="rgb(255 255 255)"> sfields: string[]; constructor(insightDatasets: </text><text x="1290" y="700"  fill="rgb(237 28 36)">InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightEr</text><text x="1962" y="700"  fill="rgb(255 255 255)">ror(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (</text><text x="0" y="705"  fill="rgb(255 255 255)">q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new Insight</text><text x="822" y="705"  fill="rgb(237 28 36)">Error(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void</text><text x="1140" y="705"  fill="rgb(255 255 255)"> { if (!Array.isArray(q) || q.length &lt; 1) { thro</text><text x="1284" y="705"  fill="rgb(237 28 36)">w new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } priva</text><text x="1962" y="705"  fill="rgb(255 255 255)">te validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey</text><text x="0" y="710"  fill="rgb(255 255 255)">[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one eleme</text><text x="813" y="710"  fill="rgb(237 28 36)">nt } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw n</text><text x="1137" y="710"  fill="rgb(255 255 255)">ew InsightError(); } let applykey: string = Obje</text><text x="1281" y="710"  fill="rgb(237 28 36)">ct.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if</text><text x="1965" y="710"  fill="rgb(255 255 255)"> (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytok</text><text x="0" y="715"  fill="rgb(255 255 255)">en) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields</text><text x="807" y="715"  fill="rgb(237 28 36)">.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.</text><text x="1134" y="715"  fill="rgb(255 255 255)">validateIdstring(key[0]) &amp;&amp; (this.sfields.includ</text><text x="1278" y="715"  fill="rgb(237 28 36)">es(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw </text><text x="1968" y="715"  fill="rgb(255 255 255)">new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw </text><text x="0" y="720"  fill="rgb(255 255 255)">new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void</text><text x="798" y="720"  fill="rgb(237 28 36)"> { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.</text><text x="1131" y="720"  fill="rgb(255 255 255)">includes(q)) { throw new InsightError(); } } els</text><text x="1275" y="720"  fill="rgb(237 28 36)">e { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { thr</text><text x="1971" y="720"  fill="rgb(255 255 255)">ow new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.i</text><text x="0" y="725"  fill="rgb(255 255 255)">sArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let v</text><text x="792" y="725"  fill="rgb(237 28 36)">alue: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;N</text><text x="1128" y="725"  fill="rgb(255 255 255)">OT&quot;: this.validateNOT(value); break; case &quot;GT&quot;:</text><text x="1269" y="725"  fill="rgb(237 28 36)"> case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightErro</text><text x="1974" y="725"  fill="rgb(255 255 255)">r(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) {</text><text x="0" y="730"  fill="rgb(255 255 255)"> throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !</text><text x="786" y="730"  fill="rgb(237 28 36)">== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(</text><text x="1125" y="730"  fill="rgb(255 255 255)">idstring) || !this.sfields.includes(sfield)) { </text><text x="1266" y="730"  fill="rgb(237 28 36)">throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey</text><text x="1974" y="730"  fill="rgb(255 255 255)">.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;</text><text x="0" y="735"  fill="rgb(255 255 255)">number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of va</text><text x="777" y="735"  fill="rgb(237 28 36)">lue) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQue</text><text x="1122" y="735"  fill="rgb(255 255 255)">ry.length === 0) { for (let insightDataset of t</text><text x="1263" y="735"  fill="rgb(237 28 36)">his.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mf</text><text x="1977" y="735"  fill="rgb(255 255 255)">ields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): stri</text><text x="0" y="740"  fill="rgb(255 255 255)">ng[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly </text><text x="771" y="740"  fill="rgb(237 28 36)">coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;</text><text x="1119" y="740"  fill="rgb(255 255 255)">lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfi</text><text x="1260" y="740"  fill="rgb(237 28 36)">elds: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: stri</text><text x="1980" y="740"  fill="rgb(255 255 255)">ng[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // key</text><text x="0" y="745"  fill="rgb(255 255 255)">s appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this</text><text x="765" y="745"  fill="rgb(237 28 36)">.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHE</text><text x="1116" y="745"  fill="rgb(255 255 255)">RE || !q.OPTIONS) { throw new InsightError(); }</text><text x="1257" y="745"  fill="rgb(237 28 36)"> for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); }</text><text x="1983" y="745"  fill="rgb(255 255 255)"> this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).le</text><text x="0" y="750"  fill="rgb(255 255 255)">ngth !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at le</text><text x="759" y="750"  fill="rgb(237 28 36)">ast one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is vali</text><text x="1110" y="750"  fill="rgb(255 255 255)">d, push it to transformationKey } } private val</text><text x="1251" y="750"  fill="rgb(237 28 36)">idateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(</text><text x="1986" y="750"  fill="rgb(255 255 255)">splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and sh</text><text x="0" y="755"  fill="rgb(255 255 255)">ould have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (apply</text><text x="756" y="755"  fill="rgb(237 28 36)">key.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); </text><text x="1107" y="755"  fill="rgb(255 255 255)">} this.transformationKey.push(applykey); if (Ar</text><text x="1248" y="755"  fill="rgb(237 28 36)">ray.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); }</text><text x="1986" y="755"  fill="rgb(255 255 255)"> let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstri</text><text x="0" y="760"  fill="rgb(255 255 255)">ng(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightE</text><text x="750" y="760"  fill="rgb(237 28 36)">rror(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (k</text><text x="1104" y="760"  fill="rgb(255 255 255)">ey !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw ne</text><text x="1245" y="760"  fill="rgb(237 28 36)">w InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.l</text><text x="1989" y="760"  fill="rgb(255 255 255)">ength &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private vali</text><text x="0" y="765"  fill="rgb(255 255 255)">dateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw </text><text x="744" y="765"  fill="rgb(237 28 36)">new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if </text><text x="1101" y="765"  fill="rgb(255 255 255)">(!Array.isArray(keys) || keys.length &lt; 1) { thr</text><text x="1242" y="765"  fill="rgb(237 28 36)">ow new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length </text><text x="1992" y="765"  fill="rgb(255 255 255)">!== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Obj</text><text x="0" y="770"  fill="rgb(255 255 255)">ect.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS</text><text x="738" y="770"  fill="rgb(237 28 36)">&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (t</text><text x="1098" y="770"  fill="rgb(255 255 255)">ypeof value !== &quot;object&quot;) { throw new InsightEr</text><text x="1239" y="770"  fill="rgb(237 28 36)">ror(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].sp</text><text x="1992" y="770"  fill="rgb(255 255 255)">lit(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0</text><text x="0" y="775"  fill="rgb(255 255 255)">]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: a</text><text x="732" y="775"  fill="rgb(237 28 36)">ny): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: str</text><text x="1095" y="775"  fill="rgb(255 255 255)">ing[] = Object.keys(value)[0].split(&quot;_&quot;); if (m</text><text x="1236" y="775"  fill="rgb(237 28 36)">key.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfie</text><text x="1995" y="775"  fill="rgb(255 255 255)">ld)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let i</text><text x="0" y="780"  fill="rgb(255 255 255)">nnerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { th</text><text x="729" y="780"  fill="rgb(237 28 36)">is.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields;</text><text x="1092" y="780"  fill="rgb(255 255 255)"> this.sfields = this.coursesfields; } else { t</text><text x="1230" y="780"  fill="rgb(237 28 36)">his.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind</text><text x="1998" y="780"  fill="rgb(255 255 255)">, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; pri</text><text x="0" y="785"  fill="rgb(255 255 255)">vate readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;a</text><text x="723" y="785"  fill="rgb(237 28 36)">ddress&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly </text><text x="1089" y="785"  fill="rgb(255 255 255)">mstoken: string[] = [&quot;COUNT&quot;]; private idInQue</text><text x="1227" y="785"  fill="rgb(237 28 36)">ry: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsigh</text><text x="1998" y="785"  fill="rgb(255 255 255)">tDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuer</text><text x="0" y="790"  fill="rgb(255 255 255)">y = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key</text><text x="717" y="790"  fill="rgb(237 28 36)"> !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIO</text><text x="1086" y="790"  fill="rgb(255 255 255)">NS) { this.validateTransformations(q.TRANSFORM</text><text x="1224" y="790"  fill="rgb(237 28 36)">ATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.v</text><text x="2001" y="790"  fill="rgb(255 255 255)">alidateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should</text><text x="0" y="795"  fill="rgb(255 255 255)"> has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.s</text><text x="711" y="795"  fill="rgb(237 28 36)">plit(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.m</text><text x="1086" y="795"  fill="rgb(255 255 255)">fields.includes(splittedKey[1]) || this.sfiel</text><text x="1221" y="795"  fill="rgb(237 28 36)">ds.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(</text><text x="2004" y="795"  fill="rgb(255 255 255)">applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; </text><text x="0" y="800"  fill="rgb(255 255 255)">if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { th</text><text x="708" y="800"  fill="rgb(237 28 36)">row new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.m</text><text x="1083" y="800"  fill="rgb(255 255 255)">stoken.includes(applytoken)) { throw new Insi</text><text x="1218" y="800"  fill="rgb(237 28 36)">ghtError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } </text><text x="2004" y="800"  fill="rgb(255 255 255)">else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new I</text><text x="0" y="805"  fill="rgb(255 255 255)">nsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.O</text><text x="702" y="805"  fill="rgb(237 28 36)">RDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightEr</text><text x="1080" y="805"  fill="rgb(255 255 255)">ror(); } for (let mskey of q) { if (this.tran</text><text x="1215" y="805"  fill="rgb(237 28 36)">sformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } e</text><text x="2007" y="805"  fill="rgb(255 255 255)">lse if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { t</text><text x="0" y="810"  fill="rgb(255 255 255)">hrow new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this</text><text x="696" y="810"  fill="rgb(237 28 36)">.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) {</text><text x="1077" y="810"  fill="rgb(255 255 255)"> throw new InsightError(); } else { if (Objec</text><text x="1212" y="810"  fill="rgb(237 28 36)">t.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;</text><text x="2007" y="810"  fill="rgb(255 255 255)">: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case </text><text x="0" y="815"  fill="rgb(255 255 255)">&quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(val</text><text x="693" y="815"  fill="rgb(237 28 36)">ue: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new </text><text x="1074" y="815"  fill="rgb(255 255 255)">InsightError(); } let skey: string[] = Object</text><text x="1209" y="815"  fill="rgb(237 28 36)">.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.sl</text><text x="2010" y="815"  fill="rgb(255 255 255)">ice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: </text><text x="0" y="820"  fill="rgb(255 255 255)">any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let i</text><text x="687" y="820"  fill="rgb(237 28 36)">dstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) |</text><text x="1071" y="820"  fill="rgb(255 255 255)">| !this.validateIdstring(idstring) || !this.</text><text x="1203" y="820"  fill="rgb(237 28 36)">mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdst</text><text x="2013" y="820"  fill="rgb(255 255 255)">ring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { th</text><text x="0" y="825"  fill="rgb(255 255 255)">is.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfie</text><text x="681" y="825"  fill="rgb(237 28 36)">lds; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { re</text><text x="1068" y="825"  fill="rgb(255 255 255)">turn this.idInQuery; } } import {InsightData</text><text x="1200" y="825"  fill="rgb(237 28 36)">set, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uui</text><text x="2016" y="825"  fill="rgb(255 255 255)">d&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;add</text><text x="0" y="830"  fill="rgb(255 255 255)">ress&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private</text><text x="678" y="830"  fill="rgb(237 28 36)"> keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appear</text><text x="1065" y="830"  fill="rgb(255 255 255)">ed in transformation, if there is a transfor</text><text x="1197" y="830"  fill="rgb(237 28 36)">mation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } pu</text><text x="2019" y="830"  fill="rgb(255 255 255)">blic validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !==</text><text x="0" y="835"  fill="rgb(255 255 255)"> &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public valida</text><text x="672" y="835"  fill="rgb(237 28 36)">teTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !=</text><text x="1062" y="835"  fill="rgb(255 255 255)">= 2) { throw new InsightError(); } this.vali</text><text x="1194" y="835"  fill="rgb(237 28 36)">dateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transf</text><text x="2019" y="835"  fill="rgb(255 255 255)">ormationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;</text><text x="0" y="840"  fill="rgb(255 255 255)">_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); </text><text x="669" y="840"  fill="rgb(237 28 36)">} } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should h</text><text x="1059" y="840"  fill="rgb(255 255 255)">ave at least one element } for (let applyrul</text><text x="1191" y="840"  fill="rgb(237 28 36)">e of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includ</text><text x="2022" y="840"  fill="rgb(255 255 255)">es(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new</text><text x="0" y="845"  fill="rgb(255 255 255)"> InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].spl</text><text x="663" y="845"  fill="rgb(237 28 36)">it(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(ke</text><text x="1056" y="845"  fill="rgb(255 255 255)">y[0]) &amp;&amp; this.mfields.includes(key[1]))) { t</text><text x="1188" y="845"  fill="rgb(237 28 36)">hrow new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Objec</text><text x="2025" y="845"  fill="rgb(255 255 255)">t.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { t</text><text x="0" y="850"  fill="rgb(255 255 255)">his.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.in</text><text x="660" y="850"  fill="rgb(237 28 36)">cludes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validate</text><text x="1053" y="850"  fill="rgb(255 255 255)">Order(q: any): void { if (Array.isArray(q)) </text><text x="1185" y="850"  fill="rgb(237 28 36)">{ throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new Insigh</text><text x="2025" y="850"  fill="rgb(255 255 255)">tError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuer</text><text x="0" y="855"  fill="rgb(255 255 255)">y.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } p</text><text x="654" y="855"  fill="rgb(237 28 36)">rivate validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object</text><text x="1050" y="855"  fill="rgb(255 255 255)">.keys(q)[0]; let value: any = Object.values(</text><text x="1182" y="855"  fill="rgb(237 28 36)">q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private </text><text x="2028" y="855"  fill="rgb(255 255 255)">validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): vo</text><text x="0" y="860"  fill="rgb(255 255 255)">id { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { thro</text><text x="651" y="860"  fill="rgb(237 28 36)">w new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0];</text><text x="1047" y="860"  fill="rgb(255 255 255)"> if (typeof str !== &quot;string&quot;) { throw new In</text><text x="1179" y="860"  fill="rgb(237 28 36)">sightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw </text><text x="2031" y="860"  fill="rgb(255 255 255)">new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: strin</text><text x="0" y="865"  fill="rgb(255 255 255)">g = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } }</text><text x="645" y="865"  fill="rgb(237 28 36)"> } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let in</text><text x="1044" y="865"  fill="rgb(255 255 255)">nerObject of value) { this.validateFilter(in</text><text x="1176" y="865"  fill="rgb(237 28 36)">nerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { </text><text x="2031" y="865"  fill="rgb(255 255 255)">this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return tr</text><text x="0" y="870"  fill="rgb(255 255 255)">ue; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFa</text><text x="642" y="870"  fill="rgb(237 28 36)">cade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; pri</text><text x="1041" y="870"  fill="rgb(255 255 255)">vate readonly coursesfields: string[] = [&quot;de</text><text x="1173" y="870"  fill="rgb(237 28 36)">pt&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, </text><text x="2034" y="870"  fill="rgb(255 255 255)">&quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: str</text><text x="0" y="875"  fill="rgb(255 255 255)">ing[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; priv</text><text x="636" y="875"  fill="rgb(237 28 36)">ate mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQue</text><text x="1038" y="875"  fill="rgb(255 255 255)">ry = []; this.transformationKey = []; this.a</text><text x="1170" y="875"  fill="rgb(237 28 36)">llInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWher</text><text x="2034" y="875"  fill="rgb(255 255 255)">e(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q</text><text x="0" y="880"  fill="rgb(255 255 255)">: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } priva</text><text x="633" y="880"  fill="rgb(237 28 36)">te validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and shou</text><text x="1035" y="880"  fill="rgb(255 255 255)">ld has at least one element } for (let key o</text><text x="1167" y="880"  fill="rgb(237 28 36)">f q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstr</text><text x="2037" y="880"  fill="rgb(255 255 255)">ing(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validate</text><text x="0" y="885"  fill="rgb(255 255 255)">APPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(a</text><text x="627" y="885"  fill="rgb(237 28 36)">pplyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey</text><text x="1032" y="885"  fill="rgb(255 255 255)">]; if (applykey.length === 0 || applykey.inc</text><text x="1164" y="885"  fill="rgb(237 28 36)">ludes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.in</text><text x="2037" y="885"  fill="rgb(255 255 255)">cludes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.lengt</text><text x="0" y="890"  fill="rgb(255 255 255)">h !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.incl</text><text x="624" y="890"  fill="rgb(237 28 36)">udes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw n</text><text x="1029" y="890"  fill="rgb(255 255 255)">ew InsightError(); } } } } public validateOp</text><text x="1161" y="890"  fill="rgb(237 28 36)">tions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length</text><text x="2040" y="890"  fill="rgb(255 255 255)"> &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw </text><text x="0" y="895"  fill="rgb(255 255 255)">new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;st</text><text x="621" y="895"  fill="rgb(237 28 36)">ring&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2)</text><text x="1029" y="895"  fill="rgb(255 255 255)"> { throw new InsightError(); } if (q.dir !=</text><text x="1158" y="895"  fill="rgb(237 28 36)">= &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void</text><text x="2040" y="895"  fill="rgb(255 255 255)"> { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: </text><text x="0" y="900"  fill="rgb(255 255 255)">any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.vali</text><text x="615" y="900"  fill="rgb(237 28 36)">dateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; </text><text x="1026" y="900"  fill="rgb(255 255 255)">case &quot;IS&quot;: this.validateIS(value); break; d</text><text x="1155" y="900"  fill="rgb(237 28 36)">efault: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).l</text><text x="2040" y="900"  fill="rgb(255 255 255)">ength !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } el</text><text x="0" y="905"  fill="rgb(255 255 255)">se { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(</text><text x="612" y="905"  fill="rgb(237 28 36)">&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(v</text><text x="1023" y="905"  fill="rgb(255 255 255)">alue: any): void { if (typeof value !== &quot;ob</text><text x="1152" y="905"  fill="rgb(237 28 36)">ject&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typ</text><text x="2043" y="905"  fill="rgb(255 255 255)">eof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(val</text><text x="0" y="910"  fill="rgb(255 255 255)">ue: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: str</text><text x="609" y="910"  fill="rgb(237 28 36)">ing): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstrin</text><text x="1020" y="910"  fill="rgb(255 255 255)">g) { this.idInQuery.push(idstring); if (ins</text><text x="1149" y="910"  fill="rgb(237 28 36)">ightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdIn</text><text x="2043" y="910"  fill="rgb(255 255 255)">Query(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class Q</text><text x="0" y="915"  fill="rgb(255 255 255)">ueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private re</text><text x="603" y="915"  fill="rgb(237 28 36)">adonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;nam</text><text x="1017" y="915"  fill="rgb(255 255 255)">e&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]</text><text x="1146" y="915"  fill="rgb(237 28 36)">; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: stri</text><text x="2046" y="915"  fill="rgb(255 255 255)">ng[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private </text><text x="0" y="920"  fill="rgb(255 255 255)">sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate</text><text x="600" y="920"  fill="rgb(237 28 36)">(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;</text><text x="1014" y="920"  fill="rgb(255 255 255)">&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIO</text><text x="1143" y="920"  fill="rgb(237 28 36)">NS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Objec</text><text x="2046" y="920"  fill="rgb(255 255 255)">t.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void {</text><text x="0" y="925"  fill="rgb(255 255 255)"> if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.</text><text x="597" y="925"  fill="rgb(237 28 36)">push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = k</text><text x="1011" y="925"  fill="rgb(255 255 255)">ey.split(&quot;_&quot;); if (splittedKey.length !== 2</text><text x="1140" y="925"  fill="rgb(237 28 36)">) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an a</text><text x="2046" y="925"  fill="rgb(255 255 255)">rray, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new </text><text x="0" y="930"  fill="rgb(255 255 255)">InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applyke</text><text x="594" y="930"  fill="rgb(237 28 36)">y)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) </text><text x="1008" y="930"  fill="rgb(255 255 255)">{ throw new InsightError(); } let applytoke</text><text x="1137" y="930"  fill="rgb(237 28 36)">n: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.val</text><text x="2049" y="930"  fill="rgb(255 255 255)">idateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.vali</text><text x="0" y="935"  fill="rgb(255 255 255)">dateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q</text><text x="591" y="935"  fill="rgb(237 28 36)">); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (</text><text x="1005" y="935"  fill="rgb(255 255 255)">q.ORDER) { this.validateOrder(q.ORDER); } }</text><text x="1134" y="935"  fill="rgb(237 28 36)"> private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } p</text><text x="2049" y="935"  fill="rgb(255 255 255)">rivate validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.inclu</text><text x="0" y="940"  fill="rgb(255 255 255)">des(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError</text><text x="585" y="940"  fill="rgb(237 28 36)">(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!thi</text><text x="1005" y="940"  fill="rgb(255 255 255)">s.keysInQuery.includes(anykey)) { throw ne</text><text x="1131" y="940"  fill="rgb(237 28 36)">w InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: st</text><text x="2052" y="940"  fill="rgb(255 255 255)">ring = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: t</text><text x="0" y="945"  fill="rgb(255 255 255)">his.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private vali</text><text x="582" y="945"  fill="rgb(237 28 36)">dateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(va</text><text x="1002" y="945"  fill="rgb(255 255 255)">lue: any): void { if (typeof value !== &quot;ob</text><text x="1128" y="945"  fill="rgb(237 28 36)">ject&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.value</text><text x="2052" y="945"  fill="rgb(255 255 255)">s(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstrin</text><text x="0" y="950"  fill="rgb(255 255 255)">g) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw ne</text><text x="579" y="950"  fill="rgb(237 28 36)">w InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let i</text><text x="999" y="950"  fill="rgb(255 255 255)">dstring: string = mkey[0]; let mfield: str</text><text x="1125" y="950"  fill="rgb(237 28 36)">ing = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } </text><text x="2052" y="950"  fill="rgb(255 255 255)">for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.lengt</text><text x="0" y="955"  fill="rgb(255 255 255)">h === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { t</text><text x="576" y="955"  fill="rgb(237 28 36)">his.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfiel</text><text x="996" y="955"  fill="rgb(255 255 255)">ds; } return true; } } return false; } else</text><text x="1125" y="955"  fill="rgb(237 28 36)"> { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;y</text><text x="2052" y="955"  fill="rgb(255 255 255)">ear&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lo</text><text x="0" y="960"  fill="rgb(255 255 255)">n&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;,</text><text x="573" y="960"  fill="rgb(237 28 36)"> &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private </text><text x="993" y="960"  fill="rgb(255 255 255)">keysInQuery: string[]; // all keys appeared</text><text x="1122" y="960"  fill="rgb(237 28 36)"> in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.k</text><text x="2055" y="960"  fill="rgb(255 255 255)">eysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.O</text><text x="0" y="965"  fill="rgb(255 255 255)">PTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWh</text><text x="570" y="965"  fill="rgb(237 28 36)">ere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validate</text><text x="990" y="965"  fill="rgb(255 255 255)">Transformations(q: any): void { if (typeof </text><text x="1119" y="965"  fill="rgb(237 28 36)">q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, a</text><text x="2055" y="965"  fill="rgb(255 255 255)">nd should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it t</text><text x="0" y="970"  fill="rgb(255 255 255)">o transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateI</text><text x="567" y="970"  fill="rgb(237 28 36)">dstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } </text><text x="987" y="970"  fill="rgb(255 255 255)">} private validateAPPLY(q: any): void { if </text><text x="1116" y="970"  fill="rgb(237 28 36)">(!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[ap</text><text x="2055" y="970"  fill="rgb(255 255 255)">plykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transf</text><text x="0" y="975"  fill="rgb(255 255 255)">ormationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtok</text><text x="564" y="975"  fill="rgb(237 28 36)">en.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;</text><text x="987" y="975"  fill="rgb(255 255 255)">_&quot;); if (key.length !== 2) { throw new Ins</text><text x="1113" y="975"  fill="rgb(237 28 36)">ightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { thr</text><text x="2058" y="975"  fill="rgb(255 255 255)">ow new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMN</text><text x="0" y="980"  fill="rgb(255 255 255)">S&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q</text><text x="561" y="980"  fill="rgb(237 28 36)">.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includ</text><text x="984" y="980"  fill="rgb(255 255 255)">es(mskey)) { throw new InsightError(); } }</text><text x="1110" y="980"  fill="rgb(237 28 36)"> else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !=</text><text x="2058" y="980"  fill="rgb(255 255 255)">= 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray</text><text x="0" y="985"  fill="rgb(255 255 255)">(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: an</text><text x="558" y="985"  fill="rgb(237 28 36)">y): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } privat</text><text x="981" y="985"  fill="rgb(255 255 255)">e validateFilter(q: any): void { if (Objec</text><text x="1107" y="985"  fill="rgb(237 28 36)">t.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); brea</text><text x="2058" y="985"  fill="rgb(255 255 255)">k; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== </text><text x="0" y="990"  fill="rgb(255 255 255)">&quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys</text><text x="555" y="990"  fill="rgb(237 28 36)">(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new</text><text x="978" y="990"  fill="rgb(255 255 255)"> InsightError(); } else { let idstring: st</text><text x="1104" y="990"  fill="rgb(237 28 36)">ring = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(</text><text x="2061" y="990"  fill="rgb(255 255 255)">value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.ke</text><text x="0" y="995"  fill="rgb(255 255 255)">ys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0</text><text x="552" y="995"  fill="rgb(237 28 36)">]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } pri</text><text x="975" y="995"  fill="rgb(255 255 255)">vate validateANDOR(value: any): void { if (</text><text x="1104" y="995"  fill="rgb(237 28 36)">!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstrin</text><text x="2061" y="995"  fill="rgb(255 255 255)">g) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = th</text><text x="0" y="1000"  fill="rgb(255 255 255)">is.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } pu</text><text x="549" y="1000"  fill="rgb(237 28 36)">blic getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; </text><text x="975" y="1000"  fill="rgb(255 255 255)">export default class QueryValidator { priv</text><text x="1101" y="1000"  fill="rgb(237 28 36)">ate readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name</text><text x="2061" y="1000"  fill="rgb(255 255 255)">&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] =</text><text x="0" y="1005"  fill="rgb(255 255 255)"> [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transform</text><text x="546" y="1005"  fill="rgb(237 28 36)">ationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfie</text><text x="972" y="1005"  fill="rgb(255 255 255)">lds: string[]; private sfields: string[]; </text><text x="1098" y="1005"  fill="rgb(237 28 36)">constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; </text><text x="2061" y="1005"  fill="rgb(255 255 255)">key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateT</text><text x="0" y="1010"  fill="rgb(255 255 255)">ransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;unde</text><text x="543" y="1010"  fill="rgb(237 28 36)">fined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private valid</text><text x="969" y="1010"  fill="rgb(255 255 255)">ateGROUP(q: any): void { if (!Array.isArra</text><text x="1095" y="1010"  fill="rgb(237 28 36)">y(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.s</text><text x="2064" y="1010"  fill="rgb(255 255 255)">plit(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(spli</text><text x="0" y="1015"  fill="rgb(255 255 255)">ttedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // </text><text x="540" y="1015"  fill="rgb(237 28 36)">q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule)</text><text x="966" y="1015"  fill="rgb(255 255 255)">.length &gt; 1) { throw new InsightError(); }</text><text x="1092" y="1015"  fill="rgb(237 28 36)"> let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { thr</text><text x="2064" y="1015"  fill="rgb(255 255 255)">ow new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(apply</text><text x="0" y="1020"  fill="rgb(255 255 255)">token)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)</text><text x="537" y="1020"  fill="rgb(237 28 36)">) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(appl</text><text x="963" y="1020"  fill="rgb(255 255 255)">ytoken)) { if (!(this.validateIdstring(key[</text><text x="1092" y="1020"  fill="rgb(237 28 36)">0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDE</text><text x="2064" y="1020"  fill="rgb(255 255 255)">R) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mske</text><text x="0" y="1025"  fill="rgb(255 255 255)">y of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery</text><text x="534" y="1025"  fill="rgb(237 28 36)">.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { i</text><text x="963" y="1025"  fill="rgb(255 255 255)">f (!this.keysInQuery.includes(q)) { throw </text><text x="1089" y="1025"  fill="rgb(237 28 36)">new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keys</text><text x="2064" y="1025"  fill="rgb(255 255 255)">InQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError</text><text x="0" y="1030"  fill="rgb(255 255 255)">(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError();</text><text x="531" y="1030"  fill="rgb(237 28 36)"> } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(v</text><text x="960" y="1030"  fill="rgb(255 255 255)">alue); break; case &quot;NOT&quot;: this.validateNOT</text><text x="1086" y="1030"  fill="rgb(237 28 36)">(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: an</text><text x="2064" y="1030"  fill="rgb(255 255 255)">y): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let sk</text><text x="0" y="1035"  fill="rgb(255 255 255)">ey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let s</text><text x="528" y="1035"  fill="rgb(237 28 36)">tr: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !t</text><text x="957" y="1035"  fill="rgb(255 255 255)">his.validateIdstring(idstring) || !this.sf</text><text x="1083" y="1035"  fill="rgb(237 28 36)">ields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: </text><text x="2067" y="1035"  fill="rgb(255 255 255)">string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(</text><text x="0" y="1040"  fill="rgb(255 255 255)">idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw</text><text x="525" y="1040"  fill="rgb(237 28 36)"> new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boole</text><text x="954" y="1040"  fill="rgb(255 255 255)">an { if (this.idInQuery.length === 0) { for</text><text x="1083" y="1040"  fill="rgb(237 28 36)"> (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQue</text><text x="1383" y="1040"  fill="rgb(255 255 255)">ry.push(idstring); if (insightDataset</text><text x="1494" y="1040"  fill="rgb(237 28 36)">.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } retu</text><text x="2067" y="1040"  fill="rgb(255 255 255)">rn true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } i</text><text x="0" y="1045"  fill="rgb(255 255 255)">mport {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pa</text><text x="522" y="1045"  fill="rgb(237 28 36)">ss&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommf</text><text x="954" y="1045"  fill="rgb(255 255 255)">ields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;];</text><text x="1080" y="1045"  fill="rgb(237 28 36)"> private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;ad</text><text x="1350" y="1045"  fill="rgb(255 255 255)">dress&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mto</text><text x="1524" y="1045"  fill="rgb(237 28 36)">ken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery</text><text x="2067" y="1045"  fill="rgb(255 255 255)">: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if th</text><text x="0" y="1050"  fill="rgb(255 255 255)">ere is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { th</text><text x="522" y="1050"  fill="rgb(237 28 36)">is.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): voi</text><text x="951" y="1050"  fill="rgb(255 255 255)">d { if (!q || !q.WHERE || !q.OPTIONS) { th</text><text x="1077" y="1050"  fill="rgb(237 28 36)">row new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp;</text><text x="1329" y="1050"  fill="rgb(255 255 255)"> key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(</text><text x="1545" y="1050"  fill="rgb(237 28 36)">); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformati</text><text x="2067" y="1050"  fill="rgb(255 255 255)">ons(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightErro</text><text x="0" y="1055"  fill="rgb(255 255 255)">r(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); /</text><text x="519" y="1055"  fill="rgb(237 28 36)">/ q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); //</text><text x="948" y="1055"  fill="rgb(255 255 255)"> if the key is valid, push it to transform</text><text x="1074" y="1055"  fill="rgb(237 28 36)">ationKey } } private validateKey(key: string): void { let splittedKey: string[</text><text x="1308" y="1055"  fill="rgb(255 255 255)">] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!</text><text x="1563" y="1055"  fill="rgb(237 28 36)">(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private vali</text><text x="2070" y="1055"  fill="rgb(255 255 255)">dateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } fo</text><text x="0" y="1060"  fill="rgb(255 255 255)">r (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; </text><text x="516" y="1060"  fill="rgb(237 28 36)">let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw n</text><text x="945" y="1060"  fill="rgb(255 255 255)">ew InsightError(); } this.transformationKey</text><text x="1074" y="1060"  fill="rgb(237 28 36)">.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).l</text><text x="1287" y="1060"  fill="rgb(255 255 255)">ength &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!</text><text x="1578" y="1060"  fill="rgb(237 28 36)">this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.l</text><text x="2070" y="1060"  fill="rgb(255 255 255)">ength !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes</text><text x="0" y="1065"  fill="rgb(255 255 255)">(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfie</text><text x="513" y="1065"  fill="rgb(237 28 36)">lds.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let ke</text><text x="945" y="1065"  fill="rgb(255 255 255)">y of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key </text><text x="1071" y="1065"  fill="rgb(237 28 36)">!== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(</text><text x="1269" y="1065"  fill="rgb(255 255 255)">q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q |</text><text x="1593" y="1065"  fill="rgb(237 28 36)">| q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { th</text><text x="2070" y="1065"  fill="rgb(255 255 255)">row new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array</text><text x="0" y="1070"  fill="rgb(255 255 255)">.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.ke</text><text x="510" y="1070"  fill="rgb(237 28 36)">ys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys:</text><text x="942" y="1070"  fill="rgb(255 255 255)"> any = q.keys; if (!Array.isArray(keys) ||</text><text x="1068" y="1070"  fill="rgb(237 28 36)"> keys.length &lt; 1) { throw new InsightError(); } for (let anyk</text><text x="1251" y="1070"  fill="rgb(255 255 255)">ey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any)</text><text x="1605" y="1070"  fill="rgb(237 28 36)">: void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter</text><text x="2070" y="1070"  fill="rgb(255 255 255)">(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Ob</text><text x="0" y="1075"  fill="rgb(255 255 255)">ject.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: t</text><text x="507" y="1075"  fill="rgb(237 28 36)">his.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: </text><text x="939" y="1075"  fill="rgb(255 255 255)">any): void { if (typeof value !== &quot;object&quot;)</text><text x="1068" y="1075"  fill="rgb(237 28 36)"> { throw new InsightError(); } this.validateFilter(valu</text><text x="1233" y="1075"  fill="rgb(255 255 255)">e); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value</text><text x="1614" y="1075"  fill="rgb(237 28 36)">).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); </text><text x="2070" y="1075"  fill="rgb(255 255 255)">} else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { t</text><text x="0" y="1080"  fill="rgb(255 255 255)">hrow new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError();</text><text x="507" y="1080"  fill="rgb(237 28 36)"> } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(</text><text x="936" y="1080"  fill="rgb(255 255 255)">); } let mkey: string[] = Object.keys(value</text><text x="1065" y="1080"  fill="rgb(237 28 36)">)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw ne</text><text x="1215" y="1080"  fill="rgb(255 255 255)">w InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typ</text><text x="1626" y="1080"  fill="rgb(237 28 36)">eof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR</text><text x="2070" y="1080"  fill="rgb(255 255 255)">(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validat</text><text x="0" y="1085"  fill="rgb(255 255 255)">eFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { </text><text x="504" y="1085"  fill="rgb(237 28 36)">if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = th</text><text x="936" y="1085"  fill="rgb(255 255 255)">is.coursemfields; this.sfields = this.cour</text><text x="1062" y="1085"  fill="rgb(237 28 36)">sesfields; } else { this.mfields = this.roommf</text><text x="1200" y="1085"  fill="rgb(255 255 255)">ields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQue</text><text x="1635" y="1085"  fill="rgb(237 28 36)">ry(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default clas</text><text x="2073" y="1085"  fill="rgb(255 255 255)">s QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string</text><text x="0" y="1090"  fill="rgb(255 255 255)">[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullna</text><text x="501" y="1090"  fill="rgb(237 28 36)">me&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; </text><text x="933" y="1090"  fill="rgb(255 255 255)">private readonly mstoken: string[] = [&quot;COUN</text><text x="1062" y="1090"  fill="rgb(237 28 36)">T&quot;]; private idInQuery: string[]; // mak</text><text x="1182" y="1090"  fill="rgb(255 255 255)">e sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]</text><text x="1641" y="1090"  fill="rgb(237 28 36)">; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; priva</text><text x="2073" y="1090"  fill="rgb(255 255 255)">te sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []</text><text x="0" y="1095"  fill="rgb(255 255 255)">; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.k</text><text x="498" y="1095"  fill="rgb(237 28 36)">eys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if</text><text x="930" y="1095"  fill="rgb(255 255 255)"> (q.TRANSFORMATIONS) { this.validateTransfo</text><text x="1059" y="1095"  fill="rgb(237 28 36)">rmations(q.TRANSFORMATIONS); } this.</text><text x="1167" y="1095"  fill="rgb(255 255 255)">validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(</text><text x="1650" y="1095"  fill="rgb(237 28 36)">q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): voi</text><text x="2073" y="1095"  fill="rgb(255 255 255)">d { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (le</text><text x="0" y="1100"  fill="rgb(255 255 255)">t key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void</text><text x="498" y="1100"  fill="rgb(237 28 36)"> { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splitted</text><text x="927" y="1100"  fill="rgb(255 255 255)">Key[0]) &amp;&amp; (this.mfields.includes(splittedK</text><text x="1056" y="1100"  fill="rgb(237 28 36)">ey[1]) || this.sfields.includes(</text><text x="1152" y="1100"  fill="rgb(255 255 255)">splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and </text><text x="1659" y="1100"  fill="rgb(237 28 36)">should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw n</text><text x="2073" y="1100"  fill="rgb(255 255 255)">ew InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applyk</text><text x="0" y="1105"  fill="rgb(255 255 255)">ey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Ob</text><text x="495" y="1105"  fill="rgb(237 28 36)">ject.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(appl</text><text x="924" y="1105"  fill="rgb(255 255 255)">ytoken) &amp;&amp; !this.mstoken.includes(applytoken</text><text x="1056" y="1105"  fill="rgb(237 28 36)">)) { throw new InsightError</text><text x="1137" y="1105"  fill="rgb(255 255 255)">(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstri</text><text x="1665" y="1105"  fill="rgb(237 28 36)">ng(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.v</text><text x="2073" y="1105"  fill="rgb(255 255 255)">alidateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public valid</text><text x="0" y="1110"  fill="rgb(255 255 255)">ateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.</text><text x="492" y="1110"  fill="rgb(237 28 36)">validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { th</text><text x="924" y="1110"  fill="rgb(255 255 255)">row new InsightError(); } for (let mskey of</text><text x="1053" y="1110"  fill="rgb(237 28 36)"> q) { if (this.transfo</text><text x="1119" y="1110"  fill="rgb(255 255 255)">rmationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private valida</text><text x="1671" y="1110"  fill="rgb(237 28 36)">teOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.in</text><text x="2073" y="1110"  fill="rgb(255 255 255)">cludes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.di</text><text x="0" y="1115"  fill="rgb(255 255 255)">r !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } fo</text><text x="489" y="1115"  fill="rgb(237 28 36)">r (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Ar</text><text x="921" y="1115"  fill="rgb(255 255 255)">ray.isArray(q)) { throw new InsightError(); </text><text x="1053" y="1115"  fill="rgb(237 28 36)">} else { if (Obje</text><text x="1104" y="1115"  fill="rgb(255 255 255)">ct.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.</text><text x="1677" y="1115"  fill="rgb(237 28 36)">keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;:</text><text x="2076" y="1115"  fill="rgb(255 255 255)"> this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break</text><text x="0" y="1120"  fill="rgb(255 255 255)">; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter</text><text x="489" y="1120"  fill="rgb(237 28 36)">(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !=</text><text x="918" y="1120"  fill="rgb(255 255 255)">= 1) { throw new InsightError(); } let skey:</text><text x="1050" y="1120"  fill="rgb(237 28 36)"> string[] = O</text><text x="1089" y="1120"  fill="rgb(255 255 255)">bject.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if </text><text x="1683" y="1120"  fill="rgb(237 28 36)">(typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstr</text><text x="2076" y="1120"  fill="rgb(255 255 255)">ing) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;</text><text x="0" y="1125"  fill="rgb(255 255 255)">object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw ne</text><text x="486" y="1125"  fill="rgb(237 28 36)">w InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof nu</text><text x="915" y="1125"  fill="rgb(255 255 255)">m !== &quot;number&quot;) || !this.validateIdstring(id</text><text x="1047" y="1125"  fill="rgb(237 28 36)">string) |</text><text x="1074" y="1125"  fill="rgb(255 255 255)">| !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObje</text><text x="1689" y="1125"  fill="rgb(237 28 36)">ct of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.len</text><text x="2076" y="1125"  fill="rgb(255 255 255)">gth === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (in</text><text x="0" y="1130"  fill="rgb(255 255 255)">sightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfield</text><text x="483" y="1130"  fill="rgb(237 28 36)">s; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery</text><text x="912" y="1130"  fill="rgb(255 255 255)">(): string[] { return this.idInQuery; } } imp</text><text x="1047" y="1130"  fill="rgb(237 28 36)">ort {</text><text x="1062" y="1130"  fill="rgb(255 255 255)">InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private reado</text><text x="1695" y="1130"  fill="rgb(237 28 36)">nly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;</text><text x="2076" y="1130"  fill="rgb(255 255 255)">lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]</text><text x="0" y="1135"  fill="rgb(255 255 255)">; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure th</text><text x="480" y="1135"  fill="rgb(237 28 36)">e query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[</text><text x="909" y="1135"  fill="rgb(255 255 255)">]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this</text><text x="1701" y="1135"  fill="rgb(237 28 36)">.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q</text><text x="2076" y="1135"  fill="rgb(255 255 255)">.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATION</text><text x="0" y="1140"  fill="rgb(255 255 255)">S&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOption</text><text x="480" y="1140"  fill="rgb(237 28 36)">s(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.</text><text x="906" y="1140"  fill="rgb(255 255 255)">keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least </text><text x="1707" y="1140"  fill="rgb(237 28 36)">one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it</text><text x="2076" y="1140"  fill="rgb(255 255 255)"> to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) </text><text x="0" y="1145"  fill="rgb(255 255 255)">{ throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1]))))</text><text x="477" y="1145"  fill="rgb(237 28 36)"> { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an ar</text><text x="903" y="1145"  fill="rgb(255 255 255)">ray, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.le</text><text x="1710" y="1145"  fill="rgb(237 28 36)">ngth === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.trans</text><text x="2079" y="1145"  fill="rgb(255 255 255)">formationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: </text><text x="0" y="1150"  fill="rgb(255 255 255)">string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[</text><text x="474" y="1150"  fill="rgb(237 28 36)">] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.va</text><text x="900" y="1150"  fill="rgb(255 255 255)">lidateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } </text><text x="1716" y="1150"  fill="rgb(237 28 36)">} } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUM</text><text x="2079" y="1150"  fill="rgb(255 255 255)">NS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } pri</text><text x="0" y="1155"  fill="rgb(255 255 255)">vate validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if</text><text x="471" y="1155"  fill="rgb(237 28 36)"> (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } }</text><text x="897" y="1155"  fill="rgb(255 255 255)"> private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightEr</text><text x="1719" y="1155"  fill="rgb(237 28 36)">ror(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArra</text><text x="2079" y="1155"  fill="rgb(255 255 255)">y(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new Ins</text><text x="0" y="1160"  fill="rgb(255 255 255)">ightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.</text><text x="471" y="1160"  fill="rgb(237 28 36)">validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key:</text><text x="897" y="1160"  fill="rgb(255 255 255)"> string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateI</text><text x="1725" y="1160"  fill="rgb(237 28 36)">S(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !==</text><text x="2079" y="1160"  fill="rgb(255 255 255)"> &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;)</text><text x="0" y="1165"  fill="rgb(255 255 255)"> { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if </text><text x="468" y="1165"  fill="rgb(237 28 36)">(skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.v</text><text x="894" y="1165"  fill="rgb(255 255 255)">alues(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (type</text><text x="1728" y="1165"  fill="rgb(237 28 36)">of value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.k</text><text x="2079" y="1165"  fill="rgb(255 255 255)">eys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = m</text><text x="0" y="1170"  fill="rgb(255 255 255)">key[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { thro</text><text x="465" y="1170"  fill="rgb(237 28 36)">w new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(</text><text x="891" y="1170"  fill="rgb(255 255 255)">); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idst</text><text x="1731" y="1170"  fill="rgb(237 28 36)">ring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = t</text><text x="2079" y="1170"  fill="rgb(255 255 255)">his.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { retu</text><text x="0" y="1175"  fill="rgb(255 255 255)">rn this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, Insight</text><text x="462" y="1175"  fill="rgb(237 28 36)">Error} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audi</text><text x="888" y="1175"  fill="rgb(255 255 255)">t&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furnitur</text><text x="1737" y="1175"  fill="rgb(237 28 36)">e&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] </text><text x="2079" y="1175"  fill="rgb(255 255 255)">= [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in colu</text><text x="0" y="1180"  fill="rgb(255 255 255)">mns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset:</text><text x="462" y="1180"  fill="rgb(237 28 36)"> InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []</text><text x="885" y="1180"  fill="rgb(255 255 255)">; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRAN</text><text x="1740" y="1180"  fill="rgb(237 28 36)">SFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validate</text><text x="2079" y="1180"  fill="rgb(255 255 255)">Transformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP =</text><text x="0" y="1185"  fill="rgb(255 255 255)">== &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validate</text><text x="459" y="1185"  fill="rgb(237 28 36)">APPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an </text><text x="882" y="1185"  fill="rgb(255 255 255)">object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.lengt</text><text x="1743" y="1185"  fill="rgb(237 28 36)">h !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(spli</text><text x="2082" y="1185"  fill="rgb(255 255 255)">ttedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.is</text><text x="0" y="1190"  fill="rgb(255 255 255)">Array(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(apply</text><text x="456" y="1190"  fill="rgb(237 28 36)">rule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = app</text><text x="882" y="1190"  fill="rgb(255 255 255)">lyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let appl</text><text x="1746" y="1190"  fill="rgb(237 28 36)">ytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(apply</text><text x="2082" y="1190"  fill="rgb(255 255 255)">token)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError()</text><text x="0" y="1195"  fill="rgb(255 255 255)">; } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else</text><text x="453" y="1195"  fill="rgb(237 28 36)"> if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1</text><text x="879" y="1195"  fill="rgb(255 255 255)">])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); </text><text x="1749" y="1195"  fill="rgb(237 28 36)">} } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mske</text><text x="2082" y="1195"  fill="rgb(255 255 255)">y of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this</text><text x="0" y="1200"  fill="rgb(255 255 255)">.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else</text><text x="453" y="1200"  fill="rgb(237 28 36)"> if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(</text><text x="876" y="1200"  fill="rgb(255 255 255)">q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw n</text><text x="1752" y="1200"  fill="rgb(237 28 36)">ew InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError</text><text x="2082" y="1200"  fill="rgb(255 255 255)">(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).len</text><text x="0" y="1205"  fill="rgb(255 255 255)">gth !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: </text><text x="450" y="1205"  fill="rgb(237 28 36)">case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ</text><text x="873" y="1205"  fill="rgb(255 255 255)">(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;obje</text><text x="1758" y="1205"  fill="rgb(237 28 36)">ct&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let sk</text><text x="2082" y="1205"  fill="rgb(255 255 255)">ey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]</text><text x="0" y="1210"  fill="rgb(255 255 255)">; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.sl</text><text x="447" y="1210"  fill="rgb(237 28 36)">ice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private v</text><text x="873" y="1210"  fill="rgb(255 255 255)">alidateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string </text><text x="1761" y="1210"  fill="rgb(237 28 36)">= mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(</text><text x="2082" y="1210"  fill="rgb(255 255 255)">idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray</text><text x="0" y="1215"  fill="rgb(255 255 255)">(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIds</text><text x="447" y="1215"  fill="rgb(237 28 36)">tring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset</text><text x="870" y="1215"  fill="rgb(255 255 255)">.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { r</text><text x="1761" y="1215"  fill="rgb(237 28 36)">eturn this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } i</text><text x="2082" y="1215"  fill="rgb(255 255 255)">mport {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly co</text><text x="0" y="1220"  fill="rgb(255 255 255)">ursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;</text><text x="444" y="1220"  fill="rgb(237 28 36)">uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, </text><text x="867" y="1220"  fill="rgb(255 255 255)">&quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, </text><text x="1221" y="1220"  fill="rgb(24 158 180)">&quot;SUM&quot;]; private readonly mstoken: strin</text><text x="1338" y="1220"  fill="rgb(255 255 255)">g[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in co</text><text x="1764" y="1220"  fill="rgb(237 28 36)">lumns after being validated private transformationKey: string[]; // keys appeared in transformation, if th</text><text x="2082" y="1220"  fill="rgb(255 255 255)">ere is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insi</text><text x="0" y="1225"  fill="rgb(255 255 255)">ghtDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets;</text><text x="441" y="1225"  fill="rgb(237 28 36)"> } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key </text><text x="864" y="1225"  fill="rgb(255 255 255)">!== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere</text><text x="1203" y="1225"  fill="rgb(24 158 180)">(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransfo</text><text x="1371" y="1225"  fill="rgb(255 255 255)">rmations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP </text><text x="1767" y="1225"  fill="rgb(237 28 36)">=== &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightErro</text><text x="2082" y="1225"  fill="rgb(255 255 255)">r(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length </text><text x="0" y="1230"  fill="rgb(255 255 255)">&lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.t</text><text x="441" y="1230"  fill="rgb(237 28 36)">ransformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey</text><text x="864" y="1230"  fill="rgb(255 255 255)">: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validate</text><text x="1188" y="1230"  fill="rgb(24 158 180)">Idstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]</text><text x="1383" y="1230"  fill="rgb(255 255 255)">) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.is</text><text x="1770" y="1230"  fill="rgb(237 28 36)">Array(q)) { throw new InsightError(); // q should be an array, and should have at least one element } fo</text><text x="2082" y="1230"  fill="rgb(255 255 255)">r (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: str</text><text x="0" y="1235"  fill="rgb(255 255 255)">ing = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey</text><text x="438" y="1235"  fill="rgb(237 28 36)">.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria</text><text x="861" y="1235"  fill="rgb(255 255 255)">).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.</text><text x="1176" y="1235"  fill="rgb(24 158 180)">mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { thro</text><text x="1395" y="1235"  fill="rgb(255 255 255)">w new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError();</text><text x="1773" y="1235"  fill="rgb(237 28 36)"> } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(</text><text x="2085" y="1235"  fill="rgb(255 255 255)">key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfiel</text><text x="0" y="1240"  fill="rgb(255 255 255)">ds.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[</text><text x="435" y="1240"  fill="rgb(237 28 36)">] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.</text><text x="858" y="1240"  fill="rgb(255 255 255)">COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!</text><text x="1167" y="1240"  fill="rgb(24 158 180)">q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this</text><text x="1407" y="1240"  fill="rgb(255 255 255)">.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.v</text><text x="1776" y="1240"  fill="rgb(237 28 36)">alidateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.</text><text x="2085" y="1240"  fill="rgb(255 255 255)">isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError();</text><text x="0" y="1245"  fill="rgb(255 255 255)"> } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw n</text><text x="435" y="1245"  fill="rgb(237 28 36)">ew InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of ke</text><text x="858" y="1245"  fill="rgb(255 255 255)">ys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhe</text><text x="1158" y="1245"  fill="rgb(24 158 180)">re(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Obje</text><text x="1416" y="1245"  fill="rgb(255 255 255)">ct.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length</text><text x="1779" y="1245"  fill="rgb(237 28 36)"> !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Obj</text><text x="2085" y="1245"  fill="rgb(255 255 255)">ect.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case</text><text x="0" y="1250"  fill="rgb(255 255 255)"> &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } }</text><text x="432" y="1250"  fill="rgb(237 28 36)"> } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private</text><text x="855" y="1250"  fill="rgb(255 255 255)"> validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (O</text><text x="1149" y="1250"  fill="rgb(24 158 180)">bject.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.ke</text><text x="1425" y="1250"  fill="rgb(255 255 255)">ys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; le</text><text x="1782" y="1250"  fill="rgb(237 28 36)">t sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { th</text><text x="2085" y="1250"  fill="rgb(255 255 255)">row new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield</text><text x="0" y="1255"  fill="rgb(255 255 255)">)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !=</text><text x="429" y="1255"  fill="rgb(237 28 36)">= 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); </text><text x="852" y="1255"  fill="rgb(255 255 255)">} else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.val</text><text x="1140" y="1255"  fill="rgb(24 158 180)">ues(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.</text><text x="1434" y="1255"  fill="rgb(255 255 255)">includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(val</text><text x="1782" y="1255"  fill="rgb(237 28 36)">ue) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validate</text><text x="2085" y="1255"  fill="rgb(255 255 255)">Filter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset </text><text x="0" y="1260"  fill="rgb(255 255 255)">of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKin</text><text x="429" y="1260"  fill="rgb(237 28 36)">d.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = </text><text x="849" y="1260"  fill="rgb(255 255 255)">this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(ids</text><text x="1131" y="1260"  fill="rgb(24 158 180)">tring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, Insigh</text><text x="1440" y="1260"  fill="rgb(255 255 255)">tDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursem</text><text x="1785" y="1260"  fill="rgb(237 28 36)">fields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[</text><text x="2085" y="1260"  fill="rgb(255 255 255)">] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly room</text><text x="0" y="1265"  fill="rgb(255 255 255)">sfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = </text><text x="426" y="1265"  fill="rgb(237 28 36)">[&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has on</text><text x="849" y="1265"  fill="rgb(255 255 255)">e id private keysInQuery: string[]; // all keys appeared in columns after being validated p</text><text x="1122" y="1265"  fill="rgb(24 158 180)">rivate transformationKey: string[]; // keys appeared in transformation, if there is a transformation private </text><text x="1449" y="1265"  fill="rgb(255 255 255)">allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDat</text><text x="1788" y="1265"  fill="rgb(237 28 36)">asets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = [];</text><text x="2085" y="1265"  fill="rgb(255 255 255)"> this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError();</text><text x="0" y="1270"  fill="rgb(255 255 255)"> } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } t</text><text x="423" y="1270"  fill="rgb(237 28 36)">his.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } pu</text><text x="846" y="1270"  fill="rgb(255 255 255)">blic validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof </text><text x="1116" y="1270"  fill="rgb(24 158 180)">q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP)</text><text x="1455" y="1270"  fill="rgb(255 255 255)">; this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { </text><text x="1791" y="1270"  fill="rgb(237 28 36)">throw new InsightError(); // q should be an object, and should has at least one element } for (let</text><text x="2085" y="1270"  fill="rgb(255 255 255)"> key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private val</text><text x="0" y="1275"  fill="rgb(255 255 255)">idateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(t</text><text x="423" y="1275"  fill="rgb(237 28 36)">his.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new Insig</text><text x="843" y="1275"  fill="rgb(255 255 255)">htError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new </text><text x="1107" y="1275"  fill="rgb(24 158 180)">InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.is</text><text x="1464" y="1275"  fill="rgb(255 255 255)">Array(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Ob</text><text x="1794" y="1275"  fill="rgb(237 28 36)">ject.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applyke</text><text x="2085" y="1275"  fill="rgb(255 255 255)">y.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Arr</text><text x="0" y="1280"  fill="rgb(255 255 255)">ay.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; i</text><text x="420" y="1280"  fill="rgb(237 28 36)">f (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applyt</text><text x="843" y="1280"  fill="rgb(255 255 255)">oken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.</text><text x="1101" y="1280"  fill="rgb(24 158 180)">includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); </text><text x="1470" y="1280"  fill="rgb(255 255 255)">} } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.inclu</text><text x="1794" y="1280"  fill="rgb(237 28 36)">des(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public valida</text><text x="2085" y="1280"  fill="rgb(255 255 255)">teOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new </text><text x="0" y="1285"  fill="rgb(255 255 255)">InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void {</text><text x="420" y="1285"  fill="rgb(237 28 36)"> if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformat</text><text x="840" y="1285"  fill="rgb(255 255 255)">ionKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey</text><text x="1095" y="1285"  fill="rgb(24 158 180)">); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); </text><text x="1476" y="1285"  fill="rgb(255 255 255)">} else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else</text><text x="1797" y="1285"  fill="rgb(237 28 36)"> { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir</text><text x="2085" y="1285"  fill="rgb(255 255 255)"> !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw </text><text x="0" y="1290"  fill="rgb(255 255 255)">new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validat</text><text x="417" y="1290"  fill="rgb(237 28 36)">eWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); </text><text x="840" y="1290"  fill="rgb(255 255 255)">} } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { thr</text><text x="1089" y="1290"  fill="rgb(24 158 180)">ow new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND</text><text x="1482" y="1290"  fill="rgb(255 255 255)">&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: cas</text><text x="1800" y="1290"  fill="rgb(237 28 36)">e &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break;</text><text x="2085" y="1290"  fill="rgb(255 255 255)"> default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(</text><text x="0" y="1295"  fill="rgb(255 255 255)">); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (</text><text x="417" y="1295"  fill="rgb(237 28 36)">Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2)</text><text x="837" y="1295"  fill="rgb(255 255 255)"> { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: </text><text x="1083" y="1295"  fill="rgb(24 158 180)">string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.sl</text><text x="1488" y="1295"  fill="rgb(255 255 255)">ice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw </text><text x="1803" y="1295"  fill="rgb(237 28 36)">new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;o</text><text x="2085" y="1295"  fill="rgb(255 255 255)">bject&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.l</text><text x="0" y="1300"  fill="rgb(255 255 255)">ength !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.valu</text><text x="414" y="1300"  fill="rgb(237 28 36)">es(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(</text><text x="834" y="1300"  fill="rgb(255 255 255)">); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || v</text><text x="1077" y="1300"  fill="rgb(24 158 180)">alue.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstr</text><text x="1494" y="1300"  fill="rgb(255 255 255)">ing(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.all</text><text x="1803" y="1300"  fill="rgb(237 28 36)">InsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insi</text><text x="2088" y="1300"  fill="rgb(255 255 255)">ghtDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfi</text><text x="0" y="1305"  fill="rgb(255 255 255)">elds = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstri</text><text x="411" y="1305"  fill="rgb(237 28 36)">ng); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsi</text><text x="834" y="1305"  fill="rgb(255 255 255)">ghtFacade&quot;; export default class QueryValidator { private readonly coursemfield</text><text x="1071" y="1305"  fill="rgb(24 158 180)">s: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;</text><text x="1500" y="1305"  fill="rgb(255 255 255)">]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: str</text><text x="1806" y="1305"  fill="rgb(237 28 36)">ing[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; </text><text x="2088" y="1305"  fill="rgb(255 255 255)">private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: stri</text><text x="0" y="1310"  fill="rgb(255 255 255)">ng[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private</text><text x="411" y="1310"  fill="rgb(237 28 36)"> transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; </text><text x="831" y="1310"  fill="rgb(255 255 255)">private mfields: string[]; private sfields: string[]; constructor(insightDatas</text><text x="1065" y="1310"  fill="rgb(24 158 180)">ets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } publi</text><text x="1506" y="1310"  fill="rgb(255 255 255)">c validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let k</text><text x="1809" y="1310"  fill="rgb(237 28 36)">ey of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;</text><text x="2088" y="1310"  fill="rgb(255 255 255)">) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); </text><text x="0" y="1315"  fill="rgb(255 255 255)">} this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY</text><text x="408" y="1315"  fill="rgb(237 28 36)"> === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } p</text><text x="828" y="1315"  fill="rgb(255 255 255)">rivate validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { </text><text x="1062" y="1315"  fill="rgb(24 158 180)">throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transforma</text><text x="1509" y="1315"  fill="rgb(255 255 255)">tionKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key:</text><text x="1809" y="1315"  fill="rgb(237 28 36)"> string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { </text><text x="2088" y="1315"  fill="rgb(255 255 255)">throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.include</text><text x="0" y="1320"  fill="rgb(255 255 255)">s(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightErr</text><text x="408" y="1320"  fill="rgb(237 28 36)">or(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys</text><text x="828" y="1320"  fill="rgb(255 255 255)">(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string =</text><text x="1056" y="1320"  fill="rgb(24 158 180)"> Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(ap</text><text x="1515" y="1320"  fill="rgb(255 255 255)">plykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(cri</text><text x="1812" y="1320"  fill="rgb(237 28 36)">teria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: st</text><text x="2088" y="1320"  fill="rgb(255 255 255)">ring = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError();</text><text x="0" y="1325"  fill="rgb(255 255 255)"> } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(ap</text><text x="405" y="1325"  fill="rgb(237 28 36)">plytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.in</text><text x="825" y="1325"  fill="rgb(255 255 255)">cludes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.</text><text x="1050" y="1325"  fill="rgb(24 158 180)">includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys</text><text x="1521" y="1325"  fill="rgb(255 255 255)">(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError();</text><text x="1815" y="1325"  fill="rgb(237 28 36)"> } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } priva</text><text x="2088" y="1325"  fill="rgb(255 255 255)">te validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKe</text><text x="0" y="1330"  fill="rgb(255 255 255)">y.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.key</text><text x="405" y="1330"  fill="rgb(237 28 36)">sInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;s</text><text x="825" y="1330"  fill="rgb(255 255 255)">tring&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); }</text><text x="1047" y="1330"  fill="rgb(24 158 180)"> } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(</text><text x="1524" y="1330"  fill="rgb(255 255 255)">); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError</text><text x="1818" y="1330"  fill="rgb(237 28 36)">(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new Insig</text><text x="2088" y="1330"  fill="rgb(255 255 255)">htError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).len</text><text x="0" y="1335"  fill="rgb(255 255 255)">gth !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new Insight</text><text x="402" y="1335"  fill="rgb(237 28 36)">Error(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.vali</text><text x="822" y="1335"  fill="rgb(255 255 255)">dateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case</text><text x="1041" y="1335"  fill="rgb(24 158 180)"> &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validate</text><text x="1530" y="1335"  fill="rgb(255 255 255)">NOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.valida</text><text x="1818" y="1335"  fill="rgb(237 28 36)">teFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) {</text><text x="2088" y="1335"  fill="rgb(255 255 255)"> throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0</text><text x="0" y="1340"  fill="rgb(255 255 255)">].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]</text><text x="402" y="1340"  fill="rgb(237 28 36)">; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;</text><text x="822" y="1340"  fill="rgb(255 255 255)">*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfiel</text><text x="1038" y="1340"  fill="rgb(24 158 180)">d)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new Insi</text><text x="1533" y="1340"  fill="rgb(255 255 255)">ghtError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { th</text><text x="1821" y="1340"  fill="rgb(237 28 36)">row new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mke</text><text x="2088" y="1340"  fill="rgb(255 255 255)">y[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes</text><text x="0" y="1345"  fill="rgb(255 255 255)">(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) {</text><text x="402" y="1345"  fill="rgb(237 28 36)"> throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: stri</text><text x="819" y="1345"  fill="rgb(255 255 255)">ng): boolean { if (this.idInQuery.length === 0) { for (let insightDatas</text><text x="1032" y="1345"  fill="rgb(24 158 180)">et of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfiel</text><text x="1539" y="1345"  fill="rgb(255 255 255)">ds = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommf</text><text x="1824" y="1345"  fill="rgb(237 28 36)">ields; this.sfields = this.roomsfields; } return true; } } return false; } else { return</text><text x="2088" y="1345"  fill="rgb(255 255 255)"> this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatas</text><text x="0" y="1350"  fill="rgb(255 255 255)">etKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg</text><text x="399" y="1350"  fill="rgb(237 28 36)">&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private read</text><text x="816" y="1350"  fill="rgb(255 255 255)">only roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly </text><text x="1029" y="1350"  fill="rgb(24 158 180)">roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SU</text><text x="1542" y="1350"  fill="rgb(255 255 255)">M&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure</text><text x="1824" y="1350"  fill="rgb(237 28 36)"> the query only has one id private keysInQuery: string[]; // all keys appeared in column</text><text x="2088" y="1350"  fill="rgb(255 255 255)">s after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private all</text><text x="0" y="1355"  fill="rgb(255 255 255)">InsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]</text><text x="399" y="1355"  fill="rgb(237 28 36)">) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q:</text><text x="816" y="1355"  fill="rgb(255 255 255)"> any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightErr</text><text x="1026" y="1355"  fill="rgb(24 158 180)">or(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); </text><text x="1548" y="1355"  fill="rgb(255 255 255)">if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOpti</text><text x="1827" y="1355"  fill="rgb(237 28 36)">ons(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP ===</text><text x="2088" y="1355"  fill="rgb(255 255 255)"> &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP);</text><text x="0" y="1360"  fill="rgb(255 255 255)"> this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightErro</text><text x="396" y="1360"  fill="rgb(237 28 36)">r(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.pus</text><text x="813" y="1360"  fill="rgb(255 255 255)">h(key); // if the key is valid, push it to transformationKey } } priv</text><text x="1020" y="1360"  fill="rgb(24 158 180)">ate validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splitted</text><text x="1551" y="1360"  fill="rgb(255 255 255)">Key[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))</text><text x="1827" y="1360"  fill="rgb(237 28 36)">) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isAr</text><text x="2088" y="1360"  fill="rgb(255 255 255)">ray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.</text><text x="0" y="1365"  fill="rgb(255 255 255)">isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)</text><text x="396" y="1365"  fill="rgb(237 28 36)">[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) </text><text x="813" y="1365"  fill="rgb(255 255 255)">{ throw new InsightError(); } this.transformationKey.push(applykey);</text><text x="1017" y="1365"  fill="rgb(24 158 180)"> if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applyt</text><text x="1554" y="1365"  fill="rgb(255 255 255)">oken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[]</text><text x="1830" y="1365"  fill="rgb(237 28 36)"> = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); </text><text x="2088" y="1365"  fill="rgb(255 255 255)">} if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError</text><text x="0" y="1370"  fill="rgb(255 255 255)">(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this</text><text x="393" y="1370"  fill="rgb(237 28 36)">.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); f</text><text x="810" y="1370"  fill="rgb(255 255 255)">or (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { t</text><text x="1014" y="1370"  fill="rgb(24 158 180)">hrow new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw </text><text x="1560" y="1370"  fill="rgb(255 255 255)">new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!</text><text x="1833" y="1370"  fill="rgb(237 28 36)">this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.v</text><text x="2088" y="1370"  fill="rgb(255 255 255)">alidateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightErr</text><text x="0" y="1375"  fill="rgb(255 255 255)">or(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !</text><text x="393" y="1375"  fill="rgb(237 28 36)">q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } </text><text x="810" y="1375"  fill="rgb(255 255 255)">let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1</text><text x="1011" y="1375"  fill="rgb(24 158 180)">) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.is</text><text x="1563" y="1375"  fill="rgb(255 255 255)">Array(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.val</text><text x="1833" y="1375"  fill="rgb(237 28 36)">idateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).lengt</text><text x="2088" y="1375"  fill="rgb(255 255 255)">h !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { c</text><text x="0" y="1380"  fill="rgb(255 255 255)">ase &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;</text><text x="393" y="1380"  fill="rgb(237 28 36)">: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNO</text><text x="807" y="1380"  fill="rgb(255 255 255)">T(value: any): void { if (typeof value !== &quot;object&quot;) { throw new Ins</text><text x="1011" y="1380"  fill="rgb(24 158 180)">ightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { t</text><text x="1566" y="1380"  fill="rgb(255 255 255)">hrow new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey</text><text x="1836" y="1380"  fill="rgb(237 28 36)">.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; </text><text x="2088" y="1380"  fill="rgb(255 255 255)">let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { i</text><text x="0" y="1385"  fill="rgb(255 255 255)">f ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightErro</text><text x="390" y="1385"  fill="rgb(237 28 36)">r(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new Insig</text><text x="807" y="1385"  fill="rgb(255 255 255)">htError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); </text><text x="1011" y="1385"  fill="rgb(24 158 180)">if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;num</text><text x="1569" y="1385"  fill="rgb(255 255 255)">ber&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new I</text><text x="1839" y="1385"  fill="rgb(237 28 36)">nsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(v</text><text x="2088" y="1385"  fill="rgb(255 255 255)">alue) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private v</text><text x="0" y="1390"  fill="rgb(255 255 255)">alidateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset)</text><text x="390" y="1390"  fill="rgb(237 28 36)"> { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfi</text><text x="804" y="1390"  fill="rgb(255 255 255)">elds = this.coursemfields; this.sfields = this.coursesfields; } else </text><text x="1011" y="1390"  fill="rgb(24 158 180)">{ this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] </text><text x="1575" y="1390"  fill="rgb(255 255 255)">{ return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} f</text><text x="1839" y="1390"  fill="rgb(237 28 36)">rom &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly cour</text><text x="2088" y="1390"  fill="rgb(255 255 255)">semfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;</text><text x="0" y="1395"  fill="rgb(255 255 255)">title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;full</text><text x="390" y="1395"  fill="rgb(237 28 36)">name&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, </text><text x="804" y="1395"  fill="rgb(255 255 255)">&quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQu</text><text x="1014" y="1395"  fill="rgb(24 158 180)">ery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appe</text><text x="1578" y="1395"  fill="rgb(255 255 255)">ared in transformation, if there is a transformation private allInsightDataset: InsightD</text><text x="1842" y="1395"  fill="rgb(237 28 36)">ataset[]; private mfields: string[]; private sfields: string[]; constructor(insigh</text><text x="2088" y="1395"  fill="rgb(255 255 255)">tDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightD</text><text x="0" y="1400"  fill="rgb(255 255 255)">atasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object</text><text x="387" y="1400"  fill="rgb(237 28 36)">.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WH</text><text x="801" y="1400"  fill="rgb(255 255 255)">ERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.T</text><text x="990" y="1400"  fill="rgb(24 158 180)">RA</text><text x="996" y="1400"  fill="rgb(255 255 255)">NSFORMA</text><text x="1017" y="1400"  fill="rgb(24 158 180)">TIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !=</text><text x="1581" y="1400"  fill="rgb(255 255 255)">= 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.AP</text><text x="1842" y="1400"  fill="rgb(237 28 36)">PLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; </text><text x="2088" y="1400"  fill="rgb(255 255 255)">1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key)</text><text x="0" y="1405"  fill="rgb(255 255 255)">; this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): vo</text><text x="387" y="1405"  fill="rgb(237 28 36)">id { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(s</text><text x="801" y="1405"  fill="rgb(255 255 255)">plittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || th</text><text x="987" y="1405"  fill="rgb(24 158 180)">is.s</text><text x="999" y="1405"  fill="rgb(255 255 255)">fields.</text><text x="1020" y="1405"  fill="rgb(24 158 180)">includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should hav</text><text x="1584" y="1405"  fill="rgb(255 255 255)">e at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Obj</text><text x="1845" y="1405"  fill="rgb(237 28 36)">ect.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: strin</text><text x="2088" y="1405"  fill="rgb(255 255 255)">g = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transforma</text><text x="0" y="1410"  fill="rgb(255 255 255)">tionKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || O</text><text x="387" y="1410"  fill="rgb(237 28 36)">bject.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includ</text><text x="798" y="1410"  fill="rgb(255 255 255)">es(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw </text><text x="984" y="1410"  fill="rgb(24 158 180)">new In</text><text x="1002" y="1410"  fill="rgb(255 255 255)">sightEr</text><text x="1023" y="1410"  fill="rgb(24 158 180)">ror(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]</text><text x="1587" y="1410"  fill="rgb(255 255 255)">) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mst</text><text x="1845" y="1410"  fill="rgb(237 28 36)">oken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields</text><text x="2088" y="1410"  fill="rgb(255 255 255)">.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys</text><text x="0" y="1415"  fill="rgb(255 255 255)">: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this</text><text x="384" y="1415"  fill="rgb(237 28 36)">.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; </text><text x="798" y="1415"  fill="rgb(255 255 255)">1) { throw new InsightError(); } for (let mskey of q) { if (t</text><text x="981" y="1415"  fill="rgb(24 158 180)">his.tra</text><text x="1002" y="1415"  fill="rgb(255 255 255)">nsformat</text><text x="1026" y="1415"  fill="rgb(24 158 180)">ionKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(</text><text x="1590" y="1415"  fill="rgb(255 255 255)">q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q </text><text x="1848" y="1415"  fill="rgb(237 28 36)">=== &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); }</text><text x="2088" y="1415"  fill="rgb(255 255 255)"> } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { t</text><text x="0" y="1420"  fill="rgb(255 255 255)">hrow new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } fo</text><text x="384" y="1420"  fill="rgb(237 28 36)">r (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void {</text><text x="795" y="1420"  fill="rgb(255 255 255)"> if (Array.isArray(q)) { throw new InsightError(); } else { i</text><text x="978" y="1420"  fill="rgb(24 158 180)">f (Objec</text><text x="1002" y="1420"  fill="rgb(255 255 255)">t.keys(q).</text><text x="1032" y="1420"  fill="rgb(24 158 180)">length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)</text><text x="1593" y="1420"  fill="rgb(255 255 255)">[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.</text><text x="1851" y="1420"  fill="rgb(237 28 36)">validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;</text><text x="2088" y="1420"  fill="rgb(255 255 255)">GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError()</text><text x="0" y="1425"  fill="rgb(255 255 255)">; } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter</text><text x="384" y="1425"  fill="rgb(237 28 36)">(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).len</text><text x="795" y="1425"  fill="rgb(255 255 255)">gth !== 1) { throw new InsightError(); } let skey: string[] </text><text x="975" y="1425"  fill="rgb(24 158 180)">= Object.</text><text x="1002" y="1425"  fill="rgb(255 255 255)">keys(value)</text><text x="1035" y="1425"  fill="rgb(24 158 180)">[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeo</text><text x="1596" y="1425"  fill="rgb(255 255 255)">f str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includ</text><text x="1851" y="1425"  fill="rgb(237 28 36)">es(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield))</text><text x="2088" y="1425"  fill="rgb(255 255 255)"> { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).lengt</text><text x="0" y="1430"  fill="rgb(255 255 255)">h !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw ne</text><text x="381" y="1430"  fill="rgb(237 28 36)">w InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typ</text><text x="792" y="1430"  fill="rgb(255 255 255)">eof num !== &quot;number&quot;) || !this.validateIdstring(idstring) ||</text><text x="972" y="1430"  fill="rgb(24 158 180)"> !this.mfi</text><text x="1002" y="1430"  fill="rgb(255 255 255)">elds.includes</text><text x="1041" y="1430"  fill="rgb(24 158 180)">(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of</text><text x="1599" y="1430"  fill="rgb(255 255 255)"> value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: st</text><text x="1854" y="1430"  fill="rgb(237 28 36)">ring): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of</text><text x="2088" y="1430"  fill="rgb(255 255 255)"> this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatase</text><text x="0" y="1435"  fill="rgb(255 255 255)">tKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields</text><text x="381" y="1435"  fill="rgb(237 28 36)">; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdIn</text><text x="792" y="1435"  fill="rgb(255 255 255)">Query(): string[] { return this.idInQuery; } } import {Insi</text><text x="969" y="1435"  fill="rgb(24 158 180)">ghtDataset,</text><text x="1002" y="1435"  fill="rgb(255 255 255)"> InsightDataset</text><text x="1047" y="1435"  fill="rgb(24 158 180)">Kind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly </text><text x="1602" y="1435"  fill="rgb(255 255 255)">coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private rea</text><text x="1854" y="1435"  fill="rgb(237 28 36)">donly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsf</text><text x="2088" y="1435"  fill="rgb(255 255 255)">ields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[]</text><text x="0" y="1440"  fill="rgb(255 255 255)"> = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the </text><text x="381" y="1440"  fill="rgb(237 28 36)">query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: st</text><text x="789" y="1440"  fill="rgb(255 255 255)">ring[]; // keys appeared in transformation, if there is a t</text><text x="966" y="1440"  fill="rgb(24 158 180)">ransformation</text><text x="1005" y="1440"  fill="rgb(255 255 255)"> private allIns</text><text x="1050" y="1440"  fill="rgb(24 158 180)">ightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.tr</text><text x="1605" y="1440"  fill="rgb(255 255 255)">ansformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q:</text><text x="1857" y="1440"  fill="rgb(237 28 36)"> any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); }</text><text x="2088" y="1440"  fill="rgb(255 255 255)"> for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } }</text><text x="0" y="1445"  fill="rgb(255 255 255)"> this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions</text><text x="378" y="1445"  fill="rgb(237 28 36)">(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Obj</text><text x="789" y="1445"  fill="rgb(255 255 255)">ect.keys(q).length !== 2) { throw new InsightError(); } th</text><text x="963" y="1445"  fill="rgb(24 158 180)">is.validateGRO</text><text x="1005" y="1445"  fill="rgb(255 255 255)">UP(q.GROUP); this</text><text x="1056" y="1445"  fill="rgb(24 158 180)">.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least on</text><text x="1608" y="1445"  fill="rgb(255 255 255)">e element } for (let key of q) { this.validateKey(key); this.transformationKey.push</text><text x="1857" y="1445"  fill="rgb(237 28 36)">(key); // if the key is valid, push it to transformationKey } } private valid</text><text x="2088" y="1445"  fill="rgb(255 255 255)">ateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!</text><text x="0" y="1450"  fill="rgb(255 255 255)">(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) {</text><text x="378" y="1450"  fill="rgb(237 28 36)"> throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be a</text><text x="786" y="1450"  fill="rgb(255 255 255)">n array, and should have at least one element } for (let a</text><text x="960" y="1450"  fill="rgb(24 158 180)">pplyrule of q) </text><text x="1005" y="1450"  fill="rgb(255 255 255)">{ if (Array.isArray</text><text x="1062" y="1450"  fill="rgb(24 158 180)">(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.leng</text><text x="1611" y="1450"  fill="rgb(255 255 255)">th === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { </text><text x="1860" y="1450"  fill="rgb(237 28 36)">throw new InsightError(); } this.transformationKey.push(applykey); if (Array</text><text x="2088" y="1450"  fill="rgb(255 255 255)">.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; </text><text x="0" y="1455"  fill="rgb(255 255 255)">if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] =</text><text x="378" y="1455"  fill="rgb(237 28 36)"> criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this</text><text x="786" y="1455"  fill="rgb(255 255 255)">.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]</text><text x="957" y="1455"  fill="rgb(24 158 180)">))) { throw new </text><text x="1005" y="1455"  fill="rgb(255 255 255)">InsightError(); } } </text><text x="1065" y="1455"  fill="rgb(24 158 180)">else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } }</text><text x="1614" y="1455"  fill="rgb(255 255 255)"> } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for </text><text x="1860" y="1455"  fill="rgb(237 28 36)">(let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new In</text><text x="2088" y="1455"  fill="rgb(255 255 255)">sightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void </text><text x="0" y="1460"  fill="rgb(255 255 255)">{ if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!t</text><text x="378" y="1460"  fill="rgb(237 28 36)">his.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); </text><text x="783" y="1460"  fill="rgb(255 255 255)">} } private validateOrder(q: any): void { if (Array.isArr</text><text x="954" y="1460"  fill="rgb(24 158 180)">ay(q)) { throw ne</text><text x="1005" y="1460"  fill="rgb(255 255 255)">w InsightError(); } el</text><text x="1071" y="1460"  fill="rgb(24 158 180)">se if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightErr</text><text x="1617" y="1460"  fill="rgb(255 255 255)">or(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let </text><text x="1863" y="1460"  fill="rgb(237 28 36)">keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw ne</text><text x="2088" y="1460"  fill="rgb(255 255 255)">w InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validat</text><text x="0" y="1465"  fill="rgb(255 255 255)">eWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.val</text><text x="375" y="1465"  fill="rgb(237 28 36)">idateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let k</text><text x="783" y="1465"  fill="rgb(255 255 255)">ey: string = Object.keys(q)[0]; let value: any = Object.v</text><text x="954" y="1465"  fill="rgb(24 158 180)">alues(q)[0]; swit</text><text x="1005" y="1465"  fill="rgb(255 255 255)">ch (key) { case &quot;AND&quot;: c</text><text x="1077" y="1465"  fill="rgb(24 158 180)">ase &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateI</text><text x="1620" y="1465"  fill="rgb(255 255 255)">S(value); break; default: throw new InsightError(); } } } private validateNOT(val</text><text x="1863" y="1465"  fill="rgb(237 28 36)">ue: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError();</text><text x="2088" y="1465"  fill="rgb(255 255 255)"> } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (</text><text x="0" y="1470"  fill="rgb(255 255 255)">Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (ske</text><text x="375" y="1470"  fill="rgb(237 28 36)">y.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object</text><text x="783" y="1470"  fill="rgb(255 255 255)">.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw </text><text x="951" y="1470"  fill="rgb(24 158 180)">new InsightError()</text><text x="1005" y="1470"  fill="rgb(255 255 255)">; } else { if ((str.slice(</text><text x="1083" y="1470"  fill="rgb(24 158 180)">1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (type</text><text x="1623" y="1470"  fill="rgb(255 255 255)">of value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightErro</text><text x="1866" y="1470"  fill="rgb(237 28 36)">r(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.len</text><text x="2088" y="1470"  fill="rgb(255 255 255)">gth !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.value</text><text x="0" y="1475"  fill="rgb(255 255 255)">s(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new</text><text x="375" y="1475"  fill="rgb(237 28 36)"> InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightErro</text><text x="780" y="1475"  fill="rgb(255 255 255)">r(); } for (let innerObject of value) { this.validateFil</text><text x="948" y="1475"  fill="rgb(24 158 180)">ter(innerObject); }</text><text x="1005" y="1475"  fill="rgb(255 255 255)"> } private validateIdstring(</text><text x="1089" y="1475"  fill="rgb(24 158 180)">idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idst</text><text x="1626" y="1475"  fill="rgb(255 255 255)">ring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = </text><text x="1866" y="1475"  fill="rgb(237 28 36)">this.coursemfields; this.sfields = this.coursesfields; } else { this.mfiel</text><text x="2088" y="1475"  fill="rgb(255 255 255)">ds = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring</text><text x="0" y="1480"  fill="rgb(255 255 255)">); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError}</text><text x="375" y="1480"  fill="rgb(237 28 36)"> from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;aud</text><text x="780" y="1480"  fill="rgb(255 255 255)">it&quot;, &quot;year&quot;]; private readonly coursesfields: string[] </text><text x="945" y="1480"  fill="rgb(24 158 180)">= [&quot;dept&quot;, &quot;id&quot;, &quot;in</text><text x="1005" y="1480"  fill="rgb(255 255 255)">structor&quot;, &quot;title&quot;, &quot;uuid&quot;]; p</text><text x="1095" y="1480"  fill="rgb(24 158 180)">rivate readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furnitu</text><text x="1629" y="1480"  fill="rgb(255 255 255)">re&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; </text><text x="1869" y="1480"  fill="rgb(237 28 36)">private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string</text><text x="2088" y="1480"  fill="rgb(255 255 255)">[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private t</text><text x="0" y="1485"  fill="rgb(255 255 255)">ransformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: Insi</text><text x="372" y="1485"  fill="rgb(237 28 36)">ghtDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = [</text><text x="777" y="1485"  fill="rgb(255 255 255)">]; this.keysInQuery = []; this.transformationKey = []; </text><text x="942" y="1485"  fill="rgb(24 158 180)">this.allInsightDatase</text><text x="1005" y="1485"  fill="rgb(255 255 255)">t = insightDatasets; } public va</text><text x="1101" y="1485"  fill="rgb(24 158 180)">lidate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TR</text><text x="1629" y="1485"  fill="rgb(255 255 255)">ANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if </text><text x="1869" y="1485"  fill="rgb(237 28 36)">(q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } </text><text x="2088" y="1485"  fill="rgb(255 255 255)">this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY ==</text><text x="0" y="1490"  fill="rgb(255 255 255)">= &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(</text><text x="372" y="1490"  fill="rgb(237 28 36)">q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an </text><text x="777" y="1490"  fill="rgb(255 255 255)">object, and should has at least one element } for (let</text><text x="939" y="1490"  fill="rgb(24 158 180)"> key of q) { this.valid</text><text x="1008" y="1490"  fill="rgb(255 255 255)">ateKey(key); this.transformationK</text><text x="1107" y="1490"  fill="rgb(24 158 180)">ey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.len</text><text x="1632" y="1490"  fill="rgb(255 255 255)">gth !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey</text><text x="1872" y="1490"  fill="rgb(237 28 36)">[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(</text><text x="2088" y="1490"  fill="rgb(255 255 255)">splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(</text><text x="0" y="1495"  fill="rgb(255 255 255)">); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) |</text><text x="372" y="1495"  fill="rgb(237 28 36)">| Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = app</text><text x="777" y="1495"  fill="rgb(255 255 255)">lyrule[applykey]; if (applykey.length === 0 || applyke</text><text x="939" y="1495"  fill="rgb(24 158 180)">y.includes(&quot;_&quot;) || this</text><text x="1008" y="1495"  fill="rgb(255 255 255)">.transformationKey.includes(applyke</text><text x="1113" y="1495"  fill="rgb(24 158 180)">y)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let ap</text><text x="1635" y="1495"  fill="rgb(255 255 255)">plytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytok</text><text x="1872" y="1495"  fill="rgb(237 28 36)">en) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); }</text><text x="2088" y="1495"  fill="rgb(255 255 255)"> let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applyt</text><text x="0" y="1500"  fill="rgb(255 255 255)">oken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (thi</text><text x="372" y="1500"  fill="rgb(237 28 36)">s.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1</text><text x="774" y="1500"  fill="rgb(255 255 255)">])))) { throw new InsightError(); } } } } public valid</text><text x="936" y="1500"  fill="rgb(24 158 180)">ateOptions(q: any): void</text><text x="1008" y="1500"  fill="rgb(255 255 255)"> { let keys: any[] = Object.keys(q); </text><text x="1119" y="1500"  fill="rgb(24 158 180)">for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER)</text><text x="1638" y="1500"  fill="rgb(255 255 255)">; } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw </text><text x="1872" y="1500"  fill="rgb(237 28 36)">new InsightError(); } for (let mskey of q) { if (this.transformationKey.</text><text x="2088" y="1500"  fill="rgb(255 255 255)">length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQ</text><text x="0" y="1505"  fill="rgb(255 255 255)">uery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typ</text><text x="372" y="1505"  fill="rgb(237 28 36)">eof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q</text><text x="774" y="1505"  fill="rgb(255 255 255)">).length !== 2) { throw new InsightError(); } if (q.d</text><text x="933" y="1505"  fill="rgb(24 158 180)">ir !== &quot;UP&quot; &amp;&amp; q.dir !== </text><text x="1008" y="1505"  fill="rgb(255 255 255)">&quot;DOWN&quot;) { throw new InsightError(); } l</text><text x="1125" y="1505"  fill="rgb(24 158 180)">et keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw</text><text x="1641" y="1505"  fill="rgb(255 255 255)"> new InsightError(); } } } } public validateWhere(q: any): void { if (Array.is</text><text x="1875" y="1505"  fill="rgb(237 28 36)">Array(q)) { throw new InsightError(); } else { if (Object.keys(q).lengt</text><text x="2088" y="1505"  fill="rgb(255 255 255)">h !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError</text><text x="0" y="1510"  fill="rgb(255 255 255)">(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR</text><text x="369" y="1510"  fill="rgb(237 28 36)">&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(</text><text x="771" y="1510"  fill="rgb(255 255 255)">value); break; case &quot;IS&quot;: this.validateIS(value); bre</text><text x="930" y="1510"  fill="rgb(24 158 180)">ak; default: throw new Ins</text><text x="1008" y="1510"  fill="rgb(255 255 255)">ightError(); } } } private validateNOT(val</text><text x="1134" y="1510"  fill="rgb(24 158 180)">ue: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;</text><text x="1641" y="1510"  fill="rgb(255 255 255)">object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { </text><text x="1875" y="1510"  fill="rgb(237 28 36)">throw new InsightError(); } let skey: string[] = Object.keys(value)[0].</text><text x="2088" y="1510"  fill="rgb(255 255 255)">split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let</text><text x="0" y="1515"  fill="rgb(255 255 255)"> str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1</text><text x="369" y="1515"  fill="rgb(237 28 36)">).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private va</text><text x="771" y="1515"  fill="rgb(255 255 255)">lidateGTLTEQ(value: any): void { if (typeof value !=</text><text x="927" y="1515"  fill="rgb(24 158 180)">= &quot;object&quot; || Object.keys(v</text><text x="1008" y="1515"  fill="rgb(255 255 255)">alue).length !== 1) { throw new InsightError</text><text x="1140" y="1515"  fill="rgb(24 158 180)">(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: str</text><text x="1644" y="1515"  fill="rgb(255 255 255)">ing = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;nu</text><text x="1878" y="1515"  fill="rgb(237 28 36)">mber&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(m</text><text x="2088" y="1515"  fill="rgb(255 255 255)">field)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { thro</text><text x="0" y="1520"  fill="rgb(255 255 255)">w new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(ids</text><text x="369" y="1520"  fill="rgb(237 28 36)">tring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.i</text><text x="771" y="1520"  fill="rgb(255 255 255)">d === idstring) { this.idInQuery.push(idstring); if </text><text x="927" y="1520"  fill="rgb(24 158 180)">(insightDataset.kind === Ins</text><text x="1011" y="1520"  fill="rgb(255 255 255)">ightDatasetKind.Courses) { this.mfields = this</text><text x="1149" y="1520"  fill="rgb(24 158 180)">.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else </text><text x="1647" y="1520"  fill="rgb(255 255 255)">{ return this.idInQuery.includes(idstring); } } public getIdInQuery(): string</text><text x="1878" y="1520"  fill="rgb(237 28 36)">[] { return this.idInQuery; } } import {InsightDataset, InsightDataset</text><text x="2088" y="1520"  fill="rgb(255 255 255)">Kind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pa</text><text x="0" y="1525"  fill="rgb(255 255 255)">ss&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; pr</text><text x="369" y="1525"  fill="rgb(237 28 36)">ivate readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;n</text><text x="768" y="1525"  fill="rgb(255 255 255)">umber&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;hr</text><text x="924" y="1525"  fill="rgb(24 158 180)">ef&quot;]; private readonly mtoken</text><text x="1011" y="1525"  fill="rgb(255 255 255)">: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; priva</text><text x="1155" y="1525"  fill="rgb(24 158 180)">te readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in</text><text x="1650" y="1525"  fill="rgb(255 255 255)"> columns after being validated private transformationKey: string[]; // keys </text><text x="1878" y="1525"  fill="rgb(237 28 36)">appeared in transformation, if there is a transformation private allIn</text><text x="2088" y="1525"  fill="rgb(255 255 255)">sightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { th</text><text x="0" y="1530"  fill="rgb(255 255 255)">is.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public v</text><text x="369" y="1530"  fill="rgb(237 28 36)">alidate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !==</text><text x="768" y="1530"  fill="rgb(255 255 255)"> &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORM</text><text x="921" y="1530"  fill="rgb(24 158 180)">ATIONS&quot;) { throw new InsightEr</text><text x="1011" y="1530"  fill="rgb(255 255 255)">ror(); } } this.validateWhere(q.WHERE); if (q.TRANS</text><text x="1164" y="1530"  fill="rgb(24 158 180)">FORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GR</text><text x="1650" y="1530"  fill="rgb(255 255 255)">OUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).lengt</text><text x="1881" y="1530"  fill="rgb(237 28 36)">h !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); t</text><text x="2088" y="1530"  fill="rgb(255 255 255)">his.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); //</text><text x="0" y="1535"  fill="rgb(255 255 255)"> q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformati</text><text x="369" y="1535"  fill="rgb(237 28 36)">onKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: s</text><text x="768" y="1535"  fill="rgb(255 255 255)">tring[] = key.split(&quot;_&quot;); if (splittedKey.length !=</text><text x="921" y="1535"  fill="rgb(24 158 180)">= 2) { throw new InsightError(</text><text x="1011" y="1535"  fill="rgb(255 255 255)">); } if (!(this.val</text><text x="1068" y="1535"  fill="rgb(24 158 180)">idate</text><text x="1083" y="1535"  fill="rgb(255 255 255)">Idstring(splittedKey[0]) &amp;&amp; (</text><text x="1170" y="1535"  fill="rgb(24 158 180)">this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Arra</text><text x="1653" y="1535"  fill="rgb(255 255 255)">y.isArray(q)) { throw new InsightError(); // q should be an array, and shoul</text><text x="1881" y="1535"  fill="rgb(237 28 36)">d have at least one element } for (let applyrule of q) { if (Array.is</text><text x="2088" y="1535"  fill="rgb(255 255 255)">Array(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; le</text><text x="0" y="1540"  fill="rgb(255 255 255)">t criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(a</text><text x="366" y="1540"  fill="rgb(237 28 36)">pplykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).l</text><text x="765" y="1540"  fill="rgb(255 255 255)">ength &gt; 1) { throw new InsightError(); } let applyt</text><text x="918" y="1540"  fill="rgb(24 158 180)">oken: string = Object.keys(crite</text><text x="1014" y="1540"  fill="rgb(255 255 255)">ria)[0]; if (!this.</text><text x="1071" y="1540"  fill="rgb(24 158 180)">mtoken.</text><text x="1092" y="1540"  fill="rgb(255 255 255)">includes(applytoken) &amp;&amp; !this</text><text x="1179" y="1540"  fill="rgb(24 158 180)">.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightErro</text><text x="1656" y="1540"  fill="rgb(255 255 255)">r(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(k</text><text x="1884" y="1540"  fill="rgb(237 28 36)">ey[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError()</text><text x="2088" y="1540"  fill="rgb(255 255 255)">; } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields</text><text x="0" y="1545"  fill="rgb(255 255 255)">.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.k</text><text x="366" y="1545"  fill="rgb(237 28 36)">eys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLU</text><text x="765" y="1545"  fill="rgb(255 255 255)">MNS); if (q.ORDER) { this.validateOrder(q.ORDER); </text><text x="915" y="1545"  fill="rgb(24 158 180)">} } private validateColumns(q: an</text><text x="1014" y="1545"  fill="rgb(255 255 255)">y): void { if (!q |</text><text x="1071" y="1545"  fill="rgb(24 158 180)">| q.length</text><text x="1101" y="1545"  fill="rgb(255 255 255)"> &lt; 1) { throw new InsightErro</text><text x="1188" y="1545"  fill="rgb(24 158 180)">r(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { th</text><text x="1659" y="1545"  fill="rgb(255 255 255)">is.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validate</text><text x="1884" y="1545"  fill="rgb(237 28 36)">Order(q: any): void { if (Array.isArray(q)) { throw new InsightError</text><text x="2088" y="1545"  fill="rgb(255 255 255)">(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys |</text><text x="0" y="1550"  fill="rgb(255 255 255)">| Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightEr</text><text x="366" y="1550"  fill="rgb(237 28 36)">ror(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) </text><text x="765" y="1550"  fill="rgb(255 255 255)">{ if (!this.keysInQuery.includes(anykey)) { throw </text><text x="915" y="1550"  fill="rgb(24 158 180)">new InsightError(); } } } } publi</text><text x="1014" y="1550"  fill="rgb(255 255 255)">c validateWhere(q: </text><text x="1071" y="1550"  fill="rgb(24 158 180)">any): void {</text><text x="1107" y="1550"  fill="rgb(255 255 255)"> if (Array.isArray(q)) { throw</text><text x="1197" y="1550"  fill="rgb(24 158 180)"> new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).l</text><text x="1659" y="1550"  fill="rgb(255 255 255)">ength !== 1) { throw new InsightError(); } else { let key: string = Object.</text><text x="1884" y="1550"  fill="rgb(237 28 36)">keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { cas</text><text x="2088" y="1550"  fill="rgb(255 255 255)">e &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.v</text><text x="0" y="1555"  fill="rgb(255 255 255)">alidateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private va</text><text x="366" y="1555"  fill="rgb(237 28 36)">lidateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private val</text><text x="762" y="1555"  fill="rgb(255 255 255)">idateIS(value: any): void { if (typeof value !== &quot;</text><text x="912" y="1555"  fill="rgb(24 158 180)">object&quot;) { throw new InsightError(</text><text x="1014" y="1555"  fill="rgb(255 255 255)">); } if (Object.keys</text><text x="1074" y="1555"  fill="rgb(24 158 180)">(value).length</text><text x="1116" y="1555"  fill="rgb(255 255 255)"> !== 1) { throw new InsightErr</text><text x="1206" y="1555"  fill="rgb(24 158 180)">or(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0</text><text x="1662" y="1555"  fill="rgb(255 255 255)">]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if</text><text x="1887" y="1555"  fill="rgb(237 28 36)"> (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if </text><text x="2088" y="1555"  fill="rgb(255 255 255)">((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } </text><text x="0" y="1560"  fill="rgb(255 255 255)">} } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw n</text><text x="366" y="1560"  fill="rgb(237 28 36)">ew InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } els</text><text x="762" y="1560"  fill="rgb(255 255 255)">e { let idstring: string = mkey[0]; let mfield: s</text><text x="909" y="1560"  fill="rgb(24 158 180)">tring = mkey[1]; let num: any = Obje</text><text x="1017" y="1560"  fill="rgb(255 255 255)">ct.values(value)[0]</text><text x="1074" y="1560"  fill="rgb(24 158 180)">; if ((typeof nu</text><text x="1122" y="1560"  fill="rgb(255 255 255)">m !== &quot;number&quot;) || !this.valida</text><text x="1215" y="1560"  fill="rgb(24 158 180)">teIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray</text><text x="1665" y="1560"  fill="rgb(255 255 255)">(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerO</text><text x="1887" y="1560"  fill="rgb(237 28 36)">bject of value) { this.validateFilter(innerObject); } } private val</text><text x="2088" y="1560"  fill="rgb(255 255 255)">idateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (in</text><text x="0" y="1565"  fill="rgb(255 255 255)">sightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { t</text><text x="366" y="1565"  fill="rgb(237 28 36)">his.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.r</text><text x="762" y="1565"  fill="rgb(255 255 255)">oomsfields; } return true; } } return false; } el</text><text x="909" y="1565"  fill="rgb(24 158 180)">se { return this.idInQuery.includes(</text><text x="1017" y="1565"  fill="rgb(255 255 255)">idstring); } } publi</text><text x="1077" y="1565"  fill="rgb(24 158 180)">c getIdInQuery():</text><text x="1128" y="1565"  fill="rgb(255 255 255)"> string[] { return this.idInQuer</text><text x="1224" y="1565"  fill="rgb(24 158 180)">y; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly co</text><text x="1665" y="1565"  fill="rgb(255 255 255)">ursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private </text><text x="1887" y="1565"  fill="rgb(237 28 36)">readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;t</text><text x="2085" y="1565"  fill="rgb(255 255 255)">itle&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;s</text><text x="0" y="1570"  fill="rgb(255 255 255)">hortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;,</text><text x="363" y="1570"  fill="rgb(237 28 36)"> &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id </text><text x="759" y="1570"  fill="rgb(255 255 255)">private keysInQuery: string[]; // all keys appear</text><text x="906" y="1570"  fill="rgb(24 158 180)">ed in columns after being validated p</text><text x="1017" y="1570"  fill="rgb(255 255 255)">rivate transformatio</text><text x="1077" y="1570"  fill="rgb(24 158 180)">nKey: string[]; // </text><text x="1134" y="1570"  fill="rgb(255 255 255)">keys appeared in transformation, i</text><text x="1236" y="1570"  fill="rgb(24 158 180)">f there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insig</text><text x="1668" y="1570"  fill="rgb(255 255 255)">htDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []</text><text x="1890" y="1570"  fill="rgb(237 28 36)">; this.transformationKey = []; this.allInsightDataset = insightDa</text><text x="2085" y="1570"  fill="rgb(255 255 255)">tasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) </text><text x="0" y="1575"  fill="rgb(255 255 255)">{ if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhe</text><text x="363" y="1575"  fill="rgb(237 28 36)">re(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public v</text><text x="759" y="1575"  fill="rgb(255 255 255)">alidateTransformations(q: any): void { if (typeof</text><text x="906" y="1575"  fill="rgb(24 158 180)"> q.GROUP === &quot;undefined&quot; || typeof q.A</text><text x="1020" y="1575"  fill="rgb(255 255 255)">PPLY === &quot;undefined</text><text x="1077" y="1575"  fill="rgb(24 158 180)">&quot; || Object.keys(q).l</text><text x="1140" y="1575"  fill="rgb(255 255 255)">ength !== 2) { throw new InsightErr</text><text x="1245" y="1575"  fill="rgb(24 158 180)">or(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; </text><text x="1671" y="1575"  fill="rgb(255 255 255)">1) { throw new InsightError(); // q should be an object, and should has a</text><text x="1890" y="1575"  fill="rgb(237 28 36)">t least one element } for (let key of q) { this.validateKey(key);</text><text x="2085" y="1575"  fill="rgb(255 255 255)"> this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let s</text><text x="0" y="1580"  fill="rgb(255 255 255)">plittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIds</text><text x="363" y="1580"  fill="rgb(237 28 36)">tring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError</text><text x="759" y="1580"  fill="rgb(255 255 255)">(); } } private validateAPPLY(q: any): void { if</text><text x="903" y="1580"  fill="rgb(24 158 180)"> (!Array.isArray(q)) { throw new Insigh</text><text x="1020" y="1580"  fill="rgb(255 255 255)">tError(); // q shoul</text><text x="1080" y="1580"  fill="rgb(24 158 180)">d be an array, and shou</text><text x="1149" y="1580"  fill="rgb(255 255 255)">ld have at least one element } for (</text><text x="1257" y="1580"  fill="rgb(24 158 180)">let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: strin</text><text x="1671" y="1580"  fill="rgb(255 255 255)">g = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (app</text><text x="1893" y="1580"  fill="rgb(237 28 36)">lykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformat</text><text x="2085" y="1580"  fill="rgb(255 255 255)">ionKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys</text><text x="0" y="1585"  fill="rgb(255 255 255)">(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.</text><text x="363" y="1585"  fill="rgb(237 28 36)">includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].</text><text x="756" y="1585"  fill="rgb(255 255 255)">split(&quot;_&quot;); if (key.length !== 2) { throw new In</text><text x="900" y="1585"  fill="rgb(24 158 180)">sightError(); } if (this.mtoken.includes</text><text x="1020" y="1585"  fill="rgb(255 255 255)">(applytoken)) { if (</text><text x="1080" y="1585"  fill="rgb(24 158 180)">!(this.validateIdstring(k</text><text x="1155" y="1585"  fill="rgb(255 255 255)">ey[0]) &amp;&amp; this.mfields.includes(key[1</text><text x="1266" y="1585"  fill="rgb(24 158 180)">]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.</text><text x="1674" y="1585"  fill="rgb(255 255 255)">includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightE</text><text x="1893" y="1585"  fill="rgb(237 28 36)">rror(); } } } } public validateOptions(q: any): void { let keys:</text><text x="2085" y="1585"  fill="rgb(255 255 255)"> any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateCo</text><text x="0" y="1590"  fill="rgb(255 255 255)">lumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.len</text><text x="363" y="1590"  fill="rgb(237 28 36)">gth &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.</text><text x="756" y="1590"  fill="rgb(255 255 255)">includes(mskey)) { throw new InsightError(); } }</text><text x="900" y="1590"  fill="rgb(24 158 180)"> else { this.validateKey(mskey); } this.k</text><text x="1023" y="1590"  fill="rgb(255 255 255)">eysInQuery.push(mske</text><text x="1083" y="1590"  fill="rgb(24 158 180)">y); } } private validateOrd</text><text x="1164" y="1590"  fill="rgb(255 255 255)">er(q: any): void { if (Array.isArray(q</text><text x="1278" y="1590"  fill="rgb(24 158 180)">)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } }</text><text x="1677" y="1590"  fill="rgb(255 255 255)"> else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw ne</text><text x="1893" y="1590"  fill="rgb(237 28 36)">w InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { th</text><text x="2085" y="1590"  fill="rgb(255 255 255)">row new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anyk</text><text x="0" y="1595"  fill="rgb(255 255 255)">ey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): v</text><text x="363" y="1595"  fill="rgb(237 28 36)">oid { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } p</text><text x="756" y="1595"  fill="rgb(255 255 255)">rivate validateFilter(q: any): void { if (Objec</text><text x="897" y="1595"  fill="rgb(24 158 180)">t.keys(q).length !== 1) { throw new Insigh</text><text x="1023" y="1595"  fill="rgb(255 255 255)">tError(); } else { l</text><text x="1083" y="1595"  fill="rgb(24 158 180)">et key: string = Object.keys(q</text><text x="1173" y="1595"  fill="rgb(255 255 255)">)[0]; let value: any = Object.values(q</text><text x="1287" y="1595"  fill="rgb(24 158 180)">)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT</text><text x="1677" y="1595"  fill="rgb(255 255 255)">&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: t</text><text x="1893" y="1595"  fill="rgb(237 28 36)">his.validateIS(value); break; default: throw new InsightError();</text><text x="2085" y="1595"  fill="rgb(255 255 255)"> } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } </text><text x="0" y="1600"  fill="rgb(255 255 255)">private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value</text><text x="363" y="1600"  fill="rgb(237 28 36)">).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { thro</text><text x="753" y="1600"  fill="rgb(255 255 255)">w new InsightError(); } else { let idstring: str</text><text x="897" y="1600"  fill="rgb(24 158 180)">ing = skey[0]; let sfield: string = skey[1]</text><text x="1026" y="1600"  fill="rgb(255 255 255)">; let str: any = Obj</text><text x="1086" y="1600"  fill="rgb(24 158 180)">ect.values(value)[0]; if (typeo</text><text x="1179" y="1600"  fill="rgb(255 255 255)">f str !== &quot;string&quot;) { throw new Insight</text><text x="1296" y="1600"  fill="rgb(24 158 180)">Error(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { </text><text x="1680" y="1600"  fill="rgb(255 255 255)">throw new InsightError(); } } } } private validateGTLTEQ(value: any): vo</text><text x="1896" y="1600"  fill="rgb(237 28 36)">id { if (typeof value !== &quot;object&quot; || Object.keys(value).length</text><text x="2085" y="1600"  fill="rgb(255 255 255)"> !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightErr</text><text x="0" y="1605"  fill="rgb(255 255 255)">or(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if (</text><text x="363" y="1605"  fill="rgb(237 28 36)">(typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } }</text><text x="753" y="1605"  fill="rgb(255 255 255)"> private validateANDOR(value: any): void { if (</text><text x="894" y="1605"  fill="rgb(24 158 180)">!Array.isArray(value) || value.length &lt; 1) {</text><text x="1026" y="1605"  fill="rgb(255 255 255)"> throw new InsightEr</text><text x="1086" y="1605"  fill="rgb(24 158 180)">ror(); } for (let innerObject of v</text><text x="1188" y="1605"  fill="rgb(255 255 255)">alue) { this.validateFilter(innerObject</text><text x="1305" y="1605"  fill="rgb(24 158 180)">); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of th</text><text x="1680" y="1605"  fill="rgb(255 255 255)">is.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQ</text><text x="1896" y="1605"  fill="rgb(237 28 36)">uery.push(idstring); if (insightDataset.kind === InsightDataset</text><text x="2085" y="1605"  fill="rgb(255 255 255)">Kind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfiel</text><text x="0" y="1610"  fill="rgb(255 255 255)">ds = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public ge</text><text x="360" y="1610"  fill="rgb(237 28 36)">tIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacad</text><text x="753" y="1610"  fill="rgb(255 255 255)">e&quot;; export default class QueryValidator { priva</text><text x="894" y="1610"  fill="rgb(24 158 180)">te readonly coursemfields: string[] = [&quot;avg&quot;</text><text x="1026" y="1610"  fill="rgb(255 255 255)">, &quot;pass&quot;, &quot;fail&quot;, &quot;au</text><text x="1089" y="1610"  fill="rgb(24 158 180)">dit&quot;, &quot;year&quot;]; private readonly cour</text><text x="1197" y="1610"  fill="rgb(255 255 255)">sesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;i</text><text x="1314" y="1610"  fill="rgb(24 158 180)">nstructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfield</text><text x="1683" y="1610"  fill="rgb(255 255 255)">s: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;</text><text x="1896" y="1610"  fill="rgb(237 28 36)">type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] </text><text x="2085" y="1610"  fill="rgb(255 255 255)">= [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only h</text><text x="0" y="1615"  fill="rgb(255 255 255)">as one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey</text><text x="360" y="1615"  fill="rgb(237 28 36)">: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private m</text><text x="753" y="1615"  fill="rgb(255 255 255)">fields: string[]; private sfields: string[]; c</text><text x="891" y="1615"  fill="rgb(24 158 180)">onstructor(insightDatasets: InsightDataset[]) </text><text x="1029" y="1615"  fill="rgb(255 255 255)">{ this.idInQuery = [</text><text x="1089" y="1615"  fill="rgb(24 158 180)">]; this.keysInQuery = []; this.transfo</text><text x="1203" y="1615"  fill="rgb(255 255 255)">rmationKey = []; this.allInsightDataset</text><text x="1320" y="1615"  fill="rgb(24 158 180)"> = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for</text><text x="1683" y="1615"  fill="rgb(255 255 255)"> (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; </text><text x="1899" y="1615"  fill="rgb(237 28 36)">&amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } </text><text x="2085" y="1615"  fill="rgb(255 255 255)">this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); </text><text x="0" y="1620"  fill="rgb(255 255 255)">} public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; ||</text><text x="360" y="1620"  fill="rgb(237 28 36)"> Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private va</text><text x="750" y="1620"  fill="rgb(255 255 255)">lidateGROUP(q: any): void { if (!Array.isArray(</text><text x="891" y="1620"  fill="rgb(24 158 180)">q) || q.length &lt; 1) { throw new InsightError()</text><text x="1029" y="1620"  fill="rgb(255 255 255)">; // q should be an o</text><text x="1092" y="1620"  fill="rgb(24 158 180)">bject, and should has at least one eleme</text><text x="1212" y="1620"  fill="rgb(255 255 255)">nt } for (let key of q) { this.validat</text><text x="1326" y="1620"  fill="rgb(24 158 180)">eKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKe</text><text x="1686" y="1620"  fill="rgb(255 255 255)">y(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (</text><text x="1899" y="1620"  fill="rgb(237 28 36)">splittedKey.length !== 2) { throw new InsightError(); } if (!(</text><text x="2085" y="1620"  fill="rgb(255 255 255)">this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new In</text><text x="0" y="1625"  fill="rgb(255 255 255)">sightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should b</text><text x="360" y="1625"  fill="rgb(237 28 36)">e an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrul</text><text x="750" y="1625"  fill="rgb(255 255 255)">e).length &gt; 1) { throw new InsightError(); } l</text><text x="888" y="1625"  fill="rgb(24 158 180)">et applykey: string = Object.keys(applyrule)[0];</text><text x="1032" y="1625"  fill="rgb(255 255 255)"> let criteria = appl</text><text x="1092" y="1625"  fill="rgb(24 158 180)">yrule[applykey]; if (applykey.length === 0 </text><text x="1221" y="1625"  fill="rgb(255 255 255)">|| applykey.includes(&quot;_&quot;) || this.tran</text><text x="1335" y="1625"  fill="rgb(24 158 180)">sformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isAr</text><text x="1686" y="1625"  fill="rgb(255 255 255)">ray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightE</text><text x="1899" y="1625"  fill="rgb(237 28 36)">rror(); } let applytoken: string = Object.keys(criteria)[0]; </text><text x="2082" y="1625"  fill="rgb(255 255 255)">if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[app</text><text x="0" y="1630"  fill="rgb(255 255 255)">lytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(t</text><text x="360" y="1630"  fill="rgb(237 28 36)">his.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(app</text><text x="750" y="1630"  fill="rgb(255 255 255)">lytoken)) { if (!(this.validateIdstring(key[0]</text><text x="888" y="1630"  fill="rgb(24 158 180)">) &amp;&amp; (this.sfields.includes(key[1]) || this.mfie</text><text x="1032" y="1630"  fill="rgb(255 255 255)">lds.includes(key[1]))</text><text x="1095" y="1630"  fill="rgb(24 158 180)">)) { throw new InsightError(); } } } } public</text><text x="1230" y="1630"  fill="rgb(255 255 255)"> validateOptions(q: any): void { let </text><text x="1341" y="1630"  fill="rgb(24 158 180)">keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new Insight</text><text x="1686" y="1630"  fill="rgb(255 255 255)">Error(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.valida</text><text x="1902" y="1630"  fill="rgb(237 28 36)">teOrder(q.ORDER); } } private validateColumns(q: any): void </text><text x="2082" y="1630"  fill="rgb(255 255 255)">{ if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transform</text><text x="0" y="1635"  fill="rgb(255 255 255)">ationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey)</text><text x="360" y="1635"  fill="rgb(237 28 36)">; } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { </text><text x="750" y="1635"  fill="rgb(255 255 255)">if (!this.keysInQuery.includes(q)) { throw ne</text><text x="885" y="1635"  fill="rgb(24 158 180)">w InsightError(); } } else { if (!q.dir || !q.keys</text><text x="1035" y="1635"  fill="rgb(255 255 255)"> || Object.keys(q).le</text><text x="1098" y="1635"  fill="rgb(24 158 180)">ngth !== 2) { throw new InsightError(); } if (</text><text x="1236" y="1635"  fill="rgb(255 255 255)">q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) {</text><text x="1347" y="1635"  fill="rgb(24 158 180)"> throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new Insi</text><text x="1689" y="1635"  fill="rgb(255 255 255)">ghtError(); } for (let anykey of keys) { if (!this.keysInQuery.includes</text><text x="1902" y="1635"  fill="rgb(237 28 36)">(anykey)) { throw new InsightError(); } } } } public validat</text><text x="2082" y="1635"  fill="rgb(255 255 255)">eWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q)</text><text x="0" y="1640"  fill="rgb(255 255 255)">; } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let</text><text x="360" y="1640"  fill="rgb(237 28 36)"> key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(</text><text x="747" y="1640"  fill="rgb(255 255 255)">value); break; case &quot;NOT&quot;: this.validateNOT(va</text><text x="885" y="1640"  fill="rgb(24 158 180)">lue); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this</text><text x="1035" y="1640"  fill="rgb(255 255 255)">.validateGTLTEQ(value</text><text x="1098" y="1640"  fill="rgb(24 158 180)">); break; case &quot;IS&quot;: this.validateIS(value); brea</text><text x="1245" y="1640"  fill="rgb(255 255 255)">k; default: throw new InsightError()</text><text x="1353" y="1640"  fill="rgb(24 158 180)">; } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } thi</text><text x="1689" y="1640"  fill="rgb(255 255 255)">s.validateFilter(value); } private validateIS(value: any): void { if (t</text><text x="1902" y="1640"  fill="rgb(237 28 36)">ypeof value !== &quot;object&quot;) { throw new InsightError(); } if (</text><text x="2082" y="1640"  fill="rgb(255 255 255)">Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2</text><text x="0" y="1645"  fill="rgb(255 255 255)">) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Obje</text><text x="360" y="1645"  fill="rgb(237 28 36)">ct.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !t</text><text x="747" y="1645"  fill="rgb(255 255 255)">his.validateIdstring(idstring) || !this.sfiel</text><text x="882" y="1645"  fill="rgb(24 158 180)">ds.includes(sfield)) { throw new InsightError(); } }</text><text x="1038" y="1645"  fill="rgb(255 255 255)"> } } private validate</text><text x="1101" y="1645"  fill="rgb(24 158 180)">GTLTEQ(value: any): void { if (typeof value !== &quot;ob</text><text x="1254" y="1645"  fill="rgb(255 255 255)">ject&quot; || Object.keys(value).length</text><text x="1356" y="1645"  fill="rgb(24 158 180)"> !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !==</text><text x="1692" y="1645"  fill="rgb(255 255 255)"> 2) { throw new InsightError(); } else { let idstring: string = mkey[0</text><text x="1902" y="1645"  fill="rgb(237 28 36)">]; let mfield: string = mkey[1]; let num: any = Object.value</text><text x="2082" y="1645"  fill="rgb(255 255 255)">s(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(</text><text x="0" y="1650"  fill="rgb(255 255 255)">); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightErr</text><text x="360" y="1650"  fill="rgb(237 28 36)">or(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolea</text><text x="747" y="1650"  fill="rgb(255 255 255)">n { if (this.idInQuery.length === 0) { for (l</text><text x="882" y="1650"  fill="rgb(24 158 180)">et insightDataset of this.allInsightDataset) { if (i</text><text x="1038" y="1650"  fill="rgb(255 255 255)">nsightDataset.id === </text><text x="1101" y="1650"  fill="rgb(24 158 180)">idstring) { this.idInQuery.push(idstring); if (insigh</text><text x="1260" y="1650"  fill="rgb(255 255 255)">tDataset.kind === InsightDatasetKi</text><text x="1362" y="1650"  fill="rgb(24 158 180)">nd.Courses) { this.mfields = this.coursemfields; this.sfields = t</text><text x="1557" y="1650"  fill="rgb(255 255 255)">his.coursesfi</text><text x="1596" y="1650"  fill="rgb(24 158 180)">elds; } else { this.mfields = th</text><text x="1692" y="1650"  fill="rgb(255 255 255)">is.roommfields; this.sfields = this.roomsfields; } return true; } } ret</text><text x="1905" y="1650"  fill="rgb(237 28 36)">urn false; } else { return this.idInQuery.includes(idstring</text><text x="2082" y="1650"  fill="rgb(255 255 255)">); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsi</text><text x="0" y="1655"  fill="rgb(255 255 255)">ghtFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;au</text><text x="360" y="1655"  fill="rgb(237 28 36)">dit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfi</text><text x="747" y="1655"  fill="rgb(255 255 255)">elds: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; pr</text><text x="879" y="1655"  fill="rgb(24 158 180)">ivate readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;s</text><text x="1041" y="1655"  fill="rgb(255 255 255)">hortname&quot;, &quot;number&quot; ,</text><text x="1104" y="1655"  fill="rgb(24 158 180)"> &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; priva</text><text x="1269" y="1655"  fill="rgb(255 255 255)">te readonly mtoken: string[] = [&quot;</text><text x="1368" y="1655"  fill="rgb(24 158 180)">MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: stri</text><text x="1542" y="1655"  fill="rgb(255 255 255)">ng[] = [&quot;COUNT&quot;]; priv</text><text x="1608" y="1655"  fill="rgb(24 158 180)">ate idInQuery: string[]; // </text><text x="1692" y="1655"  fill="rgb(255 255 255)">make sure the query only has one id private keysInQuery: string[]; // a</text><text x="1905" y="1655"  fill="rgb(237 28 36)">ll keys appeared in columns after being validated private t</text><text x="2082" y="1655"  fill="rgb(255 255 255)">ransformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; p</text><text x="0" y="1660"  fill="rgb(255 255 255)">rivate mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = </text><text x="357" y="1660"  fill="rgb(237 28 36)">[]; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void </text><text x="747" y="1660"  fill="rgb(255 255 255)">{ if (!q || !q.WHERE || !q.OPTIONS) { throw </text><text x="879" y="1660"  fill="rgb(24 158 180)">new InsightError(); } for (let key of Object.keys(q)) </text><text x="1041" y="1660"  fill="rgb(255 255 255)">{ if (key !== &quot;OPTIONS</text><text x="1107" y="1660"  fill="rgb(24 158 180)">&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { thr</text><text x="1275" y="1660"  fill="rgb(255 255 255)">ow new InsightError(); } } this.</text><text x="1371" y="1660"  fill="rgb(24 158 180)">validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.</text><text x="1533" y="1660"  fill="rgb(255 255 255)">validateTransformations(q.TR</text><text x="1617" y="1660"  fill="rgb(24 158 180)">ANSFORMATIONS); } this.val</text><text x="1695" y="1660"  fill="rgb(255 255 255)">idateOptions(q.OPTIONS); } public validateTransformations(q: any): voi</text><text x="1905" y="1660"  fill="rgb(237 28 36)">d { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY ==</text><text x="2082" y="1660"  fill="rgb(255 255 255)">= &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } pri</text><text x="0" y="1665"  fill="rgb(255 255 255)">vate validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an</text><text x="357" y="1665"  fill="rgb(237 28 36)"> object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // i</text><text x="744" y="1665"  fill="rgb(255 255 255)">f the key is valid, push it to transformatio</text><text x="876" y="1665"  fill="rgb(24 158 180)">nKey } } private validateKey(key: string): void { let sp</text><text x="1044" y="1665"  fill="rgb(255 255 255)">littedKey: string[] =</text><text x="1107" y="1665"  fill="rgb(24 158 180)"> key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new </text><text x="1284" y="1665"  fill="rgb(255 255 255)">InsightError(); } if (!(this.va</text><text x="1377" y="1665"  fill="rgb(24 158 180)">lidateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.i</text><text x="1524" y="1665"  fill="rgb(255 255 255)">ncludes(splittedKey[1]) || this.sf</text><text x="1626" y="1665"  fill="rgb(24 158 180)">ields.includes(splitted</text><text x="1695" y="1665"  fill="rgb(255 255 255)">Key[1])))) { throw new InsightError(); } } private validateAPPLY(q: an</text><text x="1905" y="1665"  fill="rgb(237 28 36)">y): void { if (!Array.isArray(q)) { throw new InsightError(</text><text x="2082" y="1665"  fill="rgb(255 255 255)">); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(a</text><text x="0" y="1670"  fill="rgb(255 255 255)">pplyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = ap</text><text x="357" y="1670"  fill="rgb(237 28 36)">plyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new </text><text x="744" y="1670"  fill="rgb(255 255 255)">InsightError(); } this.transformationKey.pus</text><text x="876" y="1670"  fill="rgb(24 158 180)">h(applykey); if (Array.isArray(criteria) || Object.keys(c</text><text x="1047" y="1670"  fill="rgb(255 255 255)">riteria).length &gt; 1) </text><text x="1110" y="1670"  fill="rgb(24 158 180)">{ throw new InsightError(); } let applytoken: string = Objec</text><text x="1290" y="1670"  fill="rgb(255 255 255)">t.keys(criteria)[0]; if (!this</text><text x="1380" y="1670"  fill="rgb(24 158 180)">.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.</text><text x="1518" y="1670"  fill="rgb(255 255 255)">includes(applytoken)) { throw new Insi</text><text x="1632" y="1670"  fill="rgb(24 158 180)">ghtError(); } let key</text><text x="1695" y="1670"  fill="rgb(255 255 255)">: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { t</text><text x="1908" y="1670"  fill="rgb(237 28 36)">hrow new InsightError(); } if (this.mtoken.includes(apply</text><text x="2079" y="1670"  fill="rgb(255 255 255)">token)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.inclu</text><text x="0" y="1675"  fill="rgb(255 255 255)">des(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1</text><text x="357" y="1675"  fill="rgb(237 28 36)">])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key o</text><text x="744" y="1675"  fill="rgb(255 255 255)">f keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;</text><text x="876" y="1675"  fill="rgb(24 158 180)">ORDER&quot;) { throw new InsightError(); } } this.validateColu</text><text x="1047" y="1675"  fill="rgb(255 255 255)">mns(q.COLUMNS); if (q.</text><text x="1113" y="1675"  fill="rgb(24 158 180)">ORDER) { this.validateOrder(q.ORDER); } } private validateColu</text><text x="1299" y="1675"  fill="rgb(255 255 255)">mns(q: any): void { if (!q |</text><text x="1383" y="1675"  fill="rgb(24 158 180)">| q.length &lt; 1) { throw new InsightError();</text><text x="1512" y="1675"  fill="rgb(255 255 255)"> } for (let mskey of q) { if (this.transfo</text><text x="1638" y="1675"  fill="rgb(24 158 180)">rmationKey.length &gt; </text><text x="1698" y="1675"  fill="rgb(255 255 255)">0) { if (!this.transformationKey.includes(mskey)) { throw new InsightE</text><text x="1908" y="1675"  fill="rgb(237 28 36)">rror(); } } else { this.validateKey(mskey); } this.keysIn</text><text x="2079" y="1675"  fill="rgb(255 255 255)">Query.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;stri</text><text x="0" y="1680"  fill="rgb(255 255 255)">ng&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q</text><text x="357" y="1680"  fill="rgb(237 28 36)">).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any</text><text x="744" y="1680"  fill="rgb(255 255 255)"> = q.keys; if (!Array.isArray(keys) || keys</text><text x="873" y="1680"  fill="rgb(24 158 180)">.length &lt; 1) { throw new InsightError(); } for (let anykey </text><text x="1050" y="1680"  fill="rgb(255 255 255)">of keys) { if (!this.k</text><text x="1116" y="1680"  fill="rgb(24 158 180)">eysInQuery.includes(anykey)) { throw new InsightError(); } } } </text><text x="1305" y="1680"  fill="rgb(255 255 255)">} public validateWhere(q: an</text><text x="1389" y="1680"  fill="rgb(24 158 180)">y): void { if (Array.isArray(q)) { thro</text><text x="1506" y="1680"  fill="rgb(255 255 255)">w new InsightError(); } else { if (Object.keys</text><text x="1644" y="1680"  fill="rgb(24 158 180)">(q).length !== 0) </text><text x="1698" y="1680"  fill="rgb(255 255 255)">{ this.validateFilter(q); } } } private validateFilter(q: any): void {</text><text x="1908" y="1680"  fill="rgb(237 28 36)"> if (Object.keys(q).length !== 1) { throw new InsightErro</text><text x="2079" y="1680"  fill="rgb(255 255 255)">r(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validate</text><text x="0" y="1685"  fill="rgb(255 255 255)">ANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(v</text><text x="357" y="1685"  fill="rgb(237 28 36)">alue); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any)</text><text x="741" y="1685"  fill="rgb(255 255 255)">: void { if (typeof value !== &quot;object&quot;) { th</text><text x="873" y="1685"  fill="rgb(24 158 180)">row new InsightError(); } this.validateFilter(value); } pri</text><text x="1050" y="1685"  fill="rgb(255 255 255)">vate validateIS(value:</text><text x="1116" y="1685"  fill="rgb(24 158 180)"> any): void { if (typeof value !== &quot;object&quot;) { throw new InsightE</text><text x="1311" y="1685"  fill="rgb(255 255 255)">rror(); } if (Object.keys(v</text><text x="1392" y="1685"  fill="rgb(24 158 180)">alue).length !== 1) { throw new Insi</text><text x="1500" y="1685"  fill="rgb(255 255 255)">ghtError(); } let skey: string[] = Object.keys(val</text><text x="1650" y="1685"  fill="rgb(24 158 180)">ue)[0].split(&quot;_&quot;</text><text x="1698" y="1685"  fill="rgb(255 255 255)">); if (skey.length !== 2) { throw new InsightError(); } else { let ids</text><text x="1908" y="1685"  fill="rgb(237 28 36)">tring: string = skey[0]; let sfield: string = skey[1]; le</text><text x="2079" y="1685"  fill="rgb(255 255 255)">t str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;))</text><text x="0" y="1690"  fill="rgb(255 255 255)"> || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private val</text><text x="357" y="1690"  fill="rgb(237 28 36)">idateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } </text><text x="741" y="1690"  fill="rgb(255 255 255)">let mkey: string[] = Object.keys(value)[0].s</text><text x="873" y="1690"  fill="rgb(24 158 180)">plit(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError()</text><text x="1053" y="1690"  fill="rgb(255 255 255)">; } else { let idstrin</text><text x="1119" y="1690"  fill="rgb(24 158 180)">g: string = mkey[0]; let mfield: string = mkey[1]; let num: any =</text><text x="1314" y="1690"  fill="rgb(255 255 255)"> Object.values(value)[0]; i</text><text x="1395" y="1690"  fill="rgb(24 158 180)">f ((typeof num !== &quot;number&quot;) || !</text><text x="1494" y="1690"  fill="rgb(255 255 255)">this.validateIdstring(idstring) || !this.mfields.incl</text><text x="1653" y="1690"  fill="rgb(24 158 180)">udes(mfield)) { </text><text x="1701" y="1690"  fill="rgb(255 255 255)">throw new InsightError(); } } } private validateANDOR(value: any): vo</text><text x="1908" y="1690"  fill="rgb(237 28 36)">id { if (!Array.isArray(value) || value.length &lt; 1) { thr</text><text x="2079" y="1690"  fill="rgb(255 255 255)">ow new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): </text><text x="0" y="1695"  fill="rgb(255 255 255)">boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id</text><text x="357" y="1695"  fill="rgb(237 28 36)"> === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.co</text><text x="741" y="1695"  fill="rgb(255 255 255)">ursemfields; this.sfields = this.coursesfie</text><text x="870" y="1695"  fill="rgb(24 158 180)">lds; } else { this.mfields = this.roommfields; this.sfields = </text><text x="1056" y="1695"  fill="rgb(255 255 255)">this.roomsfields; } re</text><text x="1122" y="1695"  fill="rgb(24 158 180)">turn true; } } return false; } else { return this.idInQuery.includ</text><text x="1320" y="1695"  fill="rgb(255 255 255)">es(idstring); } } public g</text><text x="1398" y="1695"  fill="rgb(24 158 180)">etIdInQuery(): string[] { retur</text><text x="1491" y="1695"  fill="rgb(255 255 255)">n this.idInQuery; } } import {InsightDataset, InsightDat</text><text x="1659" y="1695"  fill="rgb(24 158 180)">asetKind, Insi</text><text x="1701" y="1695"  fill="rgb(255 255 255)">ghtError} from &quot;./IInsightFacade&quot;; export default class QueryValidator</text><text x="1911" y="1695"  fill="rgb(237 28 36)"> { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;p</text><text x="2079" y="1695"  fill="rgb(255 255 255)">ass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly r</text><text x="0" y="1700"  fill="rgb(255 255 255)">oommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;num</text><text x="357" y="1700"  fill="rgb(237 28 36)">ber&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; privat</text><text x="741" y="1700"  fill="rgb(255 255 255)">e readonly mstoken: string[] = [&quot;COUNT&quot;]; p</text><text x="870" y="1700"  fill="rgb(24 158 180)">rivate idInQuery: string[]; // make sure the query only has on</text><text x="1056" y="1700"  fill="rgb(255 255 255)">e id private keysInQuer</text><text x="1125" y="1700"  fill="rgb(24 158 180)">y: string[]; // all keys appeared in columns after being validated</text><text x="1323" y="1700"  fill="rgb(255 255 255)"> private transformationKey</text><text x="1401" y="1700"  fill="rgb(24 158 180)">: string[]; // keys appeared</text><text x="1485" y="1700"  fill="rgb(255 255 255)"> in transformation, if there is a transformation private al</text><text x="1662" y="1700"  fill="rgb(24 158 180)">lInsightDatas</text><text x="1701" y="1700"  fill="rgb(255 255 255)">et: InsightDataset[]; private mfields: string[]; private sfields: stri</text><text x="1911" y="1700"  fill="rgb(237 28 36)">ng[]; constructor(insightDatasets: InsightDataset[]) { t</text><text x="2079" y="1700"  fill="rgb(255 255 255)">his.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any):</text><text x="0" y="1705"  fill="rgb(255 255 255)"> void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;</text><text x="357" y="1705"  fill="rgb(237 28 36)">OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRA</text><text x="741" y="1705"  fill="rgb(255 255 255)">NSFORMATIONS) { this.validateTransformatio</text><text x="867" y="1705"  fill="rgb(24 158 180)">ns(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } publ</text><text x="1059" y="1705"  fill="rgb(255 255 255)">ic validateTransformat</text><text x="1125" y="1705"  fill="rgb(24 158 180)">ions(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.</text><text x="1329" y="1705"  fill="rgb(255 255 255)">APPLY === &quot;undefined&quot; || </text><text x="1404" y="1705"  fill="rgb(24 158 180)">Object.keys(q).length !== </text><text x="1482" y="1705"  fill="rgb(255 255 255)">2) { throw new InsightError(); } this.validateGROUP(q.GROUP); </text><text x="1668" y="1705"  fill="rgb(24 158 180)">this.validat</text><text x="1704" y="1705"  fill="rgb(255 255 255)">eAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.i</text><text x="1911" y="1705"  fill="rgb(237 28 36)">sArray(q) || q.length &lt; 1) { throw new InsightError(); </text><text x="2076" y="1705"  fill="rgb(255 255 255)">// q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key);</text><text x="0" y="1710"  fill="rgb(255 255 255)"> // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: str</text><text x="357" y="1710"  fill="rgb(237 28 36)">ing[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) </text><text x="741" y="1710"  fill="rgb(255 255 255)">&amp;&amp; (this.mfields.includes(splittedKey[1]) </text><text x="867" y="1710"  fill="rgb(24 158 180)">|| this.sfields.includes(splittedKey[1])))) { throw new InsightEr</text><text x="1062" y="1710"  fill="rgb(255 255 255)">ror(); } } private val</text><text x="1128" y="1710"  fill="rgb(24 158 180)">idateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new Insigh</text><text x="1332" y="1710"  fill="rgb(255 255 255)">tError(); // q should be </text><text x="1407" y="1710"  fill="rgb(24 158 180)">an array, and should ha</text><text x="1476" y="1710"  fill="rgb(255 255 255)">ve at least one element } for (let applyrule of q) { if (Array.is</text><text x="1671" y="1710"  fill="rgb(24 158 180)">Array(apply</text><text x="1704" y="1710"  fill="rgb(255 255 255)">rule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(</text><text x="1911" y="1710"  fill="rgb(237 28 36)">); } let applykey: string = Object.keys(applyrule)[0]; </text><text x="2076" y="1710"  fill="rgb(255 255 255)">let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw</text><text x="0" y="1715"  fill="rgb(255 255 255)"> new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).leng</text><text x="357" y="1715"  fill="rgb(237 28 36)">th &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) </text><text x="738" y="1715"  fill="rgb(255 255 255)">&amp;&amp; !this.mstoken.includes(applytoken)) { th</text><text x="867" y="1715"  fill="rgb(24 158 180)">row new InsightError(); } let key: string[] = criteria[applytoken]</text><text x="1065" y="1715"  fill="rgb(255 255 255)">.split(&quot;_&quot;); if (key.l</text><text x="1131" y="1715"  fill="rgb(24 158 180)">ength !== 2) { throw new InsightError(); } if (this.mtoken.includes(</text><text x="1335" y="1715"  fill="rgb(255 255 255)">applytoken)) { if (!(this</text><text x="1410" y="1715"  fill="rgb(24 158 180)">.validateIdstring(key</text><text x="1473" y="1715"  fill="rgb(255 255 255)">[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError();</text><text x="1674" y="1715"  fill="rgb(24 158 180)"> } } else </text><text x="1704" y="1715"  fill="rgb(255 255 255)">if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(</text><text x="1911" y="1715"  fill="rgb(237 28 36)">key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfiel</text><text x="2076" y="1715"  fill="rgb(255 255 255)">ds.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let </text><text x="0" y="1720"  fill="rgb(255 255 255)">key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS</text><text x="357" y="1720"  fill="rgb(237 28 36)">); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new </text><text x="738" y="1720"  fill="rgb(255 255 255)">InsightError(); } for (let mskey of q) { i</text><text x="864" y="1720"  fill="rgb(24 158 180)">f (this.transformationKey.length &gt; 0) { if (!this.transformationKey</text><text x="1065" y="1720"  fill="rgb(255 255 255)">.includes(mskey)) { thr</text><text x="1134" y="1720"  fill="rgb(24 158 180)">ow new InsightError(); } } else { this.validateKey(mskey); } this.ke</text><text x="1338" y="1720"  fill="rgb(255 255 255)">ysInQuery.push(mskey); } </text><text x="1413" y="1720"  fill="rgb(24 158 180)">} private validateO</text><text x="1470" y="1720"  fill="rgb(255 255 255)">rder(q: any): void { if (Array.isArray(q)) { throw new InsightError();</text><text x="1680" y="1720"  fill="rgb(24 158 180)"> } else i</text><text x="1707" y="1720"  fill="rgb(255 255 255)">f (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { thro</text><text x="1914" y="1720"  fill="rgb(237 28 36)">w new InsightError(); } } else { if (!q.dir || !q.keys</text><text x="2076" y="1720"  fill="rgb(255 255 255)"> || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys</text><text x="0" y="1725"  fill="rgb(255 255 255)">: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { i</text><text x="357" y="1725"  fill="rgb(237 28 36)">f (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArr</text><text x="738" y="1725"  fill="rgb(255 255 255)">ay(q)) { throw new InsightError(); } else </text><text x="864" y="1725"  fill="rgb(24 158 180)">{ if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } p</text><text x="1068" y="1725"  fill="rgb(255 255 255)">rivate validateFilter(q</text><text x="1137" y="1725"  fill="rgb(24 158 180)">: any): void { if (Object.keys(q).length !== 1) { throw new InsightE</text><text x="1341" y="1725"  fill="rgb(255 255 255)">rror(); } else { let key:</text><text x="1416" y="1725"  fill="rgb(24 158 180)"> string = Object</text><text x="1464" y="1725"  fill="rgb(255 255 255)">.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;A</text><text x="1683" y="1725"  fill="rgb(24 158 180)">ND&quot;: cas</text><text x="1707" y="1725"  fill="rgb(255 255 255)">e &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNO</text><text x="1914" y="1725"  fill="rgb(237 28 36)">T(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this</text><text x="2076" y="1725"  fill="rgb(255 255 255)">.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: </text><text x="0" y="1730"  fill="rgb(255 255 255)">any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validat</text><text x="357" y="1730"  fill="rgb(237 28 36)">eIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { thr</text><text x="738" y="1730"  fill="rgb(255 255 255)">ow new InsightError(); } let skey: string[</text><text x="864" y="1730"  fill="rgb(24 158 180)">] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw </text><text x="1071" y="1730"  fill="rgb(255 255 255)">new InsightError(); } e</text><text x="1140" y="1730"  fill="rgb(24 158 180)">lse { let idstring: string = skey[0]; let sfield: string = skey[1]; </text><text x="1344" y="1730"  fill="rgb(255 255 255)">let str: any = Object.val</text><text x="1419" y="1730"  fill="rgb(24 158 180)">ues(value)[0];</text><text x="1461" y="1730"  fill="rgb(255 255 255)"> if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str</text><text x="1686" y="1730"  fill="rgb(24 158 180)">.slice(</text><text x="1707" y="1730"  fill="rgb(255 255 255)">1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sf</text><text x="1914" y="1730"  fill="rgb(237 28 36)">ields.includes(sfield)) { throw new InsightError(); } </text><text x="2076" y="1730"  fill="rgb(255 255 255)">} } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError()</text><text x="0" y="1735"  fill="rgb(255 255 255)">; } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { </text><text x="357" y="1735"  fill="rgb(237 28 36)">let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;numb</text><text x="738" y="1735"  fill="rgb(255 255 255)">er&quot;) || !this.validateIdstring(idstring) </text><text x="861" y="1735"  fill="rgb(24 158 180)">|| !this.mfields.includes(mfield)) { throw new InsightError(); } } } pr</text><text x="1074" y="1735"  fill="rgb(255 255 255)">ivate validateANDOR(val</text><text x="1143" y="1735"  fill="rgb(24 158 180)">ue: any): void { if (!Array.isArray(value) || value.length &lt; 1) { th</text><text x="1347" y="1735"  fill="rgb(255 255 255)">row new InsightError(); }</text><text x="1422" y="1735"  fill="rgb(24 158 180)"> for (let i</text><text x="1455" y="1735"  fill="rgb(255 255 255)">nnerObject of value) { this.validateF</text><text x="1566" y="1735"  fill="rgb(24 158 180)">ilter(in</text><text x="1590" y="1735"  fill="rgb(255 255 255)">nerObject); } } private validateI</text><text x="1689" y="1735"  fill="rgb(24 158 180)">dstring</text><text x="1710" y="1735"  fill="rgb(255 255 255)">(idstring: string): boolean { if (this.idInQuery.length === 0) { for</text><text x="1914" y="1735"  fill="rgb(237 28 36)"> (let insightDataset of this.allInsightDataset) { if (</text><text x="2076" y="1735"  fill="rgb(255 255 255)">insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = thi</text><text x="0" y="1740"  fill="rgb(255 255 255)">s.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.rooms</text><text x="357" y="1740"  fill="rgb(237 28 36)">fields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[]</text><text x="738" y="1740"  fill="rgb(255 255 255)"> { return this.idInQuery; } } import {Ins</text><text x="861" y="1740"  fill="rgb(24 158 180)">ightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;;</text><text x="1074" y="1740"  fill="rgb(255 255 255)"> export default class Qu</text><text x="1146" y="1740"  fill="rgb(24 158 180)">eryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;p</text><text x="1350" y="1740"  fill="rgb(255 255 255)">ass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;y</text><text x="1425" y="1740"  fill="rgb(24 158 180)">ear&quot;]; pr</text><text x="1452" y="1740"  fill="rgb(255 255 255)">ivate readonly coursesfields: s</text><text x="1545" y="1740"  fill="rgb(24 158 180)">tring[] = [&quot;dept&quot;, &quot;id</text><text x="1611" y="1740"  fill="rgb(255 255 255)">&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;</text><text x="1692" y="1740"  fill="rgb(24 158 180)">uuid&quot;]</text><text x="1710" y="1740"  fill="rgb(255 255 255)">; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; </text><text x="1914" y="1740"  fill="rgb(237 28 36)">private readonly roomsfields: string[] = [&quot;fullname&quot;,</text><text x="2073" y="1740"  fill="rgb(255 255 255)"> &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; pr</text><text x="0" y="1745"  fill="rgb(255 255 255)">ivate readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id priv</text><text x="354" y="1745"  fill="rgb(237 28 36)">ate keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys ap</text><text x="738" y="1745"  fill="rgb(255 255 255)">peared in transformation, if there is a t</text><text x="861" y="1745"  fill="rgb(24 158 180)">ransformation private allInsightDataset: InsightDataset[]; private mfiel</text><text x="1077" y="1745"  fill="rgb(255 255 255)">ds: string[]; private sf</text><text x="1149" y="1745"  fill="rgb(24 158 180)">ields: string[]; constructor(insightDatasets: InsightDataset[]) { th</text><text x="1353" y="1745"  fill="rgb(255 255 255)">is.idInQuery = []; this.ke</text><text x="1431" y="1745"  fill="rgb(24 158 180)">ysInQ</text><text x="1446" y="1745"  fill="rgb(255 255 255)">uery = []; this.transformatio</text><text x="1533" y="1745"  fill="rgb(24 158 180)">nKey = []; this.allInsightDa</text><text x="1617" y="1745"  fill="rgb(255 255 255)">taset = insightDatasets; }</text><text x="1695" y="1745"  fill="rgb(24 158 180)"> publ</text><text x="1710" y="1745"  fill="rgb(255 255 255)">ic validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { thro</text><text x="1914" y="1745"  fill="rgb(237 28 36)">w new InsightError(); } for (let key of Object.keys(q</text><text x="2073" y="1745"  fill="rgb(255 255 255)">)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q</text><text x="0" y="1750"  fill="rgb(255 255 255)">.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public valid</text><text x="354" y="1750"  fill="rgb(237 28 36)">ateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length</text><text x="738" y="1750"  fill="rgb(255 255 255)"> !== 2) { throw new InsightError(); } thi</text><text x="861" y="1750"  fill="rgb(24 158 180)">s.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validate</text><text x="1080" y="1750"  fill="rgb(255 255 255)">GROUP(q: any): void { if</text><text x="1152" y="1750"  fill="rgb(24 158 180)"> (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // </text><text x="1356" y="1750"  fill="rgb(255 255 255)">q should be an object, and should has at least one elemen</text><text x="1527" y="1750"  fill="rgb(24 158 180)">t } for (let key of q) { this.va</text><text x="1623" y="1750"  fill="rgb(255 255 255)">lidateKey(key); this.tran</text><text x="1698" y="1750"  fill="rgb(24 158 180)">sform</text><text x="1713" y="1750"  fill="rgb(255 255 255)">ationKey.push(key); // if the key is valid, push it to transformati</text><text x="1914" y="1750"  fill="rgb(237 28 36)">onKey } } private validateKey(key: string): void { le</text><text x="2073" y="1750"  fill="rgb(255 255 255)">t splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[</text><text x="0" y="1755"  fill="rgb(255 255 255)">0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); </text><text x="354" y="1755"  fill="rgb(237 28 36)">} } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and shoul</text><text x="735" y="1755"  fill="rgb(255 255 255)">d have at least one element } for (let ap</text><text x="858" y="1755"  fill="rgb(24 158 180)">plyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).leng</text><text x="1083" y="1755"  fill="rgb(255 255 255)">th &gt; 1) { throw new Insi</text><text x="1155" y="1755"  fill="rgb(24 158 180)">ghtError(); } let applykey: string = Object.keys(applyrule)[0]; let</text><text x="1356" y="1755"  fill="rgb(255 255 255)"> criteria = applyrule[applykey]; if (applykey.length =</text><text x="1518" y="1755"  fill="rgb(24 158 180)">== 0 || applykey.includes(&quot;_&quot;) || th</text><text x="1626" y="1755"  fill="rgb(255 255 255)">is.transformationKey.inclu</text><text x="1704" y="1755"  fill="rgb(24 158 180)">des</text><text x="1713" y="1755"  fill="rgb(255 255 255)">(applykey)) { throw new InsightError(); } this.transformationKey.pus</text><text x="1917" y="1755"  fill="rgb(237 28 36)">h(applykey); if (Array.isArray(criteria) || Object.k</text><text x="2073" y="1755"  fill="rgb(255 255 255)">eys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoke</text><text x="0" y="1760"  fill="rgb(255 255 255)">n) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split</text><text x="354" y="1760"  fill="rgb(237 28 36)">(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(</text><text x="735" y="1760"  fill="rgb(255 255 255)">key[0]) &amp;&amp; this.mfields.includes(key[1]))</text><text x="858" y="1760"  fill="rgb(24 158 180)">) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)</text><text x="1086" y="1760"  fill="rgb(255 255 255)">) { if (!(this.validateI</text><text x="1158" y="1760"  fill="rgb(24 158 180)">dstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.i</text><text x="1359" y="1760"  fill="rgb(255 255 255)">ncludes(key[1])))) { throw new InsightError(); } } </text><text x="1512" y="1760"  fill="rgb(24 158 180)">} } public validateOptions(q: any): vo</text><text x="1626" y="1760"  fill="rgb(255 255 255)">id { let keys: any[] = Obje</text><text x="1707" y="1760"  fill="rgb(24 158 180)">ct</text><text x="1713" y="1760"  fill="rgb(255 255 255)">.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;</text><text x="1917" y="1760"  fill="rgb(237 28 36)">ORDER&quot;) { throw new InsightError(); } } this.validat</text><text x="2073" y="1760"  fill="rgb(255 255 255)">eColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw n</text><text x="0" y="1765"  fill="rgb(255 255 255)">ew InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.inclu</text><text x="354" y="1765"  fill="rgb(237 28 36)">des(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validat</text><text x="735" y="1765"  fill="rgb(255 255 255)">eOrder(q: any): void { if (Array.isArray(</text><text x="858" y="1765"  fill="rgb(24 158 180)">q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this</text><text x="1089" y="1765"  fill="rgb(255 255 255)">.keysInQuery.includes(q)</text><text x="1161" y="1765"  fill="rgb(24 158 180)">) { throw new InsightError(); } } else { if (!q.dir || !q.keys || O</text><text x="1362" y="1765"  fill="rgb(255 255 255)">bject.keys(q).length !== 2) { throw new InsightE</text><text x="1506" y="1765"  fill="rgb(24 158 180)">rror(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !=</text><text x="1626" y="1765"  fill="rgb(255 255 255)">= &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.</text><text x="1917" y="1765"  fill="rgb(237 28 36)">length &lt; 1) { throw new InsightError(); } for (let a</text><text x="2073" y="1765"  fill="rgb(255 255 255)">nykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.is</text><text x="0" y="1770"  fill="rgb(255 255 255)">Array(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } privat</text><text x="354" y="1770"  fill="rgb(237 28 36)">e validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object</text><text x="735" y="1770"  fill="rgb(255 255 255)">.keys(q)[0]; let value: any = Object.val</text><text x="855" y="1770"  fill="rgb(24 158 180)">ues(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); bre</text><text x="1092" y="1770"  fill="rgb(255 255 255)">ak; case &quot;NOT&quot;: this.val</text><text x="1164" y="1770"  fill="rgb(24 158 180)">idateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.vali</text><text x="1362" y="1770"  fill="rgb(255 255 255)">dateGTLTEQ(value); break; case &quot;IS&quot;: this.vali</text><text x="1500" y="1770"  fill="rgb(24 158 180)">dateIS(value); break; default: throw new I</text><text x="1626" y="1770"  fill="rgb(255 255 255)">nsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { thr</text><text x="1917" y="1770"  fill="rgb(237 28 36)">ow new InsightError(); } this.validateFilter(value)</text><text x="2070" y="1770"  fill="rgb(255 255 255)">; } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { </text><text x="0" y="1775"  fill="rgb(255 255 255)">throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new </text><text x="354" y="1775"  fill="rgb(237 28 36)">InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; </text><text x="735" y="1775"  fill="rgb(255 255 255)">if (typeof str !== &quot;string&quot;) { throw new</text><text x="855" y="1775"  fill="rgb(24 158 180)"> InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validate</text><text x="1095" y="1775"  fill="rgb(255 255 255)">Idstring(idstring) || !t</text><text x="1167" y="1775"  fill="rgb(24 158 180)">his.sfields.includes(sfield)) { throw new InsightError(); } } } } </text><text x="1365" y="1775"  fill="rgb(255 255 255)">private validateGTLTEQ(value: any): void { </text><text x="1494" y="1775"  fill="rgb(24 158 180)">if (typeof value !== &quot;object&quot; || Object.keys</text><text x="1626" y="1775"  fill="rgb(255 255 255)">(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].sp</text><text x="1917" y="1775"  fill="rgb(237 28 36)">lit(&quot;_&quot;); if (mkey.length !== 2) { throw new Insigh</text><text x="2070" y="1775"  fill="rgb(255 255 255)">tError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;n</text><text x="0" y="1780"  fill="rgb(255 255 255)">umber&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } priva</text><text x="354" y="1780"  fill="rgb(237 28 36)">te validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let inne</text><text x="735" y="1780"  fill="rgb(255 255 255)">rObject of value) { this.validateFilter(</text><text x="855" y="1780"  fill="rgb(24 158 180)">innerObject); } } private validateIdstring(idstring: string): boolean { if (this.</text><text x="1098" y="1780"  fill="rgb(255 255 255)">idInQuery.length === 0) </text><text x="1170" y="1780"  fill="rgb(24 158 180)">{ for (let insightDataset of this.allInsightDataset) { if (insigh</text><text x="1365" y="1780"  fill="rgb(255 255 255)">tDataset.id === idstring) { this.idInQuery</text><text x="1491" y="1780"  fill="rgb(24 158 180)">.push(idstring); if (insightDataset.kind === </text><text x="1626" y="1780"  fill="rgb(255 255 255)">InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfield</text><text x="1917" y="1780"  fill="rgb(237 28 36)">s; } else { this.mfields = this.roommfields; this.s</text><text x="2070" y="1780"  fill="rgb(255 255 255)">fields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): strin</text><text x="0" y="1785"  fill="rgb(255 255 255)">g[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; ex</text><text x="354" y="1785"  fill="rgb(237 28 36)">port default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; privat</text><text x="735" y="1785"  fill="rgb(255 255 255)">e readonly coursesfields: string[] = [&quot;d</text><text x="855" y="1785"  fill="rgb(24 158 180)">ept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[]</text><text x="1101" y="1785"  fill="rgb(255 255 255)"> = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats</text><text x="1173" y="1785"  fill="rgb(24 158 180)">&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortn</text><text x="1368" y="1785"  fill="rgb(255 255 255)">ame&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;ty</text><text x="1485" y="1785"  fill="rgb(24 158 180)">pe&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mt</text><text x="1623" y="1785"  fill="rgb(255 255 255)">oken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; pri</text><text x="1917" y="1785"  fill="rgb(237 28 36)">vate idInQuery: string[]; // make sure the query on</text><text x="2070" y="1785"  fill="rgb(255 255 255)">ly has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys</text><text x="0" y="1790"  fill="rgb(255 255 255)"> appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields</text><text x="354" y="1790"  fill="rgb(237 28 36)">: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery =</text><text x="735" y="1790"  fill="rgb(255 255 255)"> []; this.transformationKey = []; this.a</text><text x="855" y="1790"  fill="rgb(24 158 180)">llInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.</text><text x="1104" y="1790"  fill="rgb(255 255 255)">WHERE || !q.OPTIONS) { t</text><text x="1176" y="1790"  fill="rgb(24 158 180)">hrow new InsightError(); } for (let key of Object.keys(q)) { if (</text><text x="1371" y="1790"  fill="rgb(255 255 255)">key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; </text><text x="1482" y="1790"  fill="rgb(24 158 180)">&amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new Insi</text><text x="1620" y="1790"  fill="rgb(255 255 255)">ghtError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(</text><text x="1917" y="1790"  fill="rgb(237 28 36)">q.TRANSFORMATIONS); } this.validateOptions(q.OPTION</text><text x="2070" y="1790"  fill="rgb(255 255 255)">S); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).len</text><text x="0" y="1795"  fill="rgb(255 255 255)">gth !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGR</text><text x="357" y="1795"  fill="rgb(237 28 36)">OUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should ha</text><text x="735" y="1795"  fill="rgb(255 255 255)">s at least one element } for (let key o</text><text x="852" y="1795"  fill="rgb(24 158 180)">f q) { this.validateKey(key); this.transformationKey.push(key); // if the key is vali</text><text x="1107" y="1795"  fill="rgb(255 255 255)">d, push it to transforma</text><text x="1179" y="1795"  fill="rgb(24 158 180)">tionKey } } private validateKey(key: string): void { let splitte</text><text x="1371" y="1795"  fill="rgb(255 255 255)">dKey: string[] = key.split(&quot;_&quot;); if</text><text x="1476" y="1795"  fill="rgb(24 158 180)"> (splittedKey.length !== 2) { throw new InsightE</text><text x="1620" y="1795"  fill="rgb(255 255 255)">rror(); } if (!(this.val</text><text x="1692" y="1795"  fill="rgb(24 158 180)">idateId</text><text x="1713" y="1795"  fill="rgb(255 255 255)">string(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || t</text><text x="1920" y="1795"  fill="rgb(237 28 36)">his.sfields.includes(splittedKey[1])))) { throw n</text><text x="2067" y="1795"  fill="rgb(255 255 255)">ew InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and sho</text><text x="0" y="1800"  fill="rgb(255 255 255)">uld have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).lengt</text><text x="357" y="1800"  fill="rgb(237 28 36)">h &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if </text><text x="735" y="1800"  fill="rgb(255 255 255)">(applykey.length === 0 || applykey.incl</text><text x="852" y="1800"  fill="rgb(24 158 180)">udes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } </text><text x="1110" y="1800"  fill="rgb(255 255 255)">this.transformationKey.p</text><text x="1182" y="1800"  fill="rgb(24 158 180)">ush(applykey); if (Array.isArray(criteria) || Object.keys(crite</text><text x="1371" y="1800"  fill="rgb(255 255 255)">ria).length &gt; 1) { throw new Insig</text><text x="1473" y="1800"  fill="rgb(24 158 180)">htError(); } let applytoken: string = Object.key</text><text x="1617" y="1800"  fill="rgb(255 255 255)">s(criteria)[0]; if (!th</text><text x="1686" y="1800"  fill="rgb(24 158 180)">is.mtoken.</text><text x="1716" y="1800"  fill="rgb(255 255 255)">includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw </text><text x="1920" y="1800"  fill="rgb(237 28 36)">new InsightError(); } let key: string[] = criteri</text><text x="2067" y="1800"  fill="rgb(255 255 255)">a[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstrin</text><text x="0" y="1805"  fill="rgb(255 255 255)">g(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)</text><text x="357" y="1805"  fill="rgb(237 28 36)">) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new Insi</text><text x="735" y="1805"  fill="rgb(255 255 255)">ghtError(); } } } } public validateOpti</text><text x="852" y="1805"  fill="rgb(24 158 180)">ons(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !</text><text x="1113" y="1805"  fill="rgb(255 255 255)">== &quot;COLUMNS&quot; &amp;&amp; key !== </text><text x="1185" y="1805"  fill="rgb(24 158 180)">&quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q</text><text x="1374" y="1805"  fill="rgb(255 255 255)">.COLUMNS); if (q.ORDER) { this.</text><text x="1467" y="1805"  fill="rgb(24 158 180)">validateOrder(q.ORDER); } } private validateColum</text><text x="1614" y="1805"  fill="rgb(255 255 255)">ns(q: any): void { if </text><text x="1680" y="1805"  fill="rgb(24 158 180)">(!q || q.leng</text><text x="1719" y="1805"  fill="rgb(255 255 255)">th &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (th</text><text x="1920" y="1805"  fill="rgb(237 28 36)">is.transformationKey.length &gt; 0) { if (!this.tran</text><text x="2067" y="1805"  fill="rgb(255 255 255)">sformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private valid</text><text x="0" y="1810"  fill="rgb(255 255 255)">ateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!thi</text><text x="357" y="1810"  fill="rgb(237 28 36)">s.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { thro</text><text x="735" y="1810"  fill="rgb(255 255 255)">w new InsightError(); } if (q.dir !== &quot;</text><text x="852" y="1810"  fill="rgb(24 158 180)">UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Arra</text><text x="1116" y="1810"  fill="rgb(255 255 255)">y.isArray(keys) || keys.l</text><text x="1191" y="1810"  fill="rgb(24 158 180)">ength &lt; 1) { throw new InsightError(); } for (let anykey of k</text><text x="1374" y="1810"  fill="rgb(255 255 255)">eys) { if (!this.keysInQuery.i</text><text x="1464" y="1810"  fill="rgb(24 158 180)">ncludes(anykey)) { throw new InsightError(); } } </text><text x="1611" y="1810"  fill="rgb(255 255 255)">} } public validateWhe</text><text x="1677" y="1810"  fill="rgb(24 158 180)">re(q: any): vo</text><text x="1719" y="1810"  fill="rgb(255 255 255)">id { if (Array.isArray(q)) { throw new InsightError(); } else { if </text><text x="1920" y="1810"  fill="rgb(237 28 36)">(Object.keys(q).length !== 0) { this.validateFilt</text><text x="2067" y="1810"  fill="rgb(255 255 255)">er(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Obje</text><text x="0" y="1815"  fill="rgb(255 255 255)">ct.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); b</text><text x="357" y="1815"  fill="rgb(237 28 36)">reak; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;I</text><text x="732" y="1815"  fill="rgb(255 255 255)">S&quot;: this.validateIS(value); break; defau</text><text x="852" y="1815"  fill="rgb(24 158 180)">lt: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof va</text><text x="1119" y="1815"  fill="rgb(255 255 255)">lue !== &quot;object&quot;) { throw</text><text x="1194" y="1815"  fill="rgb(24 158 180)"> new InsightError(); } this.validateFilter(value); } private </text><text x="1377" y="1815"  fill="rgb(255 255 255)">validateIS(value: any): voi</text><text x="1458" y="1815"  fill="rgb(24 158 180)">d { if (typeof value !== &quot;object&quot;) { throw new Ins</text><text x="1608" y="1815"  fill="rgb(255 255 255)">ightError(); } if (Ob</text><text x="1671" y="1815"  fill="rgb(24 158 180)">ject.keys(value).</text><text x="1722" y="1815"  fill="rgb(255 255 255)">length !== 1) { throw new InsightError(); } let skey: string[] = O</text><text x="1920" y="1815"  fill="rgb(237 28 36)">bject.keys(value)[0].split(&quot;_&quot;); if (skey.length </text><text x="2067" y="1815"  fill="rgb(255 255 255)">!== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]</text><text x="0" y="1820"  fill="rgb(255 255 255)">; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.valid</text><text x="357" y="1820"  fill="rgb(237 28 36)">ateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: an</text><text x="732" y="1820"  fill="rgb(255 255 255)">y): void { if (typeof value !== &quot;object</text><text x="849" y="1820"  fill="rgb(24 158 180)">&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Ob</text><text x="1122" y="1820"  fill="rgb(255 255 255)">ject.keys(value)[0].split</text><text x="1197" y="1820"  fill="rgb(24 158 180)">(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } </text><text x="1377" y="1820"  fill="rgb(255 255 255)">else { let idstring: strin</text><text x="1455" y="1820"  fill="rgb(24 158 180)">g = mkey[0]; let mfield: string = mkey[1]; let num</text><text x="1605" y="1820"  fill="rgb(255 255 255)">: any = Object.values</text><text x="1668" y="1820"  fill="rgb(24 158 180)">(value)[0]; if ((t</text><text x="1722" y="1820"  fill="rgb(255 255 255)">ypeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !th</text><text x="1920" y="1820"  fill="rgb(237 28 36)">is.mfields.includes(mfield)) { throw new Insight</text><text x="2064" y="1820"  fill="rgb(255 255 255)">Error(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let in</text><text x="0" y="1825"  fill="rgb(255 255 255)">nerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (t</text><text x="357" y="1825"  fill="rgb(237 28 36)">his.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this</text><text x="732" y="1825"  fill="rgb(255 255 255)">.idInQuery.push(idstring); if (insightD</text><text x="849" y="1825"  fill="rgb(24 158 180)">ataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfield</text><text x="1125" y="1825"  fill="rgb(255 255 255)">s = this.coursesfields; }</text><text x="1200" y="1825"  fill="rgb(24 158 180)"> else { this.mfields = this.roommfields; this.sfields = thi</text><text x="1377" y="1825"  fill="rgb(255 255 255)">s.roomsfields; } return t</text><text x="1452" y="1825"  fill="rgb(24 158 180)">rue; } } return false; } else { return this.idInQue</text><text x="1605" y="1825"  fill="rgb(255 255 255)">ry.includes(idstring</text><text x="1665" y="1825"  fill="rgb(24 158 180)">); } } public getId</text><text x="1722" y="1825"  fill="rgb(255 255 255)">InQuery(): string[] { return this.idInQuery; } } import {InsightDa</text><text x="1920" y="1825"  fill="rgb(237 28 36)">taset, InsightDatasetKind, InsightError} from &quot;.</text><text x="2064" y="1825"  fill="rgb(255 255 255)">/IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; priv</text><text x="0" y="1830"  fill="rgb(255 255 255)">ate readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: str</text><text x="357" y="1830"  fill="rgb(237 28 36)">ing[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;addre</text><text x="732" y="1830"  fill="rgb(255 255 255)">ss&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; priv</text><text x="849" y="1830"  fill="rgb(24 158 180)">ate readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: strin</text><text x="1128" y="1830"  fill="rgb(255 255 255)">g[] = [&quot;COUNT&quot;]; private </text><text x="1203" y="1830"  fill="rgb(24 158 180)">idInQuery: string[]; // make sure the query only has one id</text><text x="1380" y="1830"  fill="rgb(255 255 255)"> private keysInQuery: </text><text x="1446" y="1830"  fill="rgb(24 158 180)">string[]; // all keys appeared in columns after bein</text><text x="1602" y="1830"  fill="rgb(255 255 255)">g validated private </text><text x="1662" y="1830"  fill="rgb(24 158 180)">transformationKey: st</text><text x="1725" y="1830"  fill="rgb(255 255 255)">ring[]; // keys appeared in transformation, if there is a transfo</text><text x="1920" y="1830"  fill="rgb(237 28 36)">rmation private allInsightDataset: InsightDatase</text><text x="2064" y="1830"  fill="rgb(255 255 255)">t[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery</text><text x="0" y="1835"  fill="rgb(255 255 255)"> = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q </text><text x="357" y="1835"  fill="rgb(237 28 36)">|| !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;</text><text x="732" y="1835"  fill="rgb(255 255 255)">WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { </text><text x="849" y="1835"  fill="rgb(24 158 180)">throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.valida</text><text x="1134" y="1835"  fill="rgb(255 255 255)">teTransformations(q.TRAN</text><text x="1206" y="1835"  fill="rgb(24 158 180)">SFORMATIONS); } this.validateOptions(q.OPTIONS); } public </text><text x="1380" y="1835"  fill="rgb(255 255 255)">validateTransformatio</text><text x="1443" y="1835"  fill="rgb(24 158 180)">ns(q: any): void { if (typeof q.GROUP === &quot;undefined</text><text x="1599" y="1835"  fill="rgb(255 255 255)">&quot; || typeof q.APPLY </text><text x="1659" y="1835"  fill="rgb(24 158 180)">=== &quot;undefined&quot; || Obj</text><text x="1725" y="1835"  fill="rgb(255 255 255)">ect.keys(q).length !== 2) { throw new InsightError(); } this.vali</text><text x="1920" y="1835"  fill="rgb(237 28 36)">dateGROUP(q.GROUP); this.validateAPPLY(q.APPLY);</text><text x="2064" y="1835"  fill="rgb(255 255 255)"> } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should </text><text x="0" y="1840"  fill="rgb(255 255 255)">has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key </text><text x="357" y="1840"  fill="rgb(237 28 36)">is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;</text><text x="732" y="1840"  fill="rgb(255 255 255)">); if (splittedKey.length !== 2) { thro</text><text x="849" y="1840"  fill="rgb(24 158 180)">w new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(sp</text><text x="1137" y="1840"  fill="rgb(255 255 255)">littedKey[1]) || this.sfi</text><text x="1212" y="1840"  fill="rgb(24 158 180)">elds.includes(splittedKey[1])))) { throw new InsightErro</text><text x="1380" y="1840"  fill="rgb(255 255 255)">r(); } } private val</text><text x="1440" y="1840"  fill="rgb(24 158 180)">idateAPPLY(q: any): void { if (!Array.isArray(q)) { </text><text x="1596" y="1840"  fill="rgb(255 255 255)">throw new InsightErr</text><text x="1656" y="1840"  fill="rgb(24 158 180)">or(); // q should be an</text><text x="1725" y="1840"  fill="rgb(255 255 255)"> array, and should have at least one element } for (let applyrule</text><text x="1920" y="1840"  fill="rgb(237 28 36)"> of q) { if (Array.isArray(applyrule) || Object.</text><text x="2064" y="1840"  fill="rgb(255 255 255)">keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; i</text><text x="0" y="1845"  fill="rgb(255 255 255)">f (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightErr</text><text x="357" y="1845"  fill="rgb(237 28 36)">or(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new I</text><text x="732" y="1845"  fill="rgb(255 255 255)">nsightError(); } let applytoken: string</text><text x="849" y="1845"  fill="rgb(24 158 180)"> = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(appl</text><text x="1140" y="1845"  fill="rgb(255 255 255)">ytoken)) { throw new Insi</text><text x="1215" y="1845"  fill="rgb(24 158 180)">ghtError(); } let key: string[] = criteria[applytoken].s</text><text x="1383" y="1845"  fill="rgb(255 255 255)">plit(&quot;_&quot;); if (key</text><text x="1437" y="1845"  fill="rgb(24 158 180)">.length !== 2) { throw new InsightError(); } if (thi</text><text x="1593" y="1845"  fill="rgb(255 255 255)">s.mtoken.includes(ap</text><text x="1653" y="1845"  fill="rgb(24 158 180)">plytoken)) { if (!(this.</text><text x="1725" y="1845"  fill="rgb(255 255 255)">validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { thr</text><text x="1920" y="1845"  fill="rgb(237 28 36)">ow new InsightError(); } } else if (this.mstoke</text><text x="2061" y="1845"  fill="rgb(255 255 255)">n.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new In</text><text x="0" y="1850"  fill="rgb(255 255 255)">sightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { </text><text x="357" y="1850"  fill="rgb(237 28 36)">if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { thi</text><text x="732" y="1850"  fill="rgb(255 255 255)">s.validateOrder(q.ORDER); } } private </text><text x="846" y="1850"  fill="rgb(24 158 180)">validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mske</text><text x="1143" y="1850"  fill="rgb(255 255 255)">y of q) { if (this.transf</text><text x="1218" y="1850"  fill="rgb(24 158 180)">ormationKey.length &gt; 0) { if (!this.transformationKey.i</text><text x="1383" y="1850"  fill="rgb(255 255 255)">ncludes(mskey)) </text><text x="1431" y="1850"  fill="rgb(24 158 180)">{ throw new InsightError(); } } else { this.validateKe</text><text x="1593" y="1850"  fill="rgb(255 255 255)">y(mskey); } this.ke</text><text x="1650" y="1850"  fill="rgb(24 158 180)">ysInQuery.push(mskey); } </text><text x="1725" y="1850"  fill="rgb(255 255 255)">} private validateOrder(q: any): void { if (Array.isArray(q)) { t</text><text x="1920" y="1850"  fill="rgb(237 28 36)">hrow new InsightError(); } else if (typeof q ==</text><text x="2061" y="1850"  fill="rgb(255 255 255)">= &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { th</text><text x="0" y="1855"  fill="rgb(255 255 255)">row new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys;</text><text x="357" y="1855"  fill="rgb(237 28 36)"> if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.</text><text x="732" y="1855"  fill="rgb(255 255 255)">includes(anykey)) { throw new InsightE</text><text x="846" y="1855"  fill="rgb(24 158 180)">rror(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(</text><text x="1146" y="1855"  fill="rgb(255 255 255)">); } else { if (Object.ke</text><text x="1221" y="1855"  fill="rgb(24 158 180)">ys(q).length !== 0) { this.validateFilter(q); } } } pr</text><text x="1383" y="1855"  fill="rgb(255 255 255)">ivate validateF</text><text x="1428" y="1855"  fill="rgb(24 158 180)">ilter(q: any): void { if (Object.keys(q).length !== 1)</text><text x="1590" y="1855"  fill="rgb(255 255 255)"> { throw new Insigh</text><text x="1647" y="1855"  fill="rgb(24 158 180)">tError(); } else { let key:</text><text x="1728" y="1855"  fill="rgb(255 255 255)"> string = Object.keys(q)[0]; let value: any = Object.values(q)[0</text><text x="1920" y="1855"  fill="rgb(237 28 36)">]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.v</text><text x="2061" y="1855"  fill="rgb(255 255 255)">alidateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;</text><text x="0" y="1860"  fill="rgb(255 255 255)">IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if</text><text x="357" y="1860"  fill="rgb(237 28 36)"> (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void</text><text x="732" y="1860"  fill="rgb(255 255 255)"> { if (typeof value !== &quot;object&quot;) { th</text><text x="846" y="1860"  fill="rgb(24 158 180)">row new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey</text><text x="1149" y="1860"  fill="rgb(255 255 255)">: string[] = Object.keys(</text><text x="1224" y="1860"  fill="rgb(24 158 180)">value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw </text><text x="1383" y="1860"  fill="rgb(255 255 255)">new InsightErr</text><text x="1425" y="1860"  fill="rgb(24 158 180)">or(); } else { let idstring: string = skey[0]; let sfi</text><text x="1587" y="1860"  fill="rgb(255 255 255)">eld: string = skey[</text><text x="1644" y="1860"  fill="rgb(24 158 180)">1]; let str: any = Object.va</text><text x="1728" y="1860"  fill="rgb(255 255 255)">lues(value)[0]; if (typeof str !== &quot;string&quot;) { throw new Insight</text><text x="1920" y="1860"  fill="rgb(237 28 36)">Error(); } else { if ((str.slice(1, -1).include</text><text x="2061" y="1860"  fill="rgb(255 255 255)">s(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: a</text><text x="0" y="1865"  fill="rgb(255 255 255)">ny): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: s</text><text x="357" y="1865"  fill="rgb(237 28 36)">tring[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string </text><text x="732" y="1865"  fill="rgb(255 255 255)">= mkey[0]; let mfield: string = mkey[1</text><text x="846" y="1865"  fill="rgb(24 158 180)">]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(ids</text><text x="1152" y="1865"  fill="rgb(255 255 255)">tring) || !this.mfields.i</text><text x="1227" y="1865"  fill="rgb(24 158 180)">ncludes(mfield)) { throw new InsightError(); } } } pr</text><text x="1386" y="1865"  fill="rgb(255 255 255)">ivate valida</text><text x="1422" y="1865"  fill="rgb(24 158 180)">teANDOR(value: any): void { if (!Array.isArray(value) |</text><text x="1587" y="1865"  fill="rgb(255 255 255)">| value.length &lt; 1</text><text x="1641" y="1865"  fill="rgb(24 158 180)">) { throw new InsightError();</text><text x="1728" y="1865"  fill="rgb(255 255 255)"> } for (let innerObject of value) { this.validateFilter(innerObj</text><text x="1920" y="1865"  fill="rgb(237 28 36)">ect); } } private validateIdstring(idstring: st</text><text x="2061" y="1865"  fill="rgb(255 255 255)">ring): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { thi</text><text x="0" y="1870"  fill="rgb(255 255 255)">s.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields;</text><text x="360" y="1870"  fill="rgb(237 28 36)"> this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true</text><text x="732" y="1870"  fill="rgb(255 255 255)">; } } return false; } else { return th</text><text x="846" y="1870"  fill="rgb(24 158 180)">is.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } impor</text><text x="1155" y="1870"  fill="rgb(255 255 255)">t {InsightDataset, Insigh</text><text x="1230" y="1870"  fill="rgb(24 158 180)">tDatasetKind, InsightError} from &quot;./IInsightFacade&quot;;</text><text x="1386" y="1870"  fill="rgb(255 255 255)"> export de</text><text x="1416" y="1870"  fill="rgb(24 158 180)">fault class QueryValidator { private readonly coursemfie</text><text x="1584" y="1870"  fill="rgb(255 255 255)">lds: string[] = [&quot;a</text><text x="1641" y="1870"  fill="rgb(24 158 180)">vg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;,</text><text x="1728" y="1870"  fill="rgb(255 255 255)"> &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;i</text><text x="1920" y="1870"  fill="rgb(237 28 36)">d&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private re</text><text x="2058" y="1870"  fill="rgb(255 255 255)">adonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;addr</text><text x="0" y="1875"  fill="rgb(255 255 255)">ess&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly m</text><text x="360" y="1875"  fill="rgb(237 28 36)">stoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: strin</text><text x="732" y="1875"  fill="rgb(255 255 255)">g[]; // all keys appeared in columns a</text><text x="846" y="1875"  fill="rgb(24 158 180)">fter being validated private transformationKey: string[]; // keys appeared in transformation, if there i</text><text x="1158" y="1875"  fill="rgb(255 255 255)">s a transformation privat</text><text x="1233" y="1875"  fill="rgb(24 158 180)">e allInsightDataset: InsightDataset[]; private mfie</text><text x="1386" y="1875"  fill="rgb(255 255 255)">lds: stri</text><text x="1413" y="1875"  fill="rgb(24 158 180)">ng[]; private sfields: string[]; constructor(insightData</text><text x="1581" y="1875"  fill="rgb(255 255 255)">sets: InsightDatase</text><text x="1638" y="1875"  fill="rgb(24 158 180)">t[]) { this.idInQuery = []; th</text><text x="1728" y="1875"  fill="rgb(255 255 255)">is.keysInQuery = []; this.transformationKey = []; this.allInsigh</text><text x="1920" y="1875"  fill="rgb(237 28 36)">tDataset = insightDatasets; } public validate(</text><text x="2058" y="1875"  fill="rgb(255 255 255)">q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== </text><text x="0" y="1880"  fill="rgb(255 255 255)">&quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS</text><text x="360" y="1880"  fill="rgb(237 28 36)">) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: </text><text x="732" y="1880"  fill="rgb(255 255 255)">any): void { if (typeof q.GROUP === &quot;u</text><text x="846" y="1880"  fill="rgb(24 158 180)">ndefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); }</text><text x="1161" y="1880"  fill="rgb(255 255 255)"> this.validateGROUP(q.GRO</text><text x="1236" y="1880"  fill="rgb(24 158 180)">UP); this.validateAPPLY(q.APPLY); } private valida</text><text x="1386" y="1880"  fill="rgb(255 255 255)">teGROUP(</text><text x="1410" y="1880"  fill="rgb(24 158 180)">q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { </text><text x="1581" y="1880"  fill="rgb(255 255 255)">throw new InsightE</text><text x="1635" y="1880"  fill="rgb(24 158 180)">rror(); // q should be an objec</text><text x="1728" y="1880"  fill="rgb(255 255 255)">t, and should has at least one element } for (let key of q) { th</text><text x="1920" y="1880"  fill="rgb(237 28 36)">is.validateKey(key); this.transformationKey.pu</text><text x="2058" y="1880"  fill="rgb(255 255 255)">sh(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_</text><text x="0" y="1885"  fill="rgb(255 255 255)">&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfi</text><text x="360" y="1885"  fill="rgb(237 28 36)">elds.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAP</text><text x="732" y="1885"  fill="rgb(255 255 255)">PLY(q: any): void { if (!Array.isArray</text><text x="846" y="1885"  fill="rgb(24 158 180)">(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let </text><text x="1164" y="1885"  fill="rgb(255 255 255)">applyrule of q) { if (Arr</text><text x="1239" y="1885"  fill="rgb(24 158 180)">ay.isArray(applyrule) || Object.keys(applyrule).le</text><text x="1389" y="1885"  fill="rgb(255 255 255)">ngth &gt;</text><text x="1407" y="1885"  fill="rgb(24 158 180)"> 1) { throw new InsightError(); } let applykey: string = </text><text x="1578" y="1885"  fill="rgb(255 255 255)">Object.keys(applyr</text><text x="1632" y="1885"  fill="rgb(24 158 180)">ule)[0]; let criteria = applyrul</text><text x="1728" y="1885"  fill="rgb(255 255 255)">e[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) </text><text x="1923" y="1885"  fill="rgb(237 28 36)">|| this.transformationKey.includes(applykey))</text><text x="2058" y="1885"  fill="rgb(255 255 255)"> { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new </text><text x="0" y="1890"  fill="rgb(255 255 255)">InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.msto</text><text x="360" y="1890"  fill="rgb(237 28 36)">ken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !</text><text x="735" y="1890"  fill="rgb(255 255 255)">== 2) { throw new InsightError(); } </text><text x="843" y="1890"  fill="rgb(24 158 180)">if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1])</text><text x="1167" y="1890"  fill="rgb(255 255 255)">)) { throw new InsightErr</text><text x="1242" y="1890"  fill="rgb(24 158 180)">or(); } } else if (this.mstoken.includes(applytok</text><text x="1389" y="1890"  fill="rgb(255 255 255)">en)) </text><text x="1404" y="1890"  fill="rgb(24 158 180)">{ if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.in</text><text x="1575" y="1890"  fill="rgb(255 255 255)">cludes(key[1]) || t</text><text x="1632" y="1890"  fill="rgb(24 158 180)">his.mfields.includes(key[1])))) </text><text x="1728" y="1890"  fill="rgb(255 255 255)">{ throw new InsightError(); } } } } public validateOptions(q: any</text><text x="1923" y="1890"  fill="rgb(237 28 36)">): void { let keys: any[] = Object.keys(q); f</text><text x="2058" y="1890"  fill="rgb(255 255 255)">or (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { th</text><text x="0" y="1895"  fill="rgb(255 255 255)">is.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(</text><text x="360" y="1895"  fill="rgb(237 28 36)">); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new</text><text x="735" y="1895"  fill="rgb(255 255 255)"> InsightError(); } } else { this.val</text><text x="843" y="1895"  fill="rgb(24 158 180)">idateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(</text><text x="1170" y="1895"  fill="rgb(255 255 255)">q)) { throw new InsightEr</text><text x="1245" y="1895"  fill="rgb(24 158 180)">ror(); } else if (typeof q === &quot;string&quot;) { if (!</text><text x="1389" y="1895"  fill="rgb(255 255 255)">thi</text><text x="1398" y="1895"  fill="rgb(24 158 180)">s.keysInQuery.includes(q)) { throw new InsightError(); } } </text><text x="1575" y="1895"  fill="rgb(255 255 255)">else { if (!q.dir </text><text x="1629" y="1895"  fill="rgb(24 158 180)">|| !q.keys || Object.keys(q).lengt</text><text x="1731" y="1895"  fill="rgb(255 255 255)">h !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.d</text><text x="1923" y="1895"  fill="rgb(237 28 36)">ir !== &quot;DOWN&quot;) { throw new InsightError(); }</text><text x="2055" y="1895"  fill="rgb(255 255 255)"> let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery</text><text x="0" y="1900"  fill="rgb(255 255 255)">.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { thro</text><text x="360" y="1900"  fill="rgb(237 28 36)">w new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any</text><text x="735" y="1900"  fill="rgb(255 255 255)">): void { if (Object.keys(q).length </text><text x="843" y="1900"  fill="rgb(24 158 180)">!== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.value</text><text x="1173" y="1900"  fill="rgb(255 255 255)">s(q)[0]; switch (key) { </text><text x="1245" y="1900"  fill="rgb(24 158 180)">case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value)</text><text x="1389" y="1900"  fill="rgb(255 255 255)">; </text><text x="1395" y="1900"  fill="rgb(24 158 180)">break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT</text><text x="1572" y="1900"  fill="rgb(255 255 255)">&quot;: case &quot;LT&quot;: case</text><text x="1626" y="1900"  fill="rgb(24 158 180)"> &quot;EQ&quot;: this.validateGTLTEQ(value); </text><text x="1731" y="1900"  fill="rgb(255 255 255)">break; case &quot;IS&quot;: this.validateIS(value); break; default: throw </text><text x="1923" y="1900"  fill="rgb(237 28 36)">new InsightError(); } } } private validateNO</text><text x="2055" y="1900"  fill="rgb(255 255 255)">T(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): voi</text><text x="0" y="1905"  fill="rgb(255 255 255)">d { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new Insight</text><text x="363" y="1905"  fill="rgb(237 28 36)">Error(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else </text><text x="735" y="1905"  fill="rgb(255 255 255)">{ let idstring: string = skey[0]; le</text><text x="843" y="1905"  fill="rgb(24 158 180)">t sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new In</text><text x="1176" y="1905"  fill="rgb(255 255 255)">sightError(); } else { i</text><text x="1248" y="1905"  fill="rgb(24 158 180)">f ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.va</text><text x="1389" y="1905"  fill="rgb(255 255 255)">l</text><text x="1392" y="1905"  fill="rgb(24 158 180)">idateIdstring(idstring) || !this.sfields.includes(sfield)) </text><text x="1569" y="1905"  fill="rgb(255 255 255)">{ throw new Insight</text><text x="1626" y="1905"  fill="rgb(24 158 180)">Error(); } } } } private validateGT</text><text x="1731" y="1905"  fill="rgb(255 255 255)">LTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object</text><text x="1923" y="1905"  fill="rgb(237 28 36)">.keys(value).length !== 1) { throw new Insig</text><text x="2055" y="1905"  fill="rgb(255 255 255)">htError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string</text><text x="0" y="1910"  fill="rgb(255 255 255)"> = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.</text><text x="363" y="1910"  fill="rgb(237 28 36)">validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value:</text><text x="735" y="1910"  fill="rgb(255 255 255)"> any): void { if (!Array.isArray(val</text><text x="843" y="1910"  fill="rgb(24 158 180)">ue) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(inne</text><text x="1179" y="1910"  fill="rgb(255 255 255)">rObject); } } private va</text><text x="1251" y="1910"  fill="rgb(24 158 180)">lidateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of </text><text x="1569" y="1910"  fill="rgb(255 255 255)">this.allInsightDat</text><text x="1623" y="1910"  fill="rgb(24 158 180)">aset) { if (insightDataset.id === id</text><text x="1731" y="1910"  fill="rgb(255 255 255)">string) { this.idInQuery.push(idstring); if (insightDataset.kind</text><text x="1923" y="1910"  fill="rgb(237 28 36)"> === InsightDatasetKind.Courses) { this.mfie</text><text x="2055" y="1910"  fill="rgb(255 255 255)">lds = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return tru</text><text x="0" y="1915"  fill="rgb(255 255 255)">e; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this</text><text x="363" y="1915"  fill="rgb(237 28 36)">.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class Quer</text><text x="735" y="1915"  fill="rgb(255 255 255)">yValidator { private readonly course</text><text x="843" y="1915"  fill="rgb(24 158 180)">mfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;,</text><text x="1182" y="1915"  fill="rgb(255 255 255)"> &quot;id&quot;, &quot;instructor&quot;, &quot;ti</text><text x="1254" y="1915"  fill="rgb(24 158 180)">tle&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsf</text><text x="1566" y="1915"  fill="rgb(255 255 255)">ields: string[] = [</text><text x="1623" y="1915"  fill="rgb(24 158 180)">&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , </text><text x="1731" y="1915"  fill="rgb(255 255 255)">&quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonl</text><text x="1923" y="1915"  fill="rgb(237 28 36)">y mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, </text><text x="2052" y="1915"  fill="rgb(255 255 255)">&quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: stri</text><text x="0" y="1920"  fill="rgb(255 255 255)">ng[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in tran</text><text x="363" y="1920"  fill="rgb(237 28 36)">sformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfi</text><text x="735" y="1920"  fill="rgb(255 255 255)">elds: string[]; constructor(insightD</text><text x="843" y="1920"  fill="rgb(24 158 180)">atasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsi</text><text x="1185" y="1920"  fill="rgb(255 255 255)">ghtDataset = insightDat</text><text x="1254" y="1920"  fill="rgb(24 158 180)">asets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); }</text><text x="1566" y="1920"  fill="rgb(255 255 255)"> for (let key of O</text><text x="1620" y="1920"  fill="rgb(24 158 180)">bject.keys(q)) { if (key !== &quot;OPTIONS</text><text x="1731" y="1920"  fill="rgb(255 255 255)">&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new I</text><text x="1923" y="1920"  fill="rgb(237 28 36)">nsightError(); } } this.validateWhere(q.WHE</text><text x="2052" y="1920"  fill="rgb(255 255 255)">RE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q:</text><text x="0" y="1925"  fill="rgb(255 255 255)"> any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { thro</text><text x="363" y="1925"  fill="rgb(237 28 36)">w new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if</text><text x="735" y="1925"  fill="rgb(255 255 255)"> (!Array.isArray(q) || q.length &lt; 1)</text><text x="843" y="1925"  fill="rgb(24 158 180)"> { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { t</text><text x="1188" y="1925"  fill="rgb(255 255 255)">his.validateKey(key); t</text><text x="1257" y="1925"  fill="rgb(24 158 180)">his.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private vali</text><text x="1563" y="1925"  fill="rgb(255 255 255)">dateKey(key: strin</text><text x="1617" y="1925"  fill="rgb(24 158 180)">g): void { let splittedKey: string[] =</text><text x="1731" y="1925"  fill="rgb(255 255 255)"> key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new Insi</text><text x="1920" y="1925"  fill="rgb(237 28 36)">ghtError(); } if (!(this.validateIdstring(sp</text><text x="2052" y="1925"  fill="rgb(255 255 255)">littedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateA</text><text x="0" y="1930"  fill="rgb(255 255 255)">PPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least</text><text x="363" y="1930"  fill="rgb(237 28 36)"> one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new Ins</text><text x="735" y="1930"  fill="rgb(255 255 255)">ightError(); } let applykey: string </text><text x="843" y="1930"  fill="rgb(24 158 180)">= Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;)</text><text x="1191" y="1930"  fill="rgb(255 255 255)"> || this.transformation</text><text x="1260" y="1930"  fill="rgb(24 158 180)">Key.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Arr</text><text x="1560" y="1930"  fill="rgb(255 255 255)">ay.isArray(criteria</text><text x="1617" y="1930"  fill="rgb(24 158 180)">) || Object.keys(criteria).length &gt; 1)</text><text x="1731" y="1930"  fill="rgb(255 255 255)"> { throw new InsightError(); } let applytoken: string = Object.</text><text x="1920" y="1930"  fill="rgb(237 28 36)">keys(criteria)[0]; if (!this.mtoken.includes</text><text x="2052" y="1930"  fill="rgb(255 255 255)">(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length</text><text x="0" y="1935"  fill="rgb(255 255 255)"> !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.</text><text x="366" y="1935"  fill="rgb(237 28 36)">mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validat</text><text x="735" y="1935"  fill="rgb(255 255 255)">eIdstring(key[0]) &amp;&amp; (this.sfields.i</text><text x="843" y="1935"  fill="rgb(24 158 180)">ncludes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any</text><text x="1194" y="1935"  fill="rgb(255 255 255)">): void { let keys: an</text><text x="1260" y="1935"  fill="rgb(24 158 180)">y[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new </text><text x="1560" y="1935"  fill="rgb(255 255 255)">InsightError(); } </text><text x="1614" y="1935"  fill="rgb(24 158 180)">} this.validateColumns(q.COLUMNS); if (</text><text x="1731" y="1935"  fill="rgb(255 255 255)">q.ORDER) { this.validateOrder(q.ORDER); } } private validateCol</text><text x="1920" y="1935"  fill="rgb(237 28 36)">umns(q: any): void { if (!q || q.length &lt; 1</text><text x="2049" y="1935"  fill="rgb(255 255 255)">) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw n</text><text x="0" y="1940"  fill="rgb(255 255 255)">ew InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): </text><text x="366" y="1940"  fill="rgb(237 28 36)">void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes</text><text x="735" y="1940"  fill="rgb(255 255 255)">(q)) { throw new InsightError(); } }</text><text x="843" y="1940"  fill="rgb(24 158 180)"> else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.di</text><text x="1197" y="1940"  fill="rgb(255 255 255)">r !== &quot;DOWN&quot;) { throw </text><text x="1263" y="1940"  fill="rgb(24 158 180)">new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw</text><text x="1557" y="1940"  fill="rgb(255 255 255)"> new InsightError()</text><text x="1614" y="1940"  fill="rgb(24 158 180)">; } for (let anykey of keys) { if (!thi</text><text x="1731" y="1940"  fill="rgb(255 255 255)">s.keysInQuery.includes(anykey)) { throw new InsightError(); } }</text><text x="1920" y="1940"  fill="rgb(237 28 36)"> } } public validateWhere(q: any): void { i</text><text x="2049" y="1940"  fill="rgb(255 255 255)">f (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: a</text><text x="0" y="1945"  fill="rgb(255 255 255)">ny): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let</text><text x="366" y="1945"  fill="rgb(237 28 36)"> value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this</text><text x="735" y="1945"  fill="rgb(255 255 255)">.validateNOT(value); break; case &quot;GT</text><text x="843" y="1945"  fill="rgb(24 158 180)">&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw ne</text><text x="1200" y="1945"  fill="rgb(255 255 255)">w InsightError(); } }</text><text x="1263" y="1945"  fill="rgb(24 158 180)"> } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError</text><text x="1557" y="1945"  fill="rgb(255 255 255)">(); } this.validat</text><text x="1611" y="1945"  fill="rgb(24 158 180)">eFilter(value); } private validateIS(val</text><text x="1731" y="1945"  fill="rgb(255 255 255)">ue: any): void { if (typeof value !== &quot;object&quot;) { throw new Ins</text><text x="1920" y="1945"  fill="rgb(237 28 36)">ightError(); } if (Object.keys(value).lengt</text><text x="2049" y="1945"  fill="rgb(255 255 255)">h !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } els</text><text x="0" y="1950"  fill="rgb(255 255 255)">e { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !</text><text x="366" y="1950"  fill="rgb(237 28 36)">== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) |</text><text x="738" y="1950"  fill="rgb(255 255 255)">| !this.sfields.includes(sfield)) {</text><text x="843" y="1950"  fill="rgb(24 158 180)"> throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.k</text><text x="1200" y="1950"  fill="rgb(255 255 255)">eys(value).length !== </text><text x="1266" y="1950"  fill="rgb(24 158 180)">1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey</text><text x="1554" y="1950"  fill="rgb(255 255 255)">.length !== 2) { th</text><text x="1611" y="1950"  fill="rgb(24 158 180)">row new InsightError(); } else { let ids</text><text x="1731" y="1950"  fill="rgb(255 255 255)">tring: string = mkey[0]; let mfield: string = mkey[1]; let num:</text><text x="1920" y="1950"  fill="rgb(237 28 36)"> any = Object.values(value)[0]; if ((typeof</text><text x="2049" y="1950"  fill="rgb(255 255 255)"> num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(valu</text><text x="0" y="1955"  fill="rgb(255 255 255)">e: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value</text><text x="366" y="1955"  fill="rgb(237 28 36)">) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length ==</text><text x="738" y="1955"  fill="rgb(255 255 255)">= 0) { for (let insightDataset of t</text><text x="843" y="1955"  fill="rgb(24 158 180)">his.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind ==</text><text x="1203" y="1955"  fill="rgb(255 255 255)">= InsightDatasetKind.</text><text x="1266" y="1955"  fill="rgb(24 158 180)">Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.m</text><text x="1554" y="1955"  fill="rgb(255 255 255)">fields = this.room</text><text x="1608" y="1955"  fill="rgb(24 158 180)">mfields; this.sfields = this.roomsfields;</text><text x="1731" y="1955"  fill="rgb(255 255 255)"> } return true; } } return false; } else { return this.idInQuer</text><text x="1920" y="1955"  fill="rgb(237 28 36)">y.includes(idstring); } } public getIdInQu</text><text x="2046" y="1955"  fill="rgb(255 255 255)">ery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class Qu</text><text x="0" y="1960"  fill="rgb(255 255 255)">eryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly course</text><text x="369" y="1960"  fill="rgb(237 28 36)">sfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, </text><text x="738" y="1960"  fill="rgb(255 255 255)">&quot;seats&quot;]; private readonly roomsfie</text><text x="843" y="1960"  fill="rgb(24 158 180)">lds: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mt</text><text x="1206" y="1960"  fill="rgb(255 255 255)">oken: string[] = [&quot;MA</text><text x="1269" y="1960"  fill="rgb(24 158 180)">X&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: s</text><text x="1551" y="1960"  fill="rgb(255 255 255)">tring[]; // make su</text><text x="1608" y="1960"  fill="rgb(24 158 180)">re the query only has one id private keys</text><text x="1731" y="1960"  fill="rgb(255 255 255)">InQuery: string[]; // all keys appeared in columns after being </text><text x="1920" y="1960"  fill="rgb(237 28 36)">validated private transformationKey: strin</text><text x="2046" y="1960"  fill="rgb(255 255 255)">g[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private s</text><text x="0" y="1965"  fill="rgb(255 255 255)">fields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transfo</text><text x="369" y="1965"  fill="rgb(237 28 36)">rmationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIO</text><text x="738" y="1965"  fill="rgb(255 255 255)">NS) { throw new InsightError(); } f</text><text x="843" y="1965"  fill="rgb(24 158 180)">or (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new Insigh</text><text x="1209" y="1965"  fill="rgb(255 255 255)">tError(); } } this.v</text><text x="1269" y="1965"  fill="rgb(24 158 180)">alidateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS</text><text x="1551" y="1965"  fill="rgb(255 255 255)">); } this.validateO</text><text x="1608" y="1965"  fill="rgb(24 158 180)">ptions(q.OPTIONS); } public validateTrans</text><text x="1731" y="1965"  fill="rgb(255 255 255)">formations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; |</text><text x="1920" y="1965"  fill="rgb(237 28 36)">| typeof q.APPLY === &quot;undefined&quot; || Object</text><text x="2046" y="1965"  fill="rgb(255 255 255)">.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { </text><text x="0" y="1970"  fill="rgb(255 255 255)">if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one el</text><text x="369" y="1970"  fill="rgb(237 28 36)">ement } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to tr</text><text x="738" y="1970"  fill="rgb(255 255 255)">ansformationKey } } private validat</text><text x="843" y="1970"  fill="rgb(24 158 180)">eKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightErro</text><text x="1212" y="1970"  fill="rgb(255 255 255)">r(); } if (!(this.va</text><text x="1272" y="1970"  fill="rgb(24 158 180)">lidateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.inc</text><text x="1548" y="1970"  fill="rgb(255 255 255)">ludes(splittedKey[1</text><text x="1605" y="1970"  fill="rgb(24 158 180)">])))) { throw new InsightError(); } } priv</text><text x="1731" y="1970"  fill="rgb(255 255 255)">ate validateAPPLY(q: any): void { if (!Array.isArray(q)) { thro</text><text x="1920" y="1970"  fill="rgb(237 28 36)">w new InsightError(); // q should be an ar</text><text x="2046" y="1970"  fill="rgb(255 255 255)">ray, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new I</text><text x="0" y="1975"  fill="rgb(255 255 255)">nsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length </text><text x="369" y="1975"  fill="rgb(237 28 36)">=== 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transforma</text><text x="738" y="1975"  fill="rgb(255 255 255)">tionKey.push(applykey); if (Array.i</text><text x="843" y="1975"  fill="rgb(24 158 180)">sArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(cr</text><text x="1212" y="1975"  fill="rgb(255 255 255)">iteria)[0]; if (!thi</text><text x="1272" y="1975"  fill="rgb(24 158 180)">s.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightErro</text><text x="1548" y="1975"  fill="rgb(255 255 255)">r(); } let key: str</text><text x="1605" y="1975"  fill="rgb(24 158 180)">ing[] = criteria[applytoken].split(&quot;_&quot;); i</text><text x="1731" y="1975"  fill="rgb(255 255 255)">f (key.length !== 2) { throw new InsightError(); } if (this.mto</text><text x="1920" y="1975"  fill="rgb(237 28 36)">ken.includes(applytoken)) { if (!(this.va</text><text x="2043" y="1975"  fill="rgb(255 255 255)">lidateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.valid</text><text x="0" y="1980"  fill="rgb(255 255 255)">ateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } </text><text x="372" y="1980"  fill="rgb(237 28 36)">} public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;</text><text x="738" y="1980"  fill="rgb(255 255 255)">&amp; key !== &quot;ORDER&quot;) { throw new Insi</text><text x="843" y="1980"  fill="rgb(24 158 180)">ghtError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: </text><text x="1215" y="1980"  fill="rgb(255 255 255)">any): void { if (!q</text><text x="1272" y="1980"  fill="rgb(24 158 180)"> || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformat</text><text x="1545" y="1980"  fill="rgb(255 255 255)">ionKey.length &gt; 0) </text><text x="1602" y="1980"  fill="rgb(24 158 180)">{ if (!this.transformationKey.includes(mske</text><text x="1731" y="1980"  fill="rgb(255 255 255)">y)) { throw new InsightError(); } } else { this.validateKey(msk</text><text x="1920" y="1980"  fill="rgb(237 28 36)">ey); } this.keysInQuery.push(mskey); } } </text><text x="2043" y="1980"  fill="rgb(255 255 255)">private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includ</text><text x="0" y="1985"  fill="rgb(255 255 255)">es(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError</text><text x="372" y="1985"  fill="rgb(237 28 36)">(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys</text><text x="741" y="1985"  fill="rgb(255 255 255)">) || keys.length &lt; 1) { throw new </text><text x="843" y="1985"  fill="rgb(24 158 180)">InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } publ</text><text x="1218" y="1985"  fill="rgb(255 255 255)">ic validateWhere(q:</text><text x="1275" y="1985"  fill="rgb(24 158 180)"> any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q</text><text x="1545" y="1985"  fill="rgb(255 255 255)">).length !== 0) { t</text><text x="1602" y="1985"  fill="rgb(24 158 180)">his.validateFilter(q); } } } private valida</text><text x="1731" y="1985"  fill="rgb(255 255 255)">teFilter(q: any): void { if (Object.keys(q).length !== 1) { thr</text><text x="1920" y="1985"  fill="rgb(237 28 36)">ow new InsightError(); } else { let key: </text><text x="2043" y="1985"  fill="rgb(255 255 255)">string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: th</text><text x="0" y="1990"  fill="rgb(255 255 255)">is.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS</text><text x="372" y="1990"  fill="rgb(237 28 36)">(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;obje</text><text x="741" y="1990"  fill="rgb(255 255 255)">ct&quot;) { throw new InsightError(); }</text><text x="843" y="1990"  fill="rgb(24 158 180)"> this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(</text><text x="1221" y="1990"  fill="rgb(255 255 255)">); } if (Object.ke</text><text x="1275" y="1990"  fill="rgb(24 158 180)">ys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(va</text><text x="1542" y="1990"  fill="rgb(255 255 255)">lue)[0].split(&quot;_&quot;); </text><text x="1602" y="1990"  fill="rgb(24 158 180)">if (skey.length !== 2) { throw new InsightE</text><text x="1731" y="1990"  fill="rgb(255 255 255)">rror(); } else { let idstring: string = skey[0]; let sfield: st</text><text x="1920" y="1990"  fill="rgb(237 28 36)">ring = skey[1]; let str: any = Object.va</text><text x="2040" y="1990"  fill="rgb(255 255 255)">lues(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring</text><text x="0" y="1995"  fill="rgb(255 255 255)">) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (type</text><text x="372" y="1995"  fill="rgb(237 28 36)">of value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(va</text><text x="741" y="1995"  fill="rgb(255 255 255)">lue)[0].split(&quot;_&quot;); if (mkey.lengt</text><text x="843" y="1995"  fill="rgb(24 158 180)">h !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Obj</text><text x="1221" y="1995"  fill="rgb(255 255 255)">ect.values(value)[</text><text x="1275" y="1995"  fill="rgb(24 158 180)">0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.in</text><text x="1542" y="1995"  fill="rgb(255 255 255)">cludes(mfield)) { t</text><text x="1599" y="1995"  fill="rgb(24 158 180)">hrow new InsightError(); } } } private valid</text><text x="1731" y="1995"  fill="rgb(255 255 255)">ateANDOR(value: any): void { if (!Array.isArray(value) || value</text><text x="1920" y="1995"  fill="rgb(237 28 36)">.length &lt; 1) { throw new InsightError();</text><text x="2040" y="1995"  fill="rgb(255 255 255)"> } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length</text><text x="0" y="2000"  fill="rgb(255 255 255)"> === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idst</text><text x="375" y="2000"  fill="rgb(237 28 36)">ring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.co</text><text x="741" y="2000"  fill="rgb(255 255 255)">ursesfields; } else { this.mfields</text><text x="843" y="2000"  fill="rgb(24 158 180)"> = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(</text><text x="1224" y="2000"  fill="rgb(255 255 255)">idstring); } } pub</text><text x="1278" y="2000"  fill="rgb(24 158 180)">lic getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, Insig</text><text x="1539" y="2000"  fill="rgb(255 255 255)">htDatasetKind, Insig</text><text x="1599" y="2000"  fill="rgb(24 158 180)">htError} from &quot;./IInsightFacade&quot;; export def</text><text x="1731" y="2000"  fill="rgb(255 255 255)">ault class QueryValidator { private readonly coursemfields: str</text><text x="1920" y="2000"  fill="rgb(237 28 36)">ing[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;,</text><text x="2040" y="2000"  fill="rgb(255 255 255)"> &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon</text><text x="0" y="2005"  fill="rgb(255 255 255)">&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furnit</text><text x="375" y="2005"  fill="rgb(237 28 36)">ure&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;CO</text><text x="741" y="2005"  fill="rgb(255 255 255)">UNT&quot;]; private idInQuery: string[]</text><text x="843" y="2005"  fill="rgb(24 158 180)">; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated pr</text><text x="1227" y="2005"  fill="rgb(255 255 255)">ivate transformat</text><text x="1278" y="2005"  fill="rgb(24 158 180)">ionKey: string[]; // keys appeared in transformation, if there is a transformation priv</text><text x="1539" y="2005"  fill="rgb(255 255 255)">ate allInsightDatas</text><text x="1596" y="2005"  fill="rgb(24 158 180)">et: InsightDataset[]; private mfields: string</text><text x="1731" y="2005"  fill="rgb(255 255 255)">[]; private sfields: string[]; constructor(insightDatasets: Ins</text><text x="1920" y="2005"  fill="rgb(237 28 36)">ightDataset[]) { this.idInQuery = []; th</text><text x="2040" y="2005"  fill="rgb(255 255 255)">is.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OP</text><text x="0" y="2010"  fill="rgb(255 255 255)">TIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;T</text><text x="375" y="2010"  fill="rgb(237 28 36)">RANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransf</text><text x="741" y="2010"  fill="rgb(255 255 255)">ormations(q.TRANSFORMATIONS); } th</text><text x="843" y="2010"  fill="rgb(24 158 180)">is.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.A</text><text x="1227" y="2010"  fill="rgb(255 255 255)">PPLY === &quot;undefin</text><text x="1278" y="2010"  fill="rgb(24 158 180)">ed&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q</text><text x="1536" y="2010"  fill="rgb(255 255 255)">.GROUP); this.valida</text><text x="1596" y="2010"  fill="rgb(24 158 180)">teAPPLY(q.APPLY); } private validateGROUP(q: </text><text x="1731" y="2010"  fill="rgb(255 255 255)">any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new</text><text x="1920" y="2010"  fill="rgb(237 28 36)"> InsightError(); // q should be an obje</text><text x="2037" y="2010"  fill="rgb(255 255 255)">ct, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to</text><text x="0" y="2015"  fill="rgb(255 255 255)"> transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.le</text><text x="378" y="2015"  fill="rgb(237 28 36)">ngth !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKe</text><text x="744" y="2015"  fill="rgb(255 255 255)">y[1]) || this.sfields.includes(sp</text><text x="843" y="2015"  fill="rgb(24 158 180)">littedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new Insight</text><text x="1230" y="2015"  fill="rgb(255 255 255)">Error(); // q sho</text><text x="1281" y="2015"  fill="rgb(24 158 180)">uld be an array, and should have at least one element } for (let applyrule of q) { if</text><text x="1536" y="2015"  fill="rgb(255 255 255)"> (Array.isArray(appl</text><text x="1596" y="2015"  fill="rgb(24 158 180)">yrule) || Object.keys(applyrule).length &gt; 1) </text><text x="1731" y="2015"  fill="rgb(255 255 255)">{ throw new InsightError(); } let applykey: string = Object.key</text><text x="1920" y="2015"  fill="rgb(237 28 36)">s(applyrule)[0]; let criteria = applyru</text><text x="2037" y="2015"  fill="rgb(255 255 255)">le[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transfo</text><text x="0" y="2020"  fill="rgb(255 255 255)">rmationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let </text><text x="378" y="2020"  fill="rgb(237 28 36)">applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)</text><text x="744" y="2020"  fill="rgb(255 255 255)">) { throw new InsightError(); } le</text><text x="846" y="2020"  fill="rgb(24 158 180)">t key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(a</text><text x="1233" y="2020"  fill="rgb(255 255 255)">pplytoken)) { if</text><text x="1281" y="2020"  fill="rgb(24 158 180)"> (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new Ins</text><text x="1533" y="2020"  fill="rgb(255 255 255)">ightError(); } } els</text><text x="1593" y="2020"  fill="rgb(24 158 180)">e if (this.mstoken.includes(applytoken)) { if </text><text x="1731" y="2020"  fill="rgb(255 255 255)">(!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[</text><text x="1920" y="2020"  fill="rgb(237 28 36)">1]) || this.mfields.includes(key[1]))))</text><text x="2037" y="2020"  fill="rgb(255 255 255)"> { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS</text><text x="0" y="2025"  fill="rgb(255 255 255)">&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORD</text><text x="378" y="2025"  fill="rgb(237 28 36)">ER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q</text><text x="744" y="2025"  fill="rgb(255 255 255)">) { if (this.transformationKey.len</text><text x="846" y="2025"  fill="rgb(24 158 180)">gth &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.ke</text><text x="1233" y="2025"  fill="rgb(255 255 255)">ysInQuery.push(m</text><text x="1281" y="2025"  fill="rgb(24 158 180)">skey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new I</text><text x="1533" y="2025"  fill="rgb(255 255 255)">nsightError(); } els</text><text x="1593" y="2025"  fill="rgb(24 158 180)">e if (typeof q === &quot;string&quot;) { if (!this.keysI</text><text x="1731" y="2025"  fill="rgb(255 255 255)">nQuery.includes(q)) { throw new InsightError(); } } else { if (</text><text x="1920" y="2025"  fill="rgb(237 28 36)">!q.dir || !q.keys || Object.keys(q).len</text><text x="2037" y="2025"  fill="rgb(255 255 255)">gth !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(</text><text x="0" y="2030"  fill="rgb(255 255 255)">keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { t</text><text x="378" y="2030"  fill="rgb(237 28 36)">hrow new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } </text><text x="744" y="2030"  fill="rgb(255 255 255)">else { if (Object.keys(q).length !</text><text x="846" y="2030"  fill="rgb(24 158 180)">== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightE</text><text x="1236" y="2030"  fill="rgb(255 255 255)">rror(); } else </text><text x="1281" y="2030"  fill="rgb(24 158 180)">{ let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch</text><text x="1530" y="2030"  fill="rgb(255 255 255)"> (key) { case &quot;AND&quot;:</text><text x="1590" y="2030"  fill="rgb(24 158 180)"> case &quot;OR&quot;: this.validateANDOR(value); break; c</text><text x="1731" y="2030"  fill="rgb(255 255 255)">ase &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT</text><text x="1917" y="2030"  fill="rgb(237 28 36)">&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value</text><text x="2034" y="2030"  fill="rgb(255 255 255)">); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;</text><text x="0" y="2035"  fill="rgb(255 255 255)">object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !=</text><text x="381" y="2035"  fill="rgb(237 28 36)">= &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: st</text><text x="744" y="2035"  fill="rgb(255 255 255)">ring[] = Object.keys(value)[0].spl</text><text x="846" y="2035"  fill="rgb(24 158 180)">it(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1];</text><text x="1236" y="2035"  fill="rgb(255 255 255)"> let str: any =</text><text x="1281" y="2035"  fill="rgb(24 158 180)"> Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); </text><text x="1530" y="2035"  fill="rgb(255 255 255)">} else { if ((str.sl</text><text x="1590" y="2035"  fill="rgb(24 158 180)">ice(1, -1).includes(&quot;*&quot;)) || !this.validateIds</text><text x="1728" y="2035"  fill="rgb(255 255 255)">tring(idstring) || !this.sfields.includes(sfield)) { throw new </text><text x="1917" y="2035"  fill="rgb(237 28 36)">InsightError(); } } } } private validat</text><text x="2034" y="2035"  fill="rgb(255 255 255)">eGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.key</text><text x="0" y="2040"  fill="rgb(255 255 255)">s(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield:</text><text x="381" y="2040"  fill="rgb(237 28 36)"> string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstri</text><text x="744" y="2040"  fill="rgb(255 255 255)">ng) || !this.mfields.includes(mfie</text><text x="846" y="2040"  fill="rgb(24 158 180)">ld)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { t</text><text x="1239" y="2040"  fill="rgb(255 255 255)">hrow new Insig</text><text x="1281" y="2040"  fill="rgb(24 158 180)">htError(); } for (let innerObject of value) { this.validateFilter(innerObject); } </text><text x="1527" y="2040"  fill="rgb(255 255 255)">} private validateId</text><text x="1587" y="2040"  fill="rgb(24 158 180)">string(idstring: string): boolean { if (this.id</text><text x="1728" y="2040"  fill="rgb(255 255 255)">InQuery.length === 0) { for (let insightDataset of this.allInsi</text><text x="1917" y="2040"  fill="rgb(237 28 36)">ghtDataset) { if (insightDataset.id ===</text><text x="2034" y="2040"  fill="rgb(255 255 255)"> idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = thi</text><text x="0" y="2045"  fill="rgb(255 255 255)">s.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } </text><text x="381" y="2045"  fill="rgb(237 28 36)">else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {</text><text x="747" y="2045"  fill="rgb(255 255 255)">InsightDataset, InsightDatasetKin</text><text x="846" y="2045"  fill="rgb(24 158 180)">d, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;</text><text x="1242" y="2045"  fill="rgb(255 255 255)">pass&quot;, &quot;fail&quot;</text><text x="1281" y="2045"  fill="rgb(24 158 180)">, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;ins</text><text x="1527" y="2045"  fill="rgb(255 255 255)">tructor&quot;, &quot;title&quot;, &quot;</text><text x="1587" y="2045"  fill="rgb(24 158 180)">uuid&quot;]; private readonly roommfields: string[] </text><text x="1728" y="2045"  fill="rgb(255 255 255)">= [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string</text><text x="1917" y="2045"  fill="rgb(237 28 36)">[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number</text><text x="2031" y="2045"  fill="rgb(255 255 255)">&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = </text><text x="0" y="2050"  fill="rgb(255 255 255)">[&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appear</text><text x="384" y="2050"  fill="rgb(237 28 36)">ed in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is </text><text x="747" y="2050"  fill="rgb(255 255 255)">a transformation private allInsig</text><text x="846" y="2050"  fill="rgb(24 158 180)">htDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { </text><text x="1242" y="2050"  fill="rgb(255 255 255)">this.idInQuery</text><text x="1284" y="2050"  fill="rgb(24 158 180)"> = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDatase</text><text x="1524" y="2050"  fill="rgb(255 255 255)">t = insightDatasets;</text><text x="1584" y="2050"  fill="rgb(24 158 180)"> } public validate(q: any): void { if (!q || !q.</text><text x="1728" y="2050"  fill="rgb(255 255 255)">WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key</text><text x="1917" y="2050"  fill="rgb(237 28 36)"> of Object.keys(q)) { if (key !== &quot;OPT</text><text x="2031" y="2050"  fill="rgb(255 255 255)">IONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTr</text><text x="0" y="2055"  fill="rgb(255 255 255)">ansformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof</text><text x="384" y="2055"  fill="rgb(237 28 36)"> q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } </text><text x="747" y="2055"  fill="rgb(255 255 255)">this.validateGROUP(q.GROUP); this</text><text x="846" y="2055"  fill="rgb(24 158 180)">.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); /</text><text x="1245" y="2055"  fill="rgb(255 255 255)">/ q should be</text><text x="1284" y="2055"  fill="rgb(24 158 180)"> an object, and should has at least one element } for (let key of q) { this.vali</text><text x="1524" y="2055"  fill="rgb(255 255 255)">dateKey(key); this.t</text><text x="1584" y="2055"  fill="rgb(24 158 180)">ransformationKey.push(key); // if the key is val</text><text x="1728" y="2055"  fill="rgb(255 255 255)">id, push it to transformationKey } } private validateKey(key: s</text><text x="1917" y="2055"  fill="rgb(237 28 36)">tring): void { let splittedKey: string</text><text x="2031" y="2055"  fill="rgb(255 255 255)">[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(split</text><text x="0" y="2060"  fill="rgb(255 255 255)">tedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if </text><text x="384" y="2060"  fill="rgb(237 28 36)">(!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let </text><text x="747" y="2060"  fill="rgb(255 255 255)">applyrule of q) { if (Array.isArr</text><text x="846" y="2060"  fill="rgb(24 158 180)">ay(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; l</text><text x="1245" y="2060"  fill="rgb(255 255 255)">et criteria </text><text x="1281" y="2060"  fill="rgb(24 158 180)">= applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || thi</text><text x="1524" y="2060"  fill="rgb(255 255 255)">s.transformationKey</text><text x="1581" y="2060"  fill="rgb(24 158 180)">.includes(applykey)) { throw new InsightError(); </text><text x="1728" y="2060"  fill="rgb(255 255 255)">} this.transformationKey.push(applykey); if (Array.isArray(crit</text><text x="1917" y="2060"  fill="rgb(237 28 36)">eria) || Object.keys(criteria).length</text><text x="2028" y="2060"  fill="rgb(255 255 255)"> &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applyt</text><text x="0" y="2065"  fill="rgb(255 255 255)">oken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new Insig</text><text x="387" y="2065"  fill="rgb(237 28 36)">htError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]</text><text x="747" y="2065"  fill="rgb(255 255 255)">))) { throw new InsightError(); } </text><text x="849" y="2065"  fill="rgb(24 158 180)">} else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields</text><text x="1248" y="2065"  fill="rgb(255 255 255)">.includes(k</text><text x="1281" y="2065"  fill="rgb(24 158 180)">ey[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): vo</text><text x="1521" y="2065"  fill="rgb(255 255 255)">id { let keys: any[]</text><text x="1581" y="2065"  fill="rgb(24 158 180)"> = Object.keys(q); for (let key of keys) { if (ke</text><text x="1728" y="2065"  fill="rgb(255 255 255)">y !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError();</text><text x="1917" y="2065"  fill="rgb(237 28 36)"> } } this.validateColumns(q.COLUMNS);</text><text x="2028" y="2065"  fill="rgb(255 255 255)"> if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey</text><text x="0" y="2070"  fill="rgb(255 255 255)"> of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } el</text><text x="387" y="2070"  fill="rgb(237 28 36)">se { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray</text><text x="750" y="2070"  fill="rgb(255 255 255)">(q)) { throw new InsightError(); </text><text x="849" y="2070"  fill="rgb(24 158 180)">} else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys |</text><text x="1248" y="2070"  fill="rgb(255 255 255)">| Object.ke</text><text x="1281" y="2070"  fill="rgb(24 158 180)">ys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !=</text><text x="1521" y="2070"  fill="rgb(255 255 255)">= &quot;DOWN&quot;) { throw n</text><text x="1578" y="2070"  fill="rgb(24 158 180)">ew InsightError(); } let keys: any = q.keys; if (</text><text x="1725" y="2070"  fill="rgb(255 255 255)">!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightErro</text><text x="1917" y="2070"  fill="rgb(237 28 36)">r(); } for (let anykey of keys) { if </text><text x="2028" y="2070"  fill="rgb(255 255 255)">(!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(</text><text x="0" y="2075"  fill="rgb(255 255 255)">); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.key</text><text x="390" y="2075"  fill="rgb(237 28 36)">s(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.val</text><text x="750" y="2075"  fill="rgb(255 255 255)">ues(q)[0]; switch (key) { case &quot;A</text><text x="849" y="2075"  fill="rgb(24 158 180)">ND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.va</text><text x="1251" y="2075"  fill="rgb(255 255 255)">lidateGTLT</text><text x="1281" y="2075"  fill="rgb(24 158 180)">EQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new </text><text x="1518" y="2075"  fill="rgb(255 255 255)">InsightError(); } } </text><text x="1578" y="2075"  fill="rgb(24 158 180)">} private validateNOT(value: any): void { if (typ</text><text x="1725" y="2075"  fill="rgb(255 255 255)">eof value !== &quot;object&quot;) { throw new InsightError(); } this.valid</text><text x="1917" y="2075"  fill="rgb(237 28 36)">ateFilter(value); } private validateI</text><text x="2028" y="2075"  fill="rgb(255 255 255)">S(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let ske</text><text x="0" y="2080"  fill="rgb(255 255 255)">y: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string =</text><text x="390" y="2080"  fill="rgb(237 28 36)"> skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new</text><text x="750" y="2080"  fill="rgb(255 255 255)"> InsightError(); } else { if ((st</text><text x="849" y="2080"  fill="rgb(24 158 180)">r.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } }</text><text x="1251" y="2080"  fill="rgb(255 255 255)"> } private</text><text x="1281" y="2080"  fill="rgb(24 158 180)"> validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.key</text><text x="1518" y="2080"  fill="rgb(255 255 255)">s(value).length !==</text><text x="1575" y="2080"  fill="rgb(24 158 180)"> 1) { throw new InsightError(); } let mkey: string</text><text x="1725" y="2080"  fill="rgb(255 255 255)">[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { </text><text x="1917" y="2080"  fill="rgb(237 28 36)">throw new InsightError(); } else { l</text><text x="2025" y="2080"  fill="rgb(255 255 255)">et idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(i</text><text x="0" y="2085"  fill="rgb(255 255 255)">dstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array</text><text x="390" y="2085"  fill="rgb(237 28 36)">.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(</text><text x="750" y="2085"  fill="rgb(255 255 255)">innerObject); } } private validat</text><text x="849" y="2085"  fill="rgb(24 158 180)">eIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insi</text><text x="1254" y="2085"  fill="rgb(255 255 255)">ghtDatase</text><text x="1281" y="2085"  fill="rgb(24 158 180)">t.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind ==</text><text x="1515" y="2085"  fill="rgb(255 255 255)">= InsightDatasetKind</text><text x="1575" y="2085"  fill="rgb(24 158 180)">.Courses) { this.mfields = this.coursemfields; thi</text><text x="1725" y="2085"  fill="rgb(255 255 255)">s.sfields = this.coursesfields; } else { this.mfields = this.roo</text><text x="1917" y="2085"  fill="rgb(237 28 36)">mmfields; this.sfields = this.roomsf</text><text x="2025" y="2085"  fill="rgb(255 255 255)">ields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } im</text><text x="0" y="2090"  fill="rgb(255 255 255)">port {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private read</text><text x="393" y="2090"  fill="rgb(237 28 36)">only coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;de</text><text x="753" y="2090"  fill="rgb(255 255 255)">pt&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;</text><text x="849" y="2090"  fill="rgb(24 158 180)">, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;sho</text><text x="1254" y="2090"  fill="rgb(255 255 255)">rtname&quot;,</text><text x="1278" y="2090"  fill="rgb(24 158 180)"> &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly </text><text x="1512" y="2090"  fill="rgb(255 255 255)">mtoken: string[] = [</text><text x="1572" y="2090"  fill="rgb(24 158 180)">&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstok</text><text x="1725" y="2090"  fill="rgb(255 255 255)">en: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make s</text><text x="1917" y="2090"  fill="rgb(237 28 36)">ure the query only has one id privat</text><text x="2025" y="2090"  fill="rgb(255 255 255)">e keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if the</text><text x="0" y="2095"  fill="rgb(255 255 255)">re is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; construct</text><text x="393" y="2095"  fill="rgb(237 28 36)">or(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.al</text><text x="753" y="2095"  fill="rgb(255 255 255)">lInsightDataset = insightDatasets</text><text x="852" y="2095"  fill="rgb(24 158 180)">; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { i</text><text x="1257" y="2095"  fill="rgb(255 255 255)">f (key </text><text x="1278" y="2095"  fill="rgb(24 158 180)">!== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new Ins</text><text x="1512" y="2095"  fill="rgb(255 255 255)">ightError(); } } thi</text><text x="1572" y="2095"  fill="rgb(24 158 180)">s.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { </text><text x="1725" y="2095"  fill="rgb(255 255 255)">this.validateTransformations(q.TRANSFORMATIONS); } this.validate</text><text x="1917" y="2095"  fill="rgb(237 28 36)">Options(q.OPTIONS); } public valida</text><text x="2022" y="2095"  fill="rgb(255 255 255)">teTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError</text><text x="0" y="2100"  fill="rgb(255 255 255)">(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.</text><text x="393" y="2100"  fill="rgb(237 28 36)">length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of </text><text x="753" y="2100"  fill="rgb(255 255 255)">q) { this.validateKey(key); this.</text><text x="852" y="2100"  fill="rgb(24 158 180)">transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let spli</text><text x="1257" y="2100"  fill="rgb(255 255 255)">ttedKey</text><text x="1278" y="2100"  fill="rgb(24 158 180)">: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new Insigh</text><text x="1509" y="2100"  fill="rgb(255 255 255)">tError(); } if (!(th</text><text x="1569" y="2100"  fill="rgb(24 158 180)">is.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfield</text><text x="1722" y="2100"  fill="rgb(255 255 255)">s.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1</text><text x="1917" y="2100"  fill="rgb(237 28 36)">])))) { throw new InsightError(); }</text><text x="2022" y="2100"  fill="rgb(255 255 255)"> } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for</text><text x="0" y="2105"  fill="rgb(255 255 255)"> (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applyke</text><text x="396" y="2105"  fill="rgb(237 28 36)">y: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includ</text><text x="753" y="2105"  fill="rgb(255 255 255)">es(&quot;_&quot;) || this.transformationKey</text><text x="852" y="2105"  fill="rgb(24 158 180)">.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(cri</text><text x="1260" y="2105"  fill="rgb(255 255 255)">teria)</text><text x="1278" y="2105"  fill="rgb(24 158 180)">.length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.ke</text><text x="1509" y="2105"  fill="rgb(255 255 255)">ys(criteria)[0]; if</text><text x="1566" y="2105"  fill="rgb(24 158 180)"> (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken</text><text x="1722" y="2105"  fill="rgb(255 255 255)">.includes(applytoken)) { throw new InsightError(); } let key: str</text><text x="1917" y="2105"  fill="rgb(237 28 36)">ing[] = criteria[applytoken].split(</text><text x="2022" y="2105"  fill="rgb(255 255 255)">&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(</text><text x="0" y="2110"  fill="rgb(255 255 255)">key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this</text><text x="396" y="2110"  fill="rgb(237 28 36)">.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOption</text><text x="753" y="2110"  fill="rgb(255 255 255)">s(q: any): void { let keys: any[]</text><text x="852" y="2110"  fill="rgb(24 158 180)"> = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumn</text><text x="1260" y="2110"  fill="rgb(255 255 255)">s(q.C</text><text x="1275" y="2110"  fill="rgb(24 158 180)">OLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColu</text><text x="1506" y="2110"  fill="rgb(255 255 255)">mns(q: any): void { </text><text x="1566" y="2110"  fill="rgb(24 158 180)">if (!q || q.length &lt; 1) { throw new InsightError(); </text><text x="1722" y="2110"  fill="rgb(255 255 255)">} for (let mskey of q) { if (this.transformationKey.length &gt; 0) {</text><text x="1917" y="2110"  fill="rgb(237 28 36)"> if (!this.transformationKey.inclu</text><text x="2019" y="2110"  fill="rgb(255 255 255)">des(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.</text><text x="0" y="2115"  fill="rgb(255 255 255)">isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightErr</text><text x="399" y="2115"  fill="rgb(237 28 36)">or(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot;</text><text x="756" y="2115"  fill="rgb(255 255 255)"> &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw ne</text><text x="852" y="2115"  fill="rgb(24 158 180)">w InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey o</text><text x="1260" y="2115"  fill="rgb(255 255 255)">f key</text><text x="1275" y="2115"  fill="rgb(24 158 180)">s) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } }</text><text x="1503" y="2115"  fill="rgb(255 255 255)"> } } public validate</text><text x="1563" y="2115"  fill="rgb(24 158 180)">Where(q: any): void { if (Array.isArray(q)) { throw n</text><text x="1722" y="2115"  fill="rgb(255 255 255)">ew InsightError(); } else { if (Object.keys(q).length !== 0) { th</text><text x="1917" y="2115"  fill="rgb(237 28 36)">is.validateFilter(q); } } } privat</text><text x="2019" y="2115"  fill="rgb(255 255 255)">e validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Obj</text><text x="0" y="2120"  fill="rgb(255 255 255)">ect.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break;</text><text x="399" y="2120"  fill="rgb(237 28 36)"> case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default:</text><text x="756" y="2120"  fill="rgb(255 255 255)"> throw new InsightError(); } } } </text><text x="855" y="2120"  fill="rgb(24 158 180)">private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } priva</text><text x="1263" y="2120"  fill="rgb(255 255 255)">te </text><text x="1272" y="2120"  fill="rgb(24 158 180)">validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new In</text><text x="1500" y="2120"  fill="rgb(255 255 255)">sightError(); } if (</text><text x="1560" y="2120"  fill="rgb(24 158 180)">Object.keys(value).length !== 1) { throw new InsightE</text><text x="1719" y="2120"  fill="rgb(255 255 255)">rror(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); i</text><text x="1917" y="2120"  fill="rgb(237 28 36)">f (skey.length !== 2) { throw new </text><text x="2019" y="2120"  fill="rgb(255 255 255)">InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { th</text><text x="0" y="2125"  fill="rgb(255 255 255)">row new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sf</text><text x="402" y="2125"  fill="rgb(237 28 36)">ield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; ||</text><text x="756" y="2125"  fill="rgb(255 255 255)"> Object.keys(value).length !== 1)</text><text x="855" y="2125"  fill="rgb(24 158 180)"> { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError();</text><text x="1263" y="2125"  fill="rgb(255 255 255)"> } </text><text x="1272" y="2125"  fill="rgb(24 158 180)">else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num</text><text x="1500" y="2125"  fill="rgb(255 255 255)">: any = Object.value</text><text x="1560" y="2125"  fill="rgb(24 158 180)">s(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.v</text><text x="1719" y="2125"  fill="rgb(255 255 255)">alidateIdstring(idstring) || !this.mfields.includes(mfield)) { thr</text><text x="1917" y="2125"  fill="rgb(237 28 36)">ow new InsightError(); } } } priv</text><text x="2016" y="2125"  fill="rgb(255 255 255)">ate validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validate</text><text x="0" y="2130"  fill="rgb(255 255 255)">Filter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightData</text><text x="402" y="2130"  fill="rgb(237 28 36)">set of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDatas</text><text x="756" y="2130"  fill="rgb(255 255 255)">et.kind === InsightDatasetKind.Co</text><text x="855" y="2130"  fill="rgb(24 158 180)">urses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = t</text><text x="1266" y="2130"  fill="rgb(255 255 255)">h</text><text x="1269" y="2130"  fill="rgb(24 158 180)">is.roomsfields; } return true; } } return false; } else { return this.idInQu</text><text x="1497" y="2130"  fill="rgb(255 255 255)">ery.includes(idstrin</text><text x="1557" y="2130"  fill="rgb(24 158 180)">g); } } public getIdInQuery(): string[] { return this.</text><text x="1719" y="2130"  fill="rgb(255 255 255)">idInQuery; } } import {InsightDataset, InsightDatasetKind, Insigh</text><text x="1914" y="2130"  fill="rgb(237 28 36)">tError} from &quot;./IInsightFacade&quot;; e</text><text x="2016" y="2130"  fill="rgb(255 255 255)">xport default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[</text><text x="0" y="2135"  fill="rgb(255 255 255)">] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly </text><text x="402" y="2135"  fill="rgb(237 28 36)">roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private r</text><text x="759" y="2135"  fill="rgb(255 255 255)">eadonly mtoken: string[] = [&quot;MAX</text><text x="855" y="2135"  fill="rgb(24 158 180)">&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one</text><text x="1266" y="2135"  fill="rgb(255 255 255)"> </text><text x="1269" y="2135"  fill="rgb(24 158 180)">id private keysInQuery: string[]; // all keys appeared in columns after bei</text><text x="1494" y="2135"  fill="rgb(255 255 255)">ng validated private</text><text x="1554" y="2135"  fill="rgb(24 158 180)"> transformationKey: string[]; // keys appeared in trans</text><text x="1719" y="2135"  fill="rgb(255 255 255)">formation, if there is a transformation p</text><text x="1842" y="2135"  fill="rgb(237 28 36)">r</text><text x="1845" y="2135"  fill="rgb(255 255 255)">ivate allInsightDataset</text><text x="1914" y="2135"  fill="rgb(237 28 36)">: InsightDataset[]; private mfield</text><text x="2016" y="2135"  fill="rgb(255 255 255)">s: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = [];</text><text x="0" y="2140"  fill="rgb(255 255 255)"> this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError</text><text x="405" y="2140"  fill="rgb(237 28 36)">(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw</text><text x="759" y="2140"  fill="rgb(255 255 255)"> new InsightError(); } } this.val</text><text x="858" y="2140"  fill="rgb(24 158 180)">idateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefine</text><text x="1491" y="2140"  fill="rgb(255 255 255)">d&quot; || typeof q.APPLY </text><text x="1554" y="2140"  fill="rgb(24 158 180)">=== &quot;undefined&quot; || Object.keys(q).length !== 2) { thro</text><text x="1716" y="2140"  fill="rgb(255 255 255)">w new InsightError(); } this.validateGROU</text><text x="1839" y="2140"  fill="rgb(237 28 36)">P(</text><text x="1845" y="2140"  fill="rgb(255 255 255)">q.GROUP); this.validate</text><text x="1914" y="2140"  fill="rgb(237 28 36)">APPLY(q.APPLY); } private validat</text><text x="2013" y="2140"  fill="rgb(255 255 255)">eGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let</text><text x="0" y="2145"  fill="rgb(255 255 255)"> key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private </text><text x="405" y="2145"  fill="rgb(237 28 36)">validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new</text><text x="759" y="2145"  fill="rgb(255 255 255)"> InsightError(); } if (!(this.val</text><text x="858" y="2145"  fill="rgb(24 158 180)">idateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) {</text><text x="1488" y="2145"  fill="rgb(255 255 255)"> throw new InsightErr</text><text x="1551" y="2145"  fill="rgb(24 158 180)">or(); // q should be an array, and should have at least</text><text x="1716" y="2145"  fill="rgb(255 255 255)"> one element } for (let applyrule of q) </text><text x="1836" y="2145"  fill="rgb(237 28 36)">{ i</text><text x="1845" y="2145"  fill="rgb(255 255 255)">f (Array.isArray(applyr</text><text x="1914" y="2145"  fill="rgb(237 28 36)">ule) || Object.keys(applyrule).le</text><text x="2013" y="2145"  fill="rgb(255 255 255)">ngth &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applyke</text><text x="0" y="2150"  fill="rgb(255 255 255)">y.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (A</text><text x="408" y="2150"  fill="rgb(237 28 36)">rray.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Ob</text><text x="759" y="2150"  fill="rgb(255 255 255)">ject.keys(criteria)[0]; if (!this</text><text x="858" y="2150"  fill="rgb(24 158 180)">.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (thi</text><text x="1488" y="2150"  fill="rgb(255 255 255)">s.mtoken.includes(ap</text><text x="1548" y="2150"  fill="rgb(24 158 180)">plytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this</text><text x="1716" y="2150"  fill="rgb(255 255 255)">.mfields.includes(key[1]))) { throw new </text><text x="1836" y="2150"  fill="rgb(237 28 36)">Ins</text><text x="1845" y="2150"  fill="rgb(255 255 255)">ightError(); } } else i</text><text x="1914" y="2150"  fill="rgb(237 28 36)">f (this.mstoken.includes(applytok</text><text x="2013" y="2150"  fill="rgb(255 255 255)">en)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public valida</text><text x="0" y="2155"  fill="rgb(255 255 255)">teOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw ne</text><text x="408" y="2155"  fill="rgb(237 28 36)">w InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validat</text><text x="762" y="2155"  fill="rgb(255 255 255)">eColumns(q: any): void { if (!q </text><text x="858" y="2155"  fill="rgb(24 158 180)">|| q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateK</text><text x="1485" y="2155"  fill="rgb(255 255 255)">ey(mskey); } this.ke</text><text x="1545" y="2155"  fill="rgb(24 158 180)">ysInQuery.push(mskey); } } private validateOrder(q: any):</text><text x="1716" y="2155"  fill="rgb(255 255 255)"> void { if (Array.isArray(q)) { throw n</text><text x="1833" y="2155"  fill="rgb(237 28 36)">ew I</text><text x="1845" y="2155"  fill="rgb(255 255 255)">nsightError(); } else i</text><text x="1914" y="2155"  fill="rgb(237 28 36)">f (typeof q === &quot;string&quot;) { if (</text><text x="2010" y="2155"  fill="rgb(255 255 255)">!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir</text><text x="0" y="2160"  fill="rgb(255 255 255)"> !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw</text><text x="411" y="2160"  fill="rgb(237 28 36)"> new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError();</text><text x="762" y="2160"  fill="rgb(255 255 255)"> } } } } public validateWhere(q: </text><text x="861" y="2160"  fill="rgb(24 158 180)">any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1</text><text x="1482" y="2160"  fill="rgb(255 255 255)">) { throw new Insight</text><text x="1545" y="2160"  fill="rgb(24 158 180)">Error(); } else { let key: string = Object.keys(q)[0]; l</text><text x="1713" y="2160"  fill="rgb(255 255 255)">et value: any = Object.values(q)[0]; swi</text><text x="1833" y="2160"  fill="rgb(237 28 36)">tch </text><text x="1845" y="2160"  fill="rgb(255 255 255)">(key) { case &quot;AND&quot;: cas</text><text x="1914" y="2160"  fill="rgb(237 28 36)">e &quot;OR&quot;: this.validateANDOR(value</text><text x="2010" y="2160"  fill="rgb(255 255 255)">); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break;</text><text x="0" y="2165"  fill="rgb(255 255 255)"> default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError</text><text x="411" y="2165"  fill="rgb(237 28 36)">(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new</text><text x="762" y="2165"  fill="rgb(255 255 255)"> InsightError(); } if (Object.key</text><text x="861" y="2165"  fill="rgb(24 158 180)">s(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sf</text><text x="1479" y="2165"  fill="rgb(255 255 255)">ield: string = skey[1</text><text x="1542" y="2165"  fill="rgb(24 158 180)">]; let str: any = Object.values(value)[0]; if (typeof str</text><text x="1713" y="2165"  fill="rgb(255 255 255)"> !== &quot;string&quot;) { throw new InsightError</text><text x="1830" y="2165"  fill="rgb(237 28 36)">(); }</text><text x="1845" y="2165"  fill="rgb(255 255 255)"> else { if ((str.slice(</text><text x="1914" y="2165"  fill="rgb(237 28 36)">1, -1).includes(&quot;*&quot;)) || !this.v</text><text x="2010" y="2165"  fill="rgb(255 255 255)">alidateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;o</text><text x="0" y="2170"  fill="rgb(255 255 255)">bject&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.l</text><text x="414" y="2170"  fill="rgb(237 28 36)">ength !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let n</text><text x="765" y="2170"  fill="rgb(255 255 255)">um: any = Object.values(value)[0</text><text x="861" y="2170"  fill="rgb(24 158 180)">]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value)</text><text x="1476" y="2170"  fill="rgb(255 255 255)"> || value.length &lt; 1)</text><text x="1539" y="2170"  fill="rgb(24 158 180)"> { throw new InsightError(); } for (let innerObject of val</text><text x="1713" y="2170"  fill="rgb(255 255 255)">ue) { this.validateFilter(innerObject)</text><text x="1827" y="2170"  fill="rgb(237 28 36)">; } } </text><text x="1845" y="2170"  fill="rgb(255 255 255)">private validateIdstrin</text><text x="1914" y="2170"  fill="rgb(237 28 36)">g(idstring: string): boolean { </text><text x="2007" y="2170"  fill="rgb(255 255 255)">if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (ins</text><text x="0" y="2175"  fill="rgb(255 255 255)">ightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfi</text><text x="414" y="2175"  fill="rgb(237 28 36)">elds = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQ</text><text x="765" y="2175"  fill="rgb(255 255 255)">uery.includes(idstring); } } publ</text><text x="864" y="2175"  fill="rgb(24 158 180)">ic getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemf</text><text x="1473" y="2175"  fill="rgb(255 255 255)">ields: string[] = [&quot;a</text><text x="1536" y="2175"  fill="rgb(24 158 180)">vg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly co</text><text x="1710" y="2175"  fill="rgb(255 255 255)">ursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, </text><text x="1827" y="2175"  fill="rgb(237 28 36)">&quot;instr</text><text x="1845" y="2175"  fill="rgb(255 255 255)">uctor&quot;, &quot;title&quot;, &quot;uuid&quot;</text><text x="1914" y="2175"  fill="rgb(237 28 36)">]; private readonly roommfields</text><text x="2007" y="2175"  fill="rgb(255 255 255)">: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;];</text><text x="0" y="2180"  fill="rgb(255 255 255)"> private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: strin</text><text x="417" y="2180"  fill="rgb(237 28 36)">g[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after bei</text><text x="765" y="2180"  fill="rgb(255 255 255)">ng validated private transformati</text><text x="864" y="2180"  fill="rgb(24 158 180)">onKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDa</text><text x="1470" y="2180"  fill="rgb(255 255 255)">tasets: InsightDatase</text><text x="1533" y="2180"  fill="rgb(24 158 180)">t[]) { this.idInQuery = []; this.keysInQuery = []; this.tra</text><text x="1710" y="2180"  fill="rgb(255 255 255)">nsformationKey = []; this.allInsightDa</text><text x="1824" y="2180"  fill="rgb(237 28 36)">taset =</text><text x="1845" y="2180"  fill="rgb(255 255 255)"> insightDatasets; } pub</text><text x="1914" y="2180"  fill="rgb(237 28 36)">lic validate(q: any): void { if</text><text x="2007" y="2180"  fill="rgb(255 255 255)"> (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS</text><text x="0" y="2185"  fill="rgb(255 255 255)">&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); }</text><text x="417" y="2185"  fill="rgb(237 28 36)"> this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined</text><text x="765" y="2185"  fill="rgb(255 255 255)">&quot; || typeof q.APPLY === &quot;undefine</text><text x="864" y="2185"  fill="rgb(24 158 180)">d&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1</text><text x="1464" y="2185"  fill="rgb(255 255 255)">) { throw new InsightEr</text><text x="1533" y="2185"  fill="rgb(24 158 180)">ror(); // q should be an object, and should has at least on</text><text x="1710" y="2185"  fill="rgb(255 255 255)">e element } for (let key of q) { this</text><text x="1821" y="2185"  fill="rgb(237 28 36)">.validat</text><text x="1845" y="2185"  fill="rgb(255 255 255)">eKey(key); this.transf</text><text x="1911" y="2185"  fill="rgb(237 28 36)">ormationKey.push(key); // if th</text><text x="2004" y="2185"  fill="rgb(255 255 255)">e key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) {</text><text x="0" y="2190"  fill="rgb(255 255 255)"> throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(</text><text x="420" y="2190"  fill="rgb(237 28 36)">splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { th</text><text x="768" y="2190"  fill="rgb(255 255 255)">row new InsightError(); // q shou</text><text x="867" y="2190"  fill="rgb(24 158 180)">ld be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: strin</text><text x="1461" y="2190"  fill="rgb(255 255 255)">g = Object.keys(applyru</text><text x="1530" y="2190"  fill="rgb(24 158 180)">le)[0]; let criteria = applyrule[applykey]; if (applykey.le</text><text x="1707" y="2190"  fill="rgb(255 255 255)">ngth === 0 || applykey.includes(&quot;_&quot;) |</text><text x="1821" y="2190"  fill="rgb(237 28 36)">| this.t</text><text x="1845" y="2190"  fill="rgb(255 255 255)">ransformationKey.inclu</text><text x="1911" y="2190"  fill="rgb(237 28 36)">des(applykey)) { throw new Insi</text><text x="2004" y="2190"  fill="rgb(255 255 255)">ghtError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: s</text><text x="0" y="2195"  fill="rgb(255 255 255)">tring = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); }</text><text x="420" y="2195"  fill="rgb(237 28 36)"> let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.m</text><text x="768" y="2195"  fill="rgb(255 255 255)">token.includes(applytoken)) { if </text><text x="867" y="2195"  fill="rgb(24 158 180)">(!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfield</text><text x="1458" y="2195"  fill="rgb(255 255 255)">s.includes(key[1]) || t</text><text x="1527" y="2195"  fill="rgb(24 158 180)">his.mfields.includes(key[1])))) { throw new InsightError(); </text><text x="1707" y="2195"  fill="rgb(255 255 255)">} } } } public validateOptions(q: any</text><text x="1818" y="2195"  fill="rgb(237 28 36)">): void {</text><text x="1845" y="2195"  fill="rgb(255 255 255)"> let keys: any[] = Obj</text><text x="1911" y="2195"  fill="rgb(237 28 36)">ect.keys(q); for (let key of ke</text><text x="2004" y="2195"  fill="rgb(255 255 255)">ys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } priv</text><text x="0" y="2200"  fill="rgb(255 255 255)">ate validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.l</text><text x="423" y="2200"  fill="rgb(237 28 36)">ength &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(m</text><text x="768" y="2200"  fill="rgb(255 255 255)">skey); } this.keysInQuery.push(ms</text><text x="867" y="2200"  fill="rgb(24 158 180)">key); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError();</text><text x="1455" y="2200"  fill="rgb(255 255 255)"> } } else { if (!q.dir </text><text x="1524" y="2200"  fill="rgb(24 158 180)">|| !q.keys || Object.keys(q).length !== 2) { throw new Insigh</text><text x="1707" y="2200"  fill="rgb(255 255 255)">tError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.d</text><text x="1818" y="2200"  fill="rgb(237 28 36)">ir !== &quot;D</text><text x="1845" y="2200"  fill="rgb(255 255 255)">OWN&quot;) { throw new Insi</text><text x="1911" y="2200"  fill="rgb(237 28 36)">ghtError(); } let keys: any = </text><text x="2001" y="2200"  fill="rgb(255 255 255)">q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new Insi</text><text x="0" y="2205"  fill="rgb(255 255 255)">ghtError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length</text><text x="423" y="2205"  fill="rgb(237 28 36)"> !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { th</text><text x="771" y="2205"  fill="rgb(255 255 255)">row new InsightError(); } else { </text><text x="870" y="2205"  fill="rgb(24 158 180)">let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; ca</text><text x="1449" y="2205"  fill="rgb(255 255 255)">se &quot;GT&quot;: case &quot;LT&quot;: case</text><text x="1521" y="2205"  fill="rgb(24 158 180)"> &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.val</text><text x="1704" y="2205"  fill="rgb(255 255 255)">idateIS(value); break; default: throw</text><text x="1815" y="2205"  fill="rgb(237 28 36)"> new Insig</text><text x="1845" y="2205"  fill="rgb(255 255 255)">htError(); } } } priva</text><text x="1911" y="2205"  fill="rgb(237 28 36)">te validateNOT(value: any): vo</text><text x="2001" y="2205"  fill="rgb(255 255 255)">id { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) </text><text x="0" y="2210"  fill="rgb(255 255 255)">{ throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].sp</text><text x="426" y="2210"  fill="rgb(237 28 36)">lit(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: s</text><text x="771" y="2210"  fill="rgb(255 255 255)">tring = skey[1]; let str: any = O</text><text x="870" y="2210"  fill="rgb(24 158 180)">bject.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfi</text><text x="1446" y="2210"  fill="rgb(255 255 255)">eld)) { throw new Insigh</text><text x="1518" y="2210"  fill="rgb(24 158 180)">tError(); } } } } private validateGTLTEQ(value: any): void { i</text><text x="1704" y="2210"  fill="rgb(255 255 255)">f (typeof value !== &quot;object&quot; || Obje</text><text x="1812" y="2210"  fill="rgb(237 28 36)">ct.keys(val</text><text x="1845" y="2210"  fill="rgb(255 255 255)">ue).length !== 1) { th</text><text x="1911" y="2210"  fill="rgb(237 28 36)">row new InsightError(); } let</text><text x="1998" y="2210"  fill="rgb(255 255 255)"> mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mk</text><text x="0" y="2215"  fill="rgb(255 255 255)">ey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfi</text><text x="426" y="2215"  fill="rgb(237 28 36)">eld)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || valu</text><text x="771" y="2215"  fill="rgb(255 255 255)">e.length &lt; 1) { throw new Insight</text><text x="870" y="2215"  fill="rgb(24 158 180)">Error(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDat</text><text x="1440" y="2215"  fill="rgb(255 255 255)">aset of this.allInsightDa</text><text x="1515" y="2215"  fill="rgb(24 158 180)">taset) { if (insightDataset.id === idstring) { this.idInQuery.p</text><text x="1704" y="2215"  fill="rgb(255 255 255)">ush(idstring); if (insightDataset.ki</text><text x="1812" y="2215"  fill="rgb(237 28 36)">nd === Ins</text><text x="1842" y="2215"  fill="rgb(255 255 255)">ightDatasetKind.Courses</text><text x="1911" y="2215"  fill="rgb(237 28 36)">) { this.mfields = this.cours</text><text x="1998" y="2215"  fill="rgb(255 255 255)">emfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { retur</text><text x="0" y="2220"  fill="rgb(255 255 255)">n this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKin</text><text x="429" y="2220"  fill="rgb(237 28 36)">d, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: str</text><text x="774" y="2220"  fill="rgb(255 255 255)">ing[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;</text><text x="873" y="2220"  fill="rgb(24 158 180)">audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonl</text><text x="1437" y="2220"  fill="rgb(255 255 255)">y roomsfields: string[] =</text><text x="1512" y="2220"  fill="rgb(24 158 180)"> [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;</text><text x="1701" y="2220"  fill="rgb(255 255 255)">, &quot;furniture&quot;, &quot;href&quot;]; private read</text><text x="1809" y="2220"  fill="rgb(237 28 36)">only mtoken</text><text x="1842" y="2220"  fill="rgb(255 255 255)">: string[] = [&quot;MAX&quot;, &quot;M</text><text x="1911" y="2220"  fill="rgb(237 28 36)">IN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private r</text><text x="1998" y="2220"  fill="rgb(255 255 255)">eadonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in colum</text><text x="0" y="2225"  fill="rgb(255 255 255)">ns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsigh</text><text x="432" y="2225"  fill="rgb(237 28 36)">tDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: Ins</text><text x="774" y="2225"  fill="rgb(255 255 255)">ightDataset[]) { this.idInQuery =</text><text x="873" y="2225"  fill="rgb(24 158 180)"> []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new Insight</text><text x="1431" y="2225"  fill="rgb(255 255 255)">Error(); } for (let key of</text><text x="1509" y="2225"  fill="rgb(24 158 180)"> Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; k</text><text x="1701" y="2225"  fill="rgb(255 255 255)">ey !== &quot;TRANSFORMATIONS&quot;) { throw n</text><text x="1806" y="2225"  fill="rgb(237 28 36)">ew InsightEr</text><text x="1842" y="2225"  fill="rgb(255 255 255)">ror(); } } this.validat</text><text x="1911" y="2225"  fill="rgb(237 28 36)">eWhere(q.WHERE); if (q.TRANS</text><text x="1995" y="2225"  fill="rgb(255 255 255)">FORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP ==</text><text x="0" y="2230"  fill="rgb(255 255 255)">= &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.</text><text x="432" y="2230"  fill="rgb(237 28 36)">validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new</text><text x="774" y="2230"  fill="rgb(255 255 255)"> InsightError(); // q should be a</text><text x="873" y="2230"  fill="rgb(24 158 180)">n object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } p</text><text x="1425" y="2230"  fill="rgb(255 255 255)">rivate validateKey(key: str</text><text x="1506" y="2230"  fill="rgb(24 158 180)">ing): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (spl</text><text x="1698" y="2230"  fill="rgb(255 255 255)">ittedKey.length !== 2) { throw new I</text><text x="1806" y="2230"  fill="rgb(237 28 36)">nsightError(</text><text x="1842" y="2230"  fill="rgb(255 255 255)">); } if (!(this.valida</text><text x="1908" y="2230"  fill="rgb(237 28 36)">teIdstring(splittedKey[0]) &amp;&amp;</text><text x="1995" y="2230"  fill="rgb(255 255 255)"> (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isA</text><text x="0" y="2235"  fill="rgb(255 255 255)">rray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray</text><text x="435" y="2235"  fill="rgb(237 28 36)">(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys</text><text x="777" y="2235"  fill="rgb(255 255 255)">(applyrule)[0]; let criteria = ap</text><text x="876" y="2235"  fill="rgb(24 158 180)">plyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applyk</text><text x="1419" y="2235"  fill="rgb(255 255 255)">ey); if (Array.isArray(crite</text><text x="1503" y="2235"  fill="rgb(24 158 180)">ria) || Object.keys(criteria).length &gt; 1) { throw new InsightErro</text><text x="1698" y="2235"  fill="rgb(255 255 255)">r(); } let applytoken: string = Obj</text><text x="1803" y="2235"  fill="rgb(237 28 36)">ect.keys(crit</text><text x="1842" y="2235"  fill="rgb(255 255 255)">eria)[0]; if (!this.mt</text><text x="1908" y="2235"  fill="rgb(237 28 36)">oken.includes(applytoken) &amp;&amp; </text><text x="1995" y="2235"  fill="rgb(255 255 255)">!this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError();</text><text x="0" y="2240"  fill="rgb(255 255 255)"> } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } }</text><text x="435" y="2240"  fill="rgb(237 28 36)"> else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1</text><text x="777" y="2240"  fill="rgb(255 255 255)">]) || this.mfields.includes(key[1</text><text x="876" y="2240"  fill="rgb(24 158 180)">])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;</text><text x="1413" y="2240"  fill="rgb(255 255 255)">) { throw new InsightError();</text><text x="1500" y="2240"  fill="rgb(24 158 180)"> } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validate</text><text x="1698" y="2240"  fill="rgb(255 255 255)">Order(q.ORDER); } } private valida</text><text x="1800" y="2240"  fill="rgb(237 28 36)">teColumns(q: a</text><text x="1842" y="2240"  fill="rgb(255 255 255)">ny): void { if (!q || </text><text x="1908" y="2240"  fill="rgb(237 28 36)">q.length &lt; 1) { throw new In</text><text x="1992" y="2240"  fill="rgb(255 255 255)">sightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.</text><text x="0" y="2245"  fill="rgb(255 255 255)">validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } </text><text x="438" y="2245"  fill="rgb(237 28 36)">else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!</text><text x="777" y="2245"  fill="rgb(255 255 255)">q.dir || !q.keys || Object.keys(q)</text><text x="879" y="2245"  fill="rgb(24 158 180)">.length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.leng</text><text x="1407" y="2245"  fill="rgb(255 255 255)">th &lt; 1) { throw new InsightErr</text><text x="1497" y="2245"  fill="rgb(24 158 180)">or(); } for (let anykey of keys) { if (!this.keysInQuery.includes(</text><text x="1695" y="2245"  fill="rgb(255 255 255)">anykey)) { throw new InsightError()</text><text x="1800" y="2245"  fill="rgb(237 28 36)">; } } } } publ</text><text x="1842" y="2245"  fill="rgb(255 255 255)">ic validateWhere(q: an</text><text x="1908" y="2245"  fill="rgb(237 28 36)">y): void { if (Array.isArray</text><text x="1992" y="2245"  fill="rgb(255 255 255)">(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).leng</text><text x="0" y="2250"  fill="rgb(255 255 255)">th !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND</text><text x="438" y="2250"  fill="rgb(237 28 36)">&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: </text><text x="780" y="2250"  fill="rgb(255 255 255)">case &quot;EQ&quot;: this.validateGTLTEQ(va</text><text x="879" y="2250"  fill="rgb(24 158 180)">lue); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw</text><text x="1401" y="2250"  fill="rgb(255 255 255)"> new InsightError(); } this.va</text><text x="1491" y="2250"  fill="rgb(24 158 180)">lidateFilter(value); } private validateIS(value: any): void { if (ty</text><text x="1695" y="2250"  fill="rgb(255 255 255)">peof value !== &quot;object&quot;) { throw n</text><text x="1797" y="2250"  fill="rgb(237 28 36)">ew InsightError</text><text x="1842" y="2250"  fill="rgb(255 255 255)">(); } if (Object.keys(</text><text x="1908" y="2250"  fill="rgb(237 28 36)">value).length !== 1) { thro</text><text x="1989" y="2250"  fill="rgb(255 255 255)">w new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0];</text><text x="0" y="2255"  fill="rgb(255 255 255)"> let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.s</text><text x="441" y="2255"  fill="rgb(237 28 36)">lice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new Ins</text><text x="780" y="2255"  fill="rgb(255 255 255)">ightError(); } } } } private valid</text><text x="882" y="2255"  fill="rgb(24 158 180)">ateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].sp</text><text x="1395" y="2255"  fill="rgb(255 255 255)">lit(&quot;_&quot;); if (mkey.length !== 2</text><text x="1488" y="2255"  fill="rgb(24 158 180)">) { throw new InsightError(); } else { let idstring: string = mkey[0</text><text x="1692" y="2255"  fill="rgb(255 255 255)">]; let mfield: string = mkey[1]; l</text><text x="1794" y="2255"  fill="rgb(237 28 36)">et num: any = Ob</text><text x="1842" y="2255"  fill="rgb(255 255 255)">ject.values(value)[0];</text><text x="1908" y="2255"  fill="rgb(237 28 36)"> if ((typeof num !== &quot;numbe</text><text x="1989" y="2255"  fill="rgb(255 255 255)">r&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(</text><text x="0" y="2260"  fill="rgb(255 255 255)">value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIds</text><text x="444" y="2260"  fill="rgb(237 28 36)">tring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsight</text><text x="780" y="2260"  fill="rgb(255 255 255)">Dataset) { if (insightDataset.id =</text><text x="882" y="2260"  fill="rgb(24 158 180)">== idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfi</text><text x="1386" y="2260"  fill="rgb(255 255 255)">elds; } else { this.mfields = thi</text><text x="1485" y="2260"  fill="rgb(24 158 180)">s.roommfields; this.sfields = this.roomsfields; } return true; } } re</text><text x="1692" y="2260"  fill="rgb(255 255 255)">turn false; } else { return this.</text><text x="1791" y="2260"  fill="rgb(237 28 36)">idInQuery.include</text><text x="1842" y="2260"  fill="rgb(255 255 255)">s(idstring); } } publi</text><text x="1908" y="2260"  fill="rgb(237 28 36)">c getIdInQuery(): string[] </text><text x="1989" y="2260"  fill="rgb(255 255 255)">{ return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly cou</text><text x="0" y="2265"  fill="rgb(255 255 255)">rsemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;u</text><text x="444" y="2265"  fill="rgb(237 28 36)">uid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] =</text><text x="783" y="2265"  fill="rgb(255 255 255)"> [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number</text><text x="885" y="2265"  fill="rgb(24 158 180)">&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]</text><text x="1380" y="2265"  fill="rgb(255 255 255)">; private idInQuery: string[]; // </text><text x="1482" y="2265"  fill="rgb(24 158 180)">make sure the query only has one id private keysInQuery: string[]; //</text><text x="1689" y="2265"  fill="rgb(255 255 255)"> all keys appeared in columns afte</text><text x="1791" y="2265"  fill="rgb(237 28 36)">r being validated</text><text x="1842" y="2265"  fill="rgb(255 255 255)"> private transformati</text><text x="1905" y="2265"  fill="rgb(237 28 36)">onKey: string[]; // keys ap</text><text x="1986" y="2265"  fill="rgb(255 255 255)">peared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insig</text><text x="0" y="2270"  fill="rgb(255 255 255)">htDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } </text><text x="447" y="2270"  fill="rgb(237 28 36)">public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of </text><text x="783" y="2270"  fill="rgb(255 255 255)">Object.keys(q)) { if (key !== &quot;OPT</text><text x="885" y="2270"  fill="rgb(24 158 180)">IONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransfor</text><text x="1371" y="2270"  fill="rgb(255 255 255)">mations(q.TRANSFORMATIONS); } this.v</text><text x="1479" y="2270"  fill="rgb(24 158 180)">alidateOptions(q.OPTIONS); } public validateTransformations(q: any): v</text><text x="1689" y="2270"  fill="rgb(255 255 255)">oid { if (typeof q.GROUP === &quot;und</text><text x="1788" y="2270"  fill="rgb(237 28 36)">efined&quot; || typeof</text><text x="1839" y="2270"  fill="rgb(255 255 255)"> q.APPLY === &quot;undefine</text><text x="1905" y="2270"  fill="rgb(237 28 36)">d&quot; || Object.keys(q).length</text><text x="1986" y="2270"  fill="rgb(255 255 255)"> !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt;</text><text x="0" y="2275"  fill="rgb(255 255 255)"> 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.tran</text><text x="447" y="2275"  fill="rgb(237 28 36)">sformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: strin</text><text x="783" y="2275"  fill="rgb(255 255 255)">g): void { let splittedKey: string</text><text x="885" y="2275"  fill="rgb(24 158 180)">[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splitted</text><text x="1362" y="2275"  fill="rgb(255 255 255)">Key[1]) || this.sfields.includes(spli</text><text x="1473" y="2275"  fill="rgb(24 158 180)">ttedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q:</text><text x="1686" y="2275"  fill="rgb(255 255 255)"> any): void { if (!Array.isArray(</text><text x="1785" y="2275"  fill="rgb(237 28 36)">q)) { throw new In</text><text x="1839" y="2275"  fill="rgb(255 255 255)">sightError(); // q sho</text><text x="1905" y="2275"  fill="rgb(237 28 36)">uld be an array, and shoul</text><text x="1983" y="2275"  fill="rgb(255 255 255)">d have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: stri</text><text x="0" y="2280"  fill="rgb(255 255 255)">ng = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.incl</text><text x="450" y="2280"  fill="rgb(237 28 36)">udes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria)</text><text x="786" y="2280"  fill="rgb(255 255 255)"> || Object.keys(criteria).length &gt;</text><text x="888" y="2280"  fill="rgb(24 158 180)"> 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applyt</text><text x="1353" y="2280"  fill="rgb(255 255 255)">oken)) { throw new InsightError(); } le</text><text x="1470" y="2280"  fill="rgb(24 158 180)">t key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2)</text><text x="1686" y="2280"  fill="rgb(255 255 255)"> { throw new InsightError(); } if</text><text x="1785" y="2280"  fill="rgb(237 28 36)"> (this.mtoken.incl</text><text x="1839" y="2280"  fill="rgb(255 255 255)">udes(applytoken)) { if</text><text x="1905" y="2280"  fill="rgb(237 28 36)"> (!(this.validateIdstring(</text><text x="1983" y="2280"  fill="rgb(255 255 255)">key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfield</text><text x="0" y="2285"  fill="rgb(255 255 255)">s.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Obj</text><text x="453" y="2285"  fill="rgb(237 28 36)">ect.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } </text><text x="786" y="2285"  fill="rgb(255 255 255)">this.validateColumns(q.COLUMNS); i</text><text x="888" y="2285"  fill="rgb(24 158 180)">f (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let m</text><text x="1341" y="2285"  fill="rgb(255 255 255)">skey of q) { if (this.transformationKey.le</text><text x="1467" y="2285"  fill="rgb(24 158 180)">ngth &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new Insi</text><text x="1686" y="2285"  fill="rgb(255 255 255)">ghtError(); } } else { this.vali</text><text x="1782" y="2285"  fill="rgb(237 28 36)">dateKey(mskey); } t</text><text x="1839" y="2285"  fill="rgb(255 255 255)">his.keysInQuery.push(m</text><text x="1905" y="2285"  fill="rgb(237 28 36)">skey); } } private validat</text><text x="1983" y="2285"  fill="rgb(255 255 255)">eOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); </text><text x="0" y="2290"  fill="rgb(255 255 255)">} } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new Insi</text><text x="453" y="2290"  fill="rgb(237 28 36)">ghtError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); </text><text x="786" y="2290"  fill="rgb(255 255 255)">} for (let anykey of keys) { if (!t</text><text x="891" y="2290"  fill="rgb(24 158 180)">his.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new Insig</text><text x="1329" y="2290"  fill="rgb(255 255 255)">htError(); } else { if (Object.keys(q).lengt</text><text x="1461" y="2290"  fill="rgb(24 158 180)">h !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): v</text><text x="1683" y="2290"  fill="rgb(255 255 255)">oid { if (Object.keys(q).length </text><text x="1779" y="2290"  fill="rgb(237 28 36)">!== 1) { throw new I</text><text x="1839" y="2290"  fill="rgb(255 255 255)">nsightError(); } else </text><text x="1905" y="2290"  fill="rgb(237 28 36)">{ let key: string = Objec</text><text x="1980" y="2290"  fill="rgb(255 255 255)">t.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case </text><text x="0" y="2295"  fill="rgb(255 255 255)">&quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } privat</text><text x="456" y="2295"  fill="rgb(237 28 36)">e validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFil</text><text x="789" y="2295"  fill="rgb(255 255 255)">ter(value); } private validateIS(v</text><text x="891" y="2295"  fill="rgb(24 158 180)">alue: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError()</text><text x="1320" y="2295"  fill="rgb(255 255 255)">; } let skey: string[] = Object.keys(value)[0]</text><text x="1458" y="2295"  fill="rgb(24 158 180)">.split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { l</text><text x="1680" y="2295"  fill="rgb(255 255 255)">et idstring: string = skey[0]; le</text><text x="1779" y="2295"  fill="rgb(237 28 36)">t sfield: string = s</text><text x="1839" y="2295"  fill="rgb(255 255 255)">key[1]; let str: any =</text><text x="1905" y="2295"  fill="rgb(237 28 36)"> Object.values(value)[0];</text><text x="1980" y="2295"  fill="rgb(255 255 255)"> if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)</text><text x="0" y="2300"  fill="rgb(255 255 255)">) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { thro</text><text x="459" y="2300"  fill="rgb(237 28 36)">w new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw </text><text x="789" y="2300"  fill="rgb(255 255 255)">new InsightError(); } else { let id</text><text x="894" y="2300"  fill="rgb(24 158 180)">string: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.val</text><text x="1308" y="2300"  fill="rgb(255 255 255)">idateIdstring(idstring) || !this.mfields.include</text><text x="1452" y="2300"  fill="rgb(24 158 180)">s(mfield)) { throw new InsightError(); } } } private validateANDOR(value: an</text><text x="1680" y="2300"  fill="rgb(255 255 255)">y): void { if (!Array.isArray(va</text><text x="1776" y="2300"  fill="rgb(237 28 36)">lue) || value.length </text><text x="1839" y="2300"  fill="rgb(255 255 255)">&lt; 1) { throw new Insig</text><text x="1905" y="2300"  fill="rgb(237 28 36)">htError(); } for (let in</text><text x="1977" y="2300"  fill="rgb(255 255 255)">nerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset o</text><text x="0" y="2305"  fill="rgb(255 255 255)">f this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) </text><text x="459" y="2305"  fill="rgb(237 28 36)">{ this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfiel</text><text x="789" y="2305"  fill="rgb(255 255 255)">ds; this.sfields = this.roomsfields</text><text x="894" y="2305"  fill="rgb(24 158 180)">; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this</text><text x="1299" y="2305"  fill="rgb(255 255 255)">.idInQuery; } } import {InsightDataset, InsightDat</text><text x="1449" y="2305"  fill="rgb(24 158 180)">asetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryV</text><text x="1677" y="2305"  fill="rgb(255 255 255)">alidator { private readonly cour</text><text x="1773" y="2305"  fill="rgb(237 28 36)">semfields: string[] = </text><text x="1839" y="2305"  fill="rgb(255 255 255)">[&quot;avg&quot;, &quot;pass&quot;, &quot;fail</text><text x="1902" y="2305"  fill="rgb(237 28 36)">&quot;, &quot;audit&quot;, &quot;year&quot;]; priv</text><text x="1977" y="2305"  fill="rgb(255 255 255)">ate readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly rooms</text><text x="0" y="2310"  fill="rgb(255 255 255)">fields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;</text><text x="462" y="2310"  fill="rgb(237 28 36)">, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the</text><text x="792" y="2310"  fill="rgb(255 255 255)"> query only has one id private keys</text><text x="897" y="2310"  fill="rgb(24 158 180)">InQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in t</text><text x="1290" y="2310"  fill="rgb(255 255 255)">ransformation, if there is a transformation private</text><text x="1443" y="2310"  fill="rgb(24 158 180)"> allInsightDataset: InsightDataset[]; private mfields: string[]; private sfiel</text><text x="1677" y="2310"  fill="rgb(255 255 255)">ds: string[]; constructor(insig</text><text x="1770" y="2310"  fill="rgb(237 28 36)">htDatasets: InsightDat</text><text x="1836" y="2310"  fill="rgb(255 255 255)">aset[]) { this.idInQue</text><text x="1902" y="2310"  fill="rgb(237 28 36)">ry = []; this.keysInQuery</text><text x="1977" y="2310"  fill="rgb(255 255 255)"> = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); </text><text x="0" y="2315"  fill="rgb(255 255 255)">} for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWh</text><text x="462" y="2315"  fill="rgb(237 28 36)">ere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions</text><text x="792" y="2315"  fill="rgb(255 255 255)">(q.OPTIONS); } public validateTransf</text><text x="900" y="2315"  fill="rgb(24 158 180)">ormations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) </text><text x="1281" y="2315"  fill="rgb(255 255 255)">{ throw new InsightError(); } this.validateGROUP(q.G</text><text x="1437" y="2315"  fill="rgb(24 158 180)">ROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if </text><text x="1674" y="2315"  fill="rgb(255 255 255)">(!Array.isArray(q) || q.length &lt;</text><text x="1770" y="2315"  fill="rgb(237 28 36)"> 1) { throw new Insigh</text><text x="1836" y="2315"  fill="rgb(255 255 255)">tError(); // q should </text><text x="1902" y="2315"  fill="rgb(237 28 36)">be an object, and should</text><text x="1974" y="2315"  fill="rgb(255 255 255)"> has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private vali</text><text x="0" y="2320"  fill="rgb(255 255 255)">dateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIds</text><text x="465" y="2320"  fill="rgb(237 28 36)">tring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { </text><text x="795" y="2320"  fill="rgb(255 255 255)">throw new InsightError(); } } priva</text><text x="900" y="2320"  fill="rgb(24 158 180)">te validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have</text><text x="1272" y="2320"  fill="rgb(255 255 255)"> at least one element } for (let applyrule of q) { if </text><text x="1434" y="2320"  fill="rgb(24 158 180)">(Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new Insi</text><text x="1674" y="2320"  fill="rgb(255 255 255)">ghtError(); } let applykey: str</text><text x="1767" y="2320"  fill="rgb(237 28 36)">ing = Object.keys(apply</text><text x="1836" y="2320"  fill="rgb(255 255 255)">rule)[0]; let criteria</text><text x="1902" y="2320"  fill="rgb(237 28 36)"> = applyrule[applykey]; </text><text x="1974" y="2320"  fill="rgb(255 255 255)">if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Arra</text><text x="0" y="2325"  fill="rgb(255 255 255)">y.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.i</text><text x="468" y="2325"  fill="rgb(237 28 36)">ncludes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = </text><text x="795" y="2325"  fill="rgb(255 255 255)">criteria[applytoken].split(&quot;_&quot;); if </text><text x="903" y="2325"  fill="rgb(24 158 180)">(key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key</text><text x="1263" y="2325"  fill="rgb(255 255 255)">[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new Ins</text><text x="1428" y="2325"  fill="rgb(24 158 180)">ightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validat</text><text x="1671" y="2325"  fill="rgb(255 255 255)">eIdstring(key[0]) &amp;&amp; (this.sfie</text><text x="1764" y="2325"  fill="rgb(237 28 36)">lds.includes(key[1]) || </text><text x="1836" y="2325"  fill="rgb(255 255 255)">this.mfields.includes(</text><text x="1902" y="2325"  fill="rgb(237 28 36)">key[1])))) { throw new </text><text x="1971" y="2325"  fill="rgb(255 255 255)">InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new I</text><text x="0" y="2330"  fill="rgb(255 255 255)">nsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.leng</text><text x="468" y="2330"  fill="rgb(237 28 36)">th &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!th</text><text x="795" y="2330"  fill="rgb(255 255 255)">is.transformationKey.includes(mskey)</text><text x="903" y="2330"  fill="rgb(24 158 180)">) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validat</text><text x="1254" y="2330"  fill="rgb(255 255 255)">eOrder(q: any): void { if (Array.isArray(q)) { throw new</text><text x="1422" y="2330"  fill="rgb(24 158 180)"> InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes</text><text x="1671" y="2330"  fill="rgb(255 255 255)">(q)) { throw new InsightError(</text><text x="1761" y="2330"  fill="rgb(237 28 36)">); } } else { if (!q.dir </text><text x="1836" y="2330"  fill="rgb(255 255 255)">|| !q.keys || Object.k</text><text x="1902" y="2330"  fill="rgb(237 28 36)">eys(q).length !== 2) { </text><text x="1971" y="2330"  fill="rgb(255 255 255)">throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw n</text><text x="0" y="2335"  fill="rgb(255 255 255)">ew InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): voi</text><text x="471" y="2335"  fill="rgb(237 28 36)">d { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.valida</text><text x="798" y="2335"  fill="rgb(255 255 255)">teFilter(q); } } } private validateF</text><text x="906" y="2335"  fill="rgb(24 158 180)">ilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Obj</text><text x="1245" y="2335"  fill="rgb(255 255 255)">ect.keys(q)[0]; let value: any = Object.values(q)[0]; swi</text><text x="1416" y="2335"  fill="rgb(24 158 180)">tch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: thi</text><text x="1668" y="2335"  fill="rgb(255 255 255)">s.validateNOT(value); break; ca</text><text x="1761" y="2335"  fill="rgb(237 28 36)">se &quot;GT&quot;: case &quot;LT&quot;: case </text><text x="1836" y="2335"  fill="rgb(255 255 255)">&quot;EQ&quot;: this.validateGTL</text><text x="1902" y="2335"  fill="rgb(237 28 36)">TEQ(value); break; cas</text><text x="1968" y="2335"  fill="rgb(255 255 255)">e &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError()</text><text x="0" y="2340"  fill="rgb(255 255 255)">; } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).l</text><text x="474" y="2340"  fill="rgb(237 28 36)">ength !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.l</text><text x="798" y="2340"  fill="rgb(255 255 255)">ength !== 2) { throw new InsightError</text><text x="909" y="2340"  fill="rgb(24 158 180)">(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)</text><text x="1239" y="2340"  fill="rgb(255 255 255)">[0]; if (typeof str !== &quot;string&quot;) { throw new InsightErro</text><text x="1410" y="2340"  fill="rgb(24 158 180)">r(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring</text><text x="1665" y="2340"  fill="rgb(255 255 255)">) || !this.sfields.includes(sfi</text><text x="1758" y="2340"  fill="rgb(237 28 36)">eld)) { throw new InsightE</text><text x="1836" y="2340"  fill="rgb(255 255 255)">rror(); } } } } priva</text><text x="1899" y="2340"  fill="rgb(237 28 36)">te validateGTLTEQ(value</text><text x="1968" y="2340"  fill="rgb(255 255 255)">: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.le</text><text x="0" y="2345"  fill="rgb(255 255 255)">ngth !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((ty</text><text x="474" y="2345"  fill="rgb(237 28 36)">peof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new In</text><text x="798" y="2345"  fill="rgb(255 255 255)">sightError(); } } } private validateA</text><text x="909" y="2345"  fill="rgb(24 158 180)">NDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (</text><text x="1230" y="2345"  fill="rgb(255 255 255)">let innerObject of value) { this.validateFilter(innerObjec</text><text x="1404" y="2345"  fill="rgb(24 158 180)">t); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length</text><text x="1665" y="2345"  fill="rgb(255 255 255)"> === 0) { for (let insightData</text><text x="1755" y="2345"  fill="rgb(237 28 36)">set of this.allInsightData</text><text x="1833" y="2345"  fill="rgb(255 255 255)">set) { if (insightData</text><text x="1899" y="2345"  fill="rgb(237 28 36)">set.id === idstring) { </text><text x="1968" y="2345"  fill="rgb(255 255 255)">this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfie</text><text x="0" y="2350"  fill="rgb(255 255 255)">lds = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdIn</text><text x="477" y="2350"  fill="rgb(237 28 36)">Query(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} fro</text><text x="801" y="2350"  fill="rgb(255 255 255)">m &quot;./IInsightFacade&quot;; export default </text><text x="912" y="2350"  fill="rgb(24 158 180)">class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year</text><text x="1224" y="2350"  fill="rgb(255 255 255)">&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;i</text><text x="1398" y="2350"  fill="rgb(24 158 180)">d&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lo</text><text x="1662" y="2350"  fill="rgb(255 255 255)">n&quot;, &quot;seats&quot;]; private readonly</text><text x="1752" y="2350"  fill="rgb(237 28 36)"> roomsfields: string[] = [&quot;</text><text x="1833" y="2350"  fill="rgb(255 255 255)">fullname&quot;, &quot;shortname&quot;</text><text x="1899" y="2350"  fill="rgb(237 28 36)">, &quot;number&quot; , &quot;name&quot;, &quot;</text><text x="1965" y="2350"  fill="rgb(255 255 255)">address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: strin</text><text x="0" y="2355"  fill="rgb(255 255 255)">g[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: stri</text><text x="480" y="2355"  fill="rgb(237 28 36)">ng[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDa</text><text x="801" y="2355"  fill="rgb(255 255 255)">taset[]; private mfields: string[]; p</text><text x="912" y="2355"  fill="rgb(24 158 180)">rivate sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.</text><text x="1215" y="2355"  fill="rgb(255 255 255)">keysInQuery = []; this.transformationKey = []; this.allInsi</text><text x="1392" y="2355"  fill="rgb(24 158 180)">ghtDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.O</text><text x="1662" y="2355"  fill="rgb(255 255 255)">PTIONS) { throw new InsightErr</text><text x="1752" y="2355"  fill="rgb(237 28 36)">or(); } for (let key of Obj</text><text x="1833" y="2355"  fill="rgb(255 255 255)">ect.keys(q)) { if (key</text><text x="1899" y="2355"  fill="rgb(237 28 36)"> !== &quot;OPTIONS&quot; &amp;&amp; key </text><text x="1965" y="2355"  fill="rgb(255 255 255)">!== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); }</text><text x="0" y="2360"  fill="rgb(255 255 255)"> this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object</text><text x="483" y="2360"  fill="rgb(237 28 36)">.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPL</text><text x="804" y="2360"  fill="rgb(255 255 255)">Y); } private validateGROUP(q: any): </text><text x="915" y="2360"  fill="rgb(24 158 180)">void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object</text><text x="1209" y="2360"  fill="rgb(255 255 255)">, and should has at least one element } for (let key of q) </text><text x="1386" y="2360"  fill="rgb(24 158 180)">{ this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it </text><text x="1659" y="2360"  fill="rgb(255 255 255)">to transformationKey } } priva</text><text x="1749" y="2360"  fill="rgb(237 28 36)">te validateKey(key: string):</text><text x="1833" y="2360"  fill="rgb(255 255 255)"> void { let splittedKe</text><text x="1899" y="2360"  fill="rgb(237 28 36)">y: string[] = key.spl</text><text x="1962" y="2360"  fill="rgb(255 255 255)">it(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes</text><text x="0" y="2365"  fill="rgb(255 255 255)">(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an ar</text><text x="483" y="2365"  fill="rgb(237 28 36)">ray, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Obje</text><text x="804" y="2365"  fill="rgb(255 255 255)">ct.keys(applyrule).length &gt; 1) { throw</text><text x="918" y="2365"  fill="rgb(24 158 180)"> new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyru</text><text x="1203" y="2365"  fill="rgb(255 255 255)">le[applykey]; if (applykey.length === 0 || applykey.include</text><text x="1380" y="2365"  fill="rgb(24 158 180)">s(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.tran</text><text x="1656" y="2365"  fill="rgb(255 255 255)">sformationKey.push(applykey); </text><text x="1746" y="2365"  fill="rgb(237 28 36)">if (Array.isArray(criteria) |</text><text x="1833" y="2365"  fill="rgb(255 255 255)">| Object.keys(criteria</text><text x="1899" y="2365"  fill="rgb(237 28 36)">).length &gt; 1) { throw</text><text x="1962" y="2365"  fill="rgb(255 255 255)"> new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); </text><text x="0" y="2370"  fill="rgb(255 255 255)">} let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.vali</text><text x="486" y="2370"  fill="rgb(237 28 36)">dateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.msto</text><text x="804" y="2370"  fill="rgb(255 255 255)">ken.includes(applytoken)) { if (!(this</text><text x="918" y="2370"  fill="rgb(24 158 180)">.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1]))</text><text x="1197" y="2370"  fill="rgb(255 255 255)">)) { throw new InsightError(); } } } } public validateOpti</text><text x="1371" y="2370"  fill="rgb(24 158 180)">ons(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLU</text><text x="1656" y="2370"  fill="rgb(255 255 255)">MNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { th</text><text x="1743" y="2370"  fill="rgb(237 28 36)">row new InsightError(); } } th</text><text x="1833" y="2370"  fill="rgb(255 255 255)">is.validateColumns(q.</text><text x="1896" y="2370"  fill="rgb(237 28 36)">COLUMNS); if (q.ORDER</text><text x="1959" y="2370"  fill="rgb(255 255 255)">) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey</text><text x="0" y="2375"  fill="rgb(255 255 255)">.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } pri</text><text x="489" y="2375"  fill="rgb(237 28 36)">vate validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q =</text><text x="807" y="2375"  fill="rgb(255 255 255)">== &quot;string&quot;) { if (!this.keysInQuery.i</text><text x="921" y="2375"  fill="rgb(24 158 180)">ncludes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q)</text><text x="1191" y="2375"  fill="rgb(255 255 255)">.length !== 2) { throw new InsightError(); } if (q.dir !==</text><text x="1365" y="2375"  fill="rgb(24 158 180)"> &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isAr</text><text x="1653" y="2375"  fill="rgb(255 255 255)">ray(keys) || keys.length &lt; 1)</text><text x="1740" y="2375"  fill="rgb(237 28 36)"> { throw new InsightError(); }</text><text x="1830" y="2375"  fill="rgb(255 255 255)"> for (let anykey of ke</text><text x="1896" y="2375"  fill="rgb(237 28 36)">ys) { if (!this.keysI</text><text x="1959" y="2375"  fill="rgb(255 255 255)">nQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).leng</text><text x="0" y="2380"  fill="rgb(255 255 255)">th !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: str</text><text x="489" y="2380"  fill="rgb(237 28 36)">ing = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.</text><text x="807" y="2380"  fill="rgb(255 255 255)">validateANDOR(value); break; case &quot;NOT&quot;</text><text x="924" y="2380"  fill="rgb(24 158 180)">: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(</text><text x="1185" y="2380"  fill="rgb(255 255 255)">value); break; case &quot;IS&quot;: this.validateIS(value); break; </text><text x="1356" y="2380"  fill="rgb(24 158 180)">default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value </text><text x="1650" y="2380"  fill="rgb(255 255 255)">!== &quot;object&quot;) { throw new Insi</text><text x="1740" y="2380"  fill="rgb(237 28 36)">ghtError(); } this.validateFil</text><text x="1830" y="2380"  fill="rgb(255 255 255)">ter(value); } private </text><text x="1896" y="2380"  fill="rgb(237 28 36)">validateIS(value: an</text><text x="1956" y="2380"  fill="rgb(255 255 255)">y): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0]</text><text x="0" y="2385"  fill="rgb(255 255 255)">.split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(</text><text x="492" y="2385"  fill="rgb(237 28 36)">value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includ</text><text x="807" y="2385"  fill="rgb(255 255 255)">es(&quot;*&quot;)) || !this.validateIdstring(idst</text><text x="924" y="2385"  fill="rgb(24 158 180)">ring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private </text><text x="1179" y="2385"  fill="rgb(255 255 255)">validateGTLTEQ(value: any): void { if (typeof value !== &quot;</text><text x="1350" y="2385"  fill="rgb(24 158 180)">object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Objec</text><text x="1650" y="2385"  fill="rgb(255 255 255)">t.keys(value)[0].split(&quot;_&quot;); </text><text x="1737" y="2385"  fill="rgb(237 28 36)">if (mkey.length !== 2) { throw </text><text x="1830" y="2385"  fill="rgb(255 255 255)">new InsightError(); } </text><text x="1896" y="2385"  fill="rgb(237 28 36)">else { let idstring:</text><text x="1956" y="2385"  fill="rgb(255 255 255)"> string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(</text><text x="0" y="2390"  fill="rgb(255 255 255)">mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for</text><text x="495" y="2390"  fill="rgb(237 28 36)"> (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: st</text><text x="810" y="2390"  fill="rgb(255 255 255)">ring): boolean { if (this.idInQuery.len</text><text x="927" y="2390"  fill="rgb(24 158 180)">gth === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDatas</text><text x="1173" y="2390"  fill="rgb(255 255 255)">et.id === idstring) { this.idInQuery.push(idstring); if </text><text x="1341" y="2390"  fill="rgb(24 158 180)">(insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields</text><text x="1647" y="2390"  fill="rgb(255 255 255)"> = this.coursesfields; } else</text><text x="1734" y="2390"  fill="rgb(237 28 36)"> { this.mfields = this.roommfiel</text><text x="1830" y="2390"  fill="rgb(255 255 255)">ds; this.sfields = thi</text><text x="1896" y="2390"  fill="rgb(237 28 36)">s.roomsfields; } re</text><text x="1953" y="2390"  fill="rgb(255 255 255)">turn true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatase</text><text x="0" y="2395"  fill="rgb(255 255 255)">tKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;</text><text x="498" y="2395"  fill="rgb(237 28 36)">]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private rea</text><text x="810" y="2395"  fill="rgb(255 255 255)">donly roommfields: string[] = [&quot;lat&quot;, &quot;l</text><text x="930" y="2395"  fill="rgb(24 158 180)">on&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;</text><text x="1170" y="2395"  fill="rgb(255 255 255)">, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;</text><text x="1332" y="2395"  fill="rgb(24 158 180)">href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: stri</text><text x="1644" y="2395"  fill="rgb(255 255 255)">ng[] = [&quot;COUNT&quot;]; private idI</text><text x="1731" y="2395"  fill="rgb(237 28 36)">nQuery: string[]; // make sure th</text><text x="1830" y="2395"  fill="rgb(255 255 255)">e query only has one i</text><text x="1896" y="2395"  fill="rgb(237 28 36)">d private keysInQue</text><text x="1953" y="2395"  fill="rgb(255 255 255)">ry: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allI</text><text x="0" y="2400"  fill="rgb(255 255 255)">nsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysI</text><text x="501" y="2400"  fill="rgb(237 28 36)">nQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q:</text><text x="813" y="2400"  fill="rgb(255 255 255)"> any): void { if (!q || !q.WHERE || !q.O</text><text x="933" y="2400"  fill="rgb(24 158 180)">PTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (k</text><text x="1164" y="2400"  fill="rgb(255 255 255)">ey !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANS</text><text x="1323" y="2400"  fill="rgb(24 158 180)">FORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.va</text><text x="1641" y="2400"  fill="rgb(255 255 255)">lidateTransformations(q.TRANSF</text><text x="1731" y="2400"  fill="rgb(237 28 36)">ORMATIONS); } this.validateOption</text><text x="1830" y="2400"  fill="rgb(255 255 255)">s(q.OPTIONS); } public</text><text x="1896" y="2400"  fill="rgb(237 28 36)"> validateTransform</text><text x="1950" y="2400"  fill="rgb(255 255 255)">ations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); </text><text x="0" y="2405"  fill="rgb(255 255 255)">this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and sh</text><text x="504" y="2405"  fill="rgb(237 28 36)">ould has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push</text><text x="813" y="2405"  fill="rgb(255 255 255)">(key); // if the key is valid, push it t</text><text x="933" y="2405"  fill="rgb(24 158 180)">o transformationKey } } private validateKey(key: string): void { let splitt</text><text x="1158" y="2405"  fill="rgb(255 255 255)">edKey: string[] = key.split(&quot;_&quot;); if (splittedKey.le</text><text x="1314" y="2405"  fill="rgb(24 158 180)">ngth !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includ</text><text x="1641" y="2405"  fill="rgb(255 255 255)">es(splittedKey[1]) || this.sf</text><text x="1728" y="2405"  fill="rgb(237 28 36)">ields.includes(splittedKey[1]))))</text><text x="1827" y="2405"  fill="rgb(255 255 255)"> { throw new InsightEr</text><text x="1893" y="2405"  fill="rgb(237 28 36)">ror(); } } private </text><text x="1950" y="2405"  fill="rgb(255 255 255)">validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.i</text><text x="0" y="2410"  fill="rgb(255 255 255)">sArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applyke</text><text x="504" y="2410"  fill="rgb(237 28 36)">y]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) {</text><text x="813" y="2410"  fill="rgb(255 255 255)"> throw new InsightError(); } this.transfo</text><text x="936" y="2410"  fill="rgb(24 158 180)">rmationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(cri</text><text x="1155" y="2410"  fill="rgb(255 255 255)">teria).length &gt; 1) { throw new InsightError(); } </text><text x="1302" y="2410"  fill="rgb(24 158 180)">let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includ</text><text x="1638" y="2410"  fill="rgb(255 255 255)">es(applytoken)) { throw new I</text><text x="1725" y="2410"  fill="rgb(237 28 36)">nsightError(); } let key: string[]</text><text x="1827" y="2410"  fill="rgb(255 255 255)"> = criteria[applytoken</text><text x="1893" y="2410"  fill="rgb(237 28 36)">].split(&quot;_&quot;); if (</text><text x="1947" y="2410"  fill="rgb(255 255 255)">key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(</text><text x="0" y="2415"  fill="rgb(255 255 255)">); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw ne</text><text x="507" y="2415"  fill="rgb(237 28 36)">w InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for </text><text x="816" y="2415"  fill="rgb(255 255 255)">(let key of keys) { if (key !== &quot;COLUMNS&quot;</text><text x="939" y="2415"  fill="rgb(24 158 180)"> &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColu</text><text x="1149" y="2415"  fill="rgb(255 255 255)">mns(q.COLUMNS); if (q.ORDER) { this.validateOrde</text><text x="1293" y="2415"  fill="rgb(24 158 180)">r(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for </text><text x="1635" y="2415"  fill="rgb(255 255 255)">(let mskey of q) { if (this.t</text><text x="1722" y="2415"  fill="rgb(237 28 36)">ransformationKey.length &gt; 0) { if (</text><text x="1827" y="2415"  fill="rgb(255 255 255)">!this.transformationKe</text><text x="1893" y="2415"  fill="rgb(237 28 36)">y.includes(mskey))</text><text x="1947" y="2415"  fill="rgb(255 255 255)"> { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightErro</text><text x="0" y="2420"  fill="rgb(255 255 255)">r(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) {</text><text x="510" y="2420"  fill="rgb(237 28 36)"> throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let</text><text x="816" y="2420"  fill="rgb(255 255 255)"> keys: any = q.keys; if (!Array.isArray(ke</text><text x="942" y="2420"  fill="rgb(24 158 180)">ys) || keys.length &lt; 1) { throw new InsightError(); } for (let anyke</text><text x="1146" y="2420"  fill="rgb(255 255 255)">y of keys) { if (!this.keysInQuery.includes(a</text><text x="1281" y="2420"  fill="rgb(24 158 180)">nykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new In</text><text x="1632" y="2420"  fill="rgb(255 255 255)">sightError(); } else { if (Ob</text><text x="1719" y="2420"  fill="rgb(237 28 36)">ject.keys(q).length !== 0) { this.va</text><text x="1827" y="2420"  fill="rgb(255 255 255)">lidateFilter(q); } } }</text><text x="1893" y="2420"  fill="rgb(237 28 36)"> private validate</text><text x="1944" y="2420"  fill="rgb(255 255 255)">Filter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { ca</text><text x="0" y="2425"  fill="rgb(255 255 255)">se &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case</text><text x="513" y="2425"  fill="rgb(237 28 36)"> &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(va</text><text x="816" y="2425"  fill="rgb(255 255 255)">lue: any): void { if (typeof value !== &quot;obj</text><text x="945" y="2425"  fill="rgb(24 158 180)">ect&quot;) { throw new InsightError(); } this.validateFilter(value); }</text><text x="1140" y="2425"  fill="rgb(255 255 255)"> private validateIS(value: any): void { if </text><text x="1269" y="2425"  fill="rgb(24 158 180)">(typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError()</text><text x="1632" y="2425"  fill="rgb(255 255 255)">; } let skey: string[] = Obj</text><text x="1716" y="2425"  fill="rgb(237 28 36)">ect.keys(value)[0].split(&quot;_&quot;); if (sk</text><text x="1827" y="2425"  fill="rgb(255 255 255)">ey.length !== 2) { thr</text><text x="1893" y="2425"  fill="rgb(237 28 36)">ow new InsightErr</text><text x="1944" y="2425"  fill="rgb(255 255 255)">or(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if</text><text x="0" y="2430"  fill="rgb(255 255 255)"> ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: </text><text x="516" y="2430"  fill="rgb(237 28 36)">any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightErr</text><text x="819" y="2430"  fill="rgb(255 255 255)">or(); } let mkey: string[] = Object.keys(v</text><text x="945" y="2430"  fill="rgb(24 158 180)">alue)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightE</text><text x="1137" y="2430"  fill="rgb(255 255 255)">rror(); } else { let idstring: string = m</text><text x="1260" y="2430"  fill="rgb(24 158 180)">key[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.valida</text><text x="1629" y="2430"  fill="rgb(255 255 255)">teIdstring(idstring) || !this</text><text x="1716" y="2430"  fill="rgb(237 28 36)">.mfields.includes(mfield)) { throw n</text><text x="1824" y="2430"  fill="rgb(255 255 255)">ew InsightError(); } } </text><text x="1893" y="2430"  fill="rgb(237 28 36)">} private valida</text><text x="1941" y="2430"  fill="rgb(255 255 255)">teANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private va</text><text x="0" y="2435"  fill="rgb(255 255 255)">lidateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { thi</text><text x="519" y="2435"  fill="rgb(237 28 36)">s.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields =</text><text x="819" y="2435"  fill="rgb(255 255 255)"> this.coursemfields; this.sfields = this.co</text><text x="948" y="2435"  fill="rgb(24 158 180)">ursesfields; } else { this.mfields = this.roommfields; this.s</text><text x="1131" y="2435"  fill="rgb(255 255 255)">fields = this.roomsfields; } return tru</text><text x="1248" y="2435"  fill="rgb(24 158 180)">e; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idIn</text><text x="1626" y="2435"  fill="rgb(255 255 255)">Query; } } import {InsightDat</text><text x="1713" y="2435"  fill="rgb(237 28 36)">aset, InsightDatasetKind, InsightErro</text><text x="1824" y="2435"  fill="rgb(255 255 255)">r} from &quot;./IInsightFac</text><text x="1890" y="2435"  fill="rgb(237 28 36)">ade&quot;; export defa</text><text x="1941" y="2435"  fill="rgb(255 255 255)">ult class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;t</text><text x="0" y="2440"  fill="rgb(255 255 255)">itle&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;addre</text><text x="522" y="2440"  fill="rgb(237 28 36)">ss&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;];</text><text x="822" y="2440"  fill="rgb(255 255 255)"> private readonly mstoken: string[] = [&quot;COU</text><text x="951" y="2440"  fill="rgb(24 158 180)">NT&quot;]; private idInQuery: string[]; // make sure the query o</text><text x="1128" y="2440"  fill="rgb(255 255 255)">nly has one id private keysInQuery: s</text><text x="1239" y="2440"  fill="rgb(24 158 180)">tring[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transfor</text><text x="1623" y="2440"  fill="rgb(255 255 255)">mation, if there is a transfo</text><text x="1710" y="2440"  fill="rgb(237 28 36)">rmation private allInsightDataset: Ins</text><text x="1824" y="2440"  fill="rgb(255 255 255)">ightDataset[]; private</text><text x="1890" y="2440"  fill="rgb(237 28 36)"> mfields: string</text><text x="1938" y="2440"  fill="rgb(255 255 255)">[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDa</text><text x="0" y="2445"  fill="rgb(255 255 255)">tasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;W</text><text x="525" y="2445"  fill="rgb(237 28 36)">HERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if</text><text x="822" y="2445"  fill="rgb(255 255 255)"> (q.TRANSFORMATIONS) { this.validateTransfor</text><text x="954" y="2445"  fill="rgb(24 158 180)">mations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTI</text><text x="1125" y="2445"  fill="rgb(255 255 255)">ONS); } public validateTransformat</text><text x="1227" y="2445"  fill="rgb(24 158 180)">ions(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw n</text><text x="1620" y="2445"  fill="rgb(255 255 255)">ew InsightError(); } this.val</text><text x="1707" y="2445"  fill="rgb(237 28 36)">idateGROUP(q.GROUP); this.validateAPPLY</text><text x="1824" y="2445"  fill="rgb(255 255 255)">(q.APPLY); } private v</text><text x="1890" y="2445"  fill="rgb(237 28 36)">alidateGROUP(q: </text><text x="1938" y="2445"  fill="rgb(255 255 255)">any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key);</text><text x="0" y="2450"  fill="rgb(255 255 255)"> this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;);</text><text x="528" y="2450"  fill="rgb(237 28 36)"> if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedK</text><text x="822" y="2450"  fill="rgb(255 255 255)">ey[0]) &amp;&amp; (this.mfields.includes(splittedKey[</text><text x="957" y="2450"  fill="rgb(24 158 180)">1]) || this.sfields.includes(splittedKey[1])))) { throw</text><text x="1122" y="2450"  fill="rgb(255 255 255)"> new InsightError(); } } private</text><text x="1218" y="2450"  fill="rgb(24 158 180)"> validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least o</text><text x="1617" y="2450"  fill="rgb(255 255 255)">ne element } for (let applyru</text><text x="1704" y="2450"  fill="rgb(237 28 36)">le of q) { if (Array.isArray(applyrule) </text><text x="1824" y="2450"  fill="rgb(255 255 255)">|| Object.keys(applyru</text><text x="1890" y="2450"  fill="rgb(237 28 36)">le).length &gt; 1)</text><text x="1935" y="2450"  fill="rgb(255 255 255)"> { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformat</text><text x="0" y="2455"  fill="rgb(255 255 255)">ionKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new Insig</text><text x="534" y="2455"  fill="rgb(237 28 36)">htError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applyto</text><text x="825" y="2455"  fill="rgb(255 255 255)">ken) &amp;&amp; !this.mstoken.includes(applytoken)) {</text><text x="960" y="2455"  fill="rgb(24 158 180)"> throw new InsightError(); } let key: string[] = cri</text><text x="1116" y="2455"  fill="rgb(255 255 255)">teria[applytoken].split(&quot;_&quot;); </text><text x="1206" y="2455"  fill="rgb(24 158 180)">if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.m</text><text x="1617" y="2455"  fill="rgb(255 255 255)">fields.includes(key[1]))) { </text><text x="1701" y="2455"  fill="rgb(237 28 36)">throw new InsightError(); } } else if (t</text><text x="1821" y="2455"  fill="rgb(255 255 255)">his.mstoken.includes(ap</text><text x="1890" y="2455"  fill="rgb(237 28 36)">plytoken)) { if</text><text x="1935" y="2455"  fill="rgb(255 255 255)"> (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys:</text><text x="0" y="2460"  fill="rgb(255 255 255)"> any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.val</text><text x="537" y="2460"  fill="rgb(237 28 36)">idateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw</text><text x="825" y="2460"  fill="rgb(255 255 255)"> new InsightError(); } for (let mskey of q) { </text><text x="963" y="2460"  fill="rgb(24 158 180)">if (this.transformationKey.length &gt; 0) { if (!this</text><text x="1113" y="2460"  fill="rgb(255 255 255)">.transformationKey.includes(</text><text x="1197" y="2460"  fill="rgb(24 158 180)">mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): </text><text x="1614" y="2460"  fill="rgb(255 255 255)">void { if (Array.isArray(q)) </text><text x="1701" y="2460"  fill="rgb(237 28 36)">{ throw new InsightError(); } else if (t</text><text x="1821" y="2460"  fill="rgb(255 255 255)">ypeof q === &quot;string&quot;) {</text><text x="1890" y="2460"  fill="rgb(237 28 36)"> if (!this.key</text><text x="1932" y="2460"  fill="rgb(255 255 255)">sInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { th</text><text x="0" y="2465"  fill="rgb(255 255 255)">row new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includ</text><text x="540" y="2465"  fill="rgb(237 28 36)">es(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.i</text><text x="828" y="2465"  fill="rgb(255 255 255)">sArray(q)) { throw new InsightError(); } else </text><text x="966" y="2465"  fill="rgb(24 158 180)">{ if (Object.keys(q).length !== 0) { this.valida</text><text x="1110" y="2465"  fill="rgb(255 255 255)">teFilter(q); } } } private</text><text x="1188" y="2465"  fill="rgb(24 158 180)"> validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; le</text><text x="1611" y="2465"  fill="rgb(255 255 255)">t value: any = Object.values(</text><text x="1698" y="2465"  fill="rgb(237 28 36)">q)[0]; switch (key) { case &quot;AND&quot;: case &quot;O</text><text x="1821" y="2465"  fill="rgb(255 255 255)">R&quot;: this.validateANDOR(</text><text x="1890" y="2465"  fill="rgb(237 28 36)">value); break;</text><text x="1932" y="2465"  fill="rgb(255 255 255)"> case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError();</text><text x="0" y="2470"  fill="rgb(255 255 255)"> } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (</text><text x="543" y="2470"  fill="rgb(237 28 36)">typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) {</text><text x="828" y="2470"  fill="rgb(255 255 255)"> throw new InsightError(); } let skey: string[]</text><text x="969" y="2470"  fill="rgb(24 158 180)"> = Object.keys(value)[0].split(&quot;_&quot;); if (skey.</text><text x="1107" y="2470"  fill="rgb(255 255 255)">length !== 2) { throw ne</text><text x="1179" y="2470"  fill="rgb(24 158 180)">w InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str</text><text x="1608" y="2470"  fill="rgb(255 255 255)"> !== &quot;string&quot;) { throw new In</text><text x="1695" y="2470"  fill="rgb(237 28 36)">sightError(); } else { if ((str.slice(1, -</text><text x="1821" y="2470"  fill="rgb(255 255 255)">1).includes(&quot;*&quot;)) || !</text><text x="1887" y="2470"  fill="rgb(237 28 36)">this.validateI</text><text x="1929" y="2470"  fill="rgb(255 255 255)">dstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length</text><text x="0" y="2475"  fill="rgb(255 255 255)"> !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0</text><text x="546" y="2475"  fill="rgb(237 28 36)">]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;n</text><text x="831" y="2475"  fill="rgb(255 255 255)">umber&quot;) || !this.validateIdstring(idstring) || </text><text x="972" y="2475"  fill="rgb(24 158 180)">!this.mfields.includes(mfield)) { throw new I</text><text x="1107" y="2475"  fill="rgb(255 255 255)">nsightError(); } } } p</text><text x="1173" y="2475"  fill="rgb(24 158 180)">rivate validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of va</text><text x="1605" y="2475"  fill="rgb(255 255 255)">lue) { this.validateFilter(in</text><text x="1692" y="2475"  fill="rgb(237 28 36)">nerObject); } } private validateIdstring(id</text><text x="1821" y="2475"  fill="rgb(255 255 255)">string: string): boole</text><text x="1887" y="2475"  fill="rgb(237 28 36)">an { if (this.</text><text x="1929" y="2475"  fill="rgb(255 255 255)">idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDataset</text><text x="0" y="2480"  fill="rgb(255 255 255)">Kind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } retu</text><text x="552" y="2480"  fill="rgb(237 28 36)">rn false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): strin</text><text x="831" y="2480"  fill="rgb(255 255 255)">g[] { return this.idInQuery; } } import {Insight</text><text x="975" y="2480"  fill="rgb(24 158 180)">Dataset, InsightDatasetKind, InsightError} </text><text x="1104" y="2480"  fill="rgb(255 255 255)">from &quot;./IInsightFaca</text><text x="1164" y="2480"  fill="rgb(24 158 180)">de&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly c</text><text x="1602" y="2480"  fill="rgb(255 255 255)">oursesfields: string[] = [&quot;de</text><text x="1689" y="2480"  fill="rgb(237 28 36)">pt&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; </text><text x="1818" y="2480"  fill="rgb(255 255 255)">private readonly roommf</text><text x="1887" y="2480"  fill="rgb(237 28 36)">ields: string</text><text x="1926" y="2480"  fill="rgb(255 255 255)">[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] </text><text x="0" y="2485"  fill="rgb(255 255 255)">= [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all</text><text x="555" y="2485"  fill="rgb(237 28 36)"> keys appeared in columns after being validated private transformationKey: string[]; // keys </text><text x="834" y="2485"  fill="rgb(255 255 255)">appeared in transformation, if there is a transf</text><text x="978" y="2485"  fill="rgb(24 158 180)">ormation private allInsightDataset: Insig</text><text x="1101" y="2485"  fill="rgb(255 255 255)">htDataset[]; privat</text><text x="1158" y="2485"  fill="rgb(24 158 180)">e mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.t</text><text x="1599" y="2485"  fill="rgb(255 255 255)">ransformationKey = []; this.a</text><text x="1686" y="2485"  fill="rgb(237 28 36)">llInsightDataset = insightDatasets; } public</text><text x="1818" y="2485"  fill="rgb(255 255 255)"> validate(q: any): void</text><text x="1887" y="2485"  fill="rgb(237 28 36)"> { if (!q ||</text><text x="1923" y="2485"  fill="rgb(255 255 255)"> !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } </text><text x="0" y="2490"  fill="rgb(255 255 255)">this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void {</text><text x="558" y="2490"  fill="rgb(237 28 36)"> if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).leng</text><text x="834" y="2490"  fill="rgb(255 255 255)">th !== 2) { throw new InsightError(); } this.vali</text><text x="981" y="2490"  fill="rgb(24 158 180)">dateGROUP(q.GROUP); this.validateAPPLY(q</text><text x="1101" y="2490"  fill="rgb(255 255 255)">.APPLY); } priva</text><text x="1149" y="2490"  fill="rgb(24 158 180)">te validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least</text><text x="1596" y="2490"  fill="rgb(255 255 255)"> one element } for (let key o</text><text x="1683" y="2490"  fill="rgb(237 28 36)">f q) { this.validateKey(key); this.transforma</text><text x="1818" y="2490"  fill="rgb(255 255 255)">tionKey.push(key); // i</text><text x="1887" y="2490"  fill="rgb(237 28 36)">f the key is</text><text x="1923" y="2490"  fill="rgb(255 255 255)"> valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(</text><text x="0" y="2495"  fill="rgb(255 255 255)">this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): </text><text x="561" y="2495"  fill="rgb(237 28 36)">void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and shoul</text><text x="837" y="2495"  fill="rgb(255 255 255)">d have at least one element } for (let applyrule </text><text x="984" y="2495"  fill="rgb(24 158 180)">of q) { if (Array.isArray(applyrule) |</text><text x="1098" y="2495"  fill="rgb(255 255 255)">| Object.keys(a</text><text x="1143" y="2495"  fill="rgb(24 158 180)">pplyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey</text><text x="1593" y="2495"  fill="rgb(255 255 255)">.length === 0 || applykey.incl</text><text x="1683" y="2495"  fill="rgb(237 28 36)">udes(&quot;_&quot;) || this.transformationKey.includes(</text><text x="1818" y="2495"  fill="rgb(255 255 255)">applykey)) { throw new </text><text x="1887" y="2495"  fill="rgb(237 28 36)">InsightErro</text><text x="1920" y="2495"  fill="rgb(255 255 255)">r(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; i</text><text x="0" y="2500"  fill="rgb(255 255 255)">f (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw </text><text x="567" y="2500"  fill="rgb(237 28 36)">new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(</text><text x="837" y="2500"  fill="rgb(255 255 255)">key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw</text><text x="987" y="2500"  fill="rgb(24 158 180)"> new InsightError(); } } else if (th</text><text x="1095" y="2500"  fill="rgb(255 255 255)">is.mstoken.inc</text><text x="1137" y="2500"  fill="rgb(24 158 180)">ludes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError</text><text x="1590" y="2500"  fill="rgb(255 255 255)">(); } } } } public validateOpt</text><text x="1680" y="2500"  fill="rgb(237 28 36)">ions(q: any): void { let keys: any[] = Object</text><text x="1815" y="2500"  fill="rgb(255 255 255)">.keys(q); for (let key </text><text x="1884" y="2500"  fill="rgb(237 28 36)">of keys) { i</text><text x="1920" y="2500"  fill="rgb(255 255 255)">f (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void {</text><text x="0" y="2505"  fill="rgb(255 255 255)"> if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError()</text><text x="570" y="2505"  fill="rgb(237 28 36)">; } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validate</text><text x="840" y="2505"  fill="rgb(255 255 255)">Order(q: any): void { if (Array.isArray(q)) { thro</text><text x="990" y="2505"  fill="rgb(24 158 180)">w new InsightError(); } else if (ty</text><text x="1095" y="2505"  fill="rgb(255 255 255)">peof q === </text><text x="1128" y="2505"  fill="rgb(24 158 180)">&quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new I</text><text x="1587" y="2505"  fill="rgb(255 255 255)">nsightError(); } if (q.dir !==</text><text x="1677" y="2505"  fill="rgb(237 28 36)"> &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new Insight</text><text x="1815" y="2505"  fill="rgb(255 255 255)">Error(); } let keys: an</text><text x="1884" y="2505"  fill="rgb(237 28 36)">y = q.keys;</text><text x="1917" y="2505"  fill="rgb(255 255 255)"> if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validate</text><text x="0" y="2510"  fill="rgb(255 255 255)">Where(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Ob</text><text x="573" y="2510"  fill="rgb(237 28 36)">ject.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.</text><text x="840" y="2510"  fill="rgb(255 255 255)">keys(q)[0]; let value: any = Object.values(q)[0]; s</text><text x="993" y="2510"  fill="rgb(24 158 180)">witch (key) { case &quot;AND&quot;: case &quot;O</text><text x="1092" y="2510"  fill="rgb(255 255 255)">R&quot;: this.</text><text x="1119" y="2510"  fill="rgb(24 158 180)">validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: thi</text><text x="1584" y="2510"  fill="rgb(255 255 255)">s.validateIS(value); break; de</text><text x="1674" y="2510"  fill="rgb(237 28 36)">fault: throw new InsightError(); } } } private </text><text x="1815" y="2510"  fill="rgb(255 255 255)">validateNOT(value: any)</text><text x="1884" y="2510"  fill="rgb(237 28 36)">: void { if</text><text x="1917" y="2510"  fill="rgb(255 255 255)"> (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (O</text><text x="0" y="2515"  fill="rgb(255 255 255)">bject.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: st</text><text x="579" y="2515"  fill="rgb(237 28 36)">ring = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if</text><text x="843" y="2515"  fill="rgb(255 255 255)"> (typeof str !== &quot;string&quot;) { throw new InsightError</text><text x="996" y="2515"  fill="rgb(24 158 180)">(); } else { if ((str.slice(1, </text><text x="1089" y="2515"  fill="rgb(255 255 255)">-1).inc</text><text x="1110" y="2515"  fill="rgb(24 158 180)">ludes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): vo</text><text x="1581" y="2515"  fill="rgb(255 255 255)">id { if (typeof value !== &quot;obj</text><text x="1671" y="2515"  fill="rgb(237 28 36)">ect&quot; || Object.keys(value).length !== 1) { throw</text><text x="1815" y="2515"  fill="rgb(255 255 255)"> new InsightError(); } </text><text x="1884" y="2515"  fill="rgb(237 28 36)">let mkey: </text><text x="1914" y="2515"  fill="rgb(255 255 255)">string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values</text><text x="0" y="2520"  fill="rgb(255 255 255)">(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!</text><text x="582" y="2520"  fill="rgb(237 28 36)">Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerO</text><text x="843" y="2520"  fill="rgb(255 255 255)">bject of value) { this.validateFilter(innerObject); </text><text x="999" y="2520"  fill="rgb(24 158 180)">} } private validateIdstring(</text><text x="1086" y="2520"  fill="rgb(255 255 255)">idstri</text><text x="1104" y="2520"  fill="rgb(24 158 180)">ng: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idI</text><text x="1575" y="2520"  fill="rgb(255 255 255)">nQuery.push(idstring); if (insi</text><text x="1668" y="2520"  fill="rgb(237 28 36)">ghtDataset.kind === InsightDatasetKind.Courses) {</text><text x="1815" y="2520"  fill="rgb(255 255 255)"> this.mfields = this.co</text><text x="1884" y="2520"  fill="rgb(237 28 36)">ursemfield</text><text x="1914" y="2520"  fill="rgb(255 255 255)">s; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring)</text><text x="0" y="2525"  fill="rgb(255 255 255)">; } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private </text><text x="588" y="2525"  fill="rgb(237 28 36)">readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private r</text><text x="846" y="2525"  fill="rgb(255 255 255)">eadonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;ins</text><text x="1005" y="2525"  fill="rgb(24 158 180)">tructor&quot;, &quot;title&quot;, &quot;uuid&quot;]</text><text x="1083" y="2525"  fill="rgb(255 255 255)">; pri</text><text x="1098" y="2525"  fill="rgb(24 158 180)">vate readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;</text><text x="1572" y="2525"  fill="rgb(255 255 255)">, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;];</text><text x="1665" y="2525"  fill="rgb(237 28 36)"> private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN</text><text x="1812" y="2525"  fill="rgb(255 255 255)">&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; privat</text><text x="1884" y="2525"  fill="rgb(237 28 36)">e readonl</text><text x="1911" y="2525"  fill="rgb(255 255 255)">y mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private tr</text><text x="0" y="2530"  fill="rgb(255 255 255)">ansformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constr</text><text x="591" y="2530"  fill="rgb(237 28 36)">uctor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []</text><text x="846" y="2530"  fill="rgb(255 255 255)">; this.transformationKey = []; this.allInsightDataset </text><text x="1008" y="2530"  fill="rgb(24 158 180)">= insightDatasets; } pub</text><text x="1080" y="2530"  fill="rgb(255 255 255)">lic </text><text x="1092" y="2530"  fill="rgb(24 158 180)">validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WH</text><text x="1569" y="2530"  fill="rgb(255 255 255)">ERE&quot; &amp;&amp; key !== &quot;TRANSFORMATION</text><text x="1662" y="2530"  fill="rgb(237 28 36)">S&quot;) { throw new InsightError(); } } this.validateW</text><text x="1812" y="2530"  fill="rgb(255 255 255)">here(q.WHERE); if (q.TR</text><text x="1881" y="2530"  fill="rgb(237 28 36)">ANSFORMAT</text><text x="1908" y="2530"  fill="rgb(255 255 255)">IONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY ===</text><text x="0" y="2535"  fill="rgb(255 255 255)"> &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q</text><text x="597" y="2535"  fill="rgb(237 28 36)">.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at</text><text x="849" y="2535"  fill="rgb(255 255 255)"> least one element } for (let key of q) { this.validat</text><text x="1011" y="2535"  fill="rgb(24 158 180)">eKey(key); this.transf</text><text x="1077" y="2535"  fill="rgb(255 255 255)">orm</text><text x="1086" y="2535"  fill="rgb(24 158 180)">ationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;)</text><text x="1566" y="2535"  fill="rgb(255 255 255)">; if (splittedKey.length !== 2)</text><text x="1659" y="2535"  fill="rgb(237 28 36)"> { throw new InsightError(); } if (!(this.validateI</text><text x="1812" y="2535"  fill="rgb(255 255 255)">dstring(splittedKey[0])</text><text x="1881" y="2535"  fill="rgb(237 28 36)"> &amp;&amp; (this</text><text x="1908" y="2535"  fill="rgb(255 255 255)">.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError()</text><text x="0" y="2540"  fill="rgb(255 255 255)">; // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applyk</text><text x="600" y="2540"  fill="rgb(237 28 36)">ey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (app</text><text x="849" y="2540"  fill="rgb(255 255 255)">lykey.length === 0 || applykey.includes(&quot;_&quot;) || this.tr</text><text x="1014" y="2540"  fill="rgb(24 158 180)">ansformationKey.incl</text><text x="1074" y="2540"  fill="rgb(255 255 255)">ude</text><text x="1083" y="2540"  fill="rgb(24 158 180)">s(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new I</text><text x="1563" y="2540"  fill="rgb(255 255 255)">nsightError(); } let applytoken</text><text x="1656" y="2540"  fill="rgb(237 28 36)">: string = Object.keys(criteria)[0]; if (!this.mtoke</text><text x="1812" y="2540"  fill="rgb(255 255 255)">n.includes(applytoken) </text><text x="1881" y="2540"  fill="rgb(237 28 36)">&amp;&amp; !this</text><text x="1905" y="2540"  fill="rgb(255 255 255)">.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applyto</text><text x="0" y="2545"  fill="rgb(255 255 255)">ken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.</text><text x="606" y="2545"  fill="rgb(237 28 36)">sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightEr</text><text x="852" y="2545"  fill="rgb(255 255 255)">ror(); } } } } public validateOptions(q: any): void { le</text><text x="1020" y="2545"  fill="rgb(24 158 180)">t keys: any[] = Ob</text><text x="1074" y="2545"  fill="rgb(255 255 255)">je</text><text x="1080" y="2545"  fill="rgb(24 158 180)">ct.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { t</text><text x="1557" y="2545"  fill="rgb(255 255 255)">his.validateOrder(q.ORDER); } } </text><text x="1653" y="2545"  fill="rgb(237 28 36)">private validateColumns(q: any): void { if (!q || q.</text><text x="1809" y="2545"  fill="rgb(255 255 255)">length &lt; 1) { throw new </text><text x="1881" y="2545"  fill="rgb(237 28 36)">InsightE</text><text x="1905" y="2545"  fill="rgb(255 255 255)">rror(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQu</text><text x="0" y="2550"  fill="rgb(255 255 255)">ery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightErro</text><text x="609" y="2550"  fill="rgb(237 28 36)">r(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new </text><text x="855" y="2550"  fill="rgb(255 255 255)">InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;</text><text x="1023" y="2550"  fill="rgb(24 158 180)">) { throw new In</text><text x="1071" y="2550"  fill="rgb(255 255 255)">si</text><text x="1077" y="2550"  fill="rgb(24 158 180)">ghtError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQue</text><text x="1554" y="2550"  fill="rgb(255 255 255)">ry.includes(anykey)) { throw new </text><text x="1653" y="2550"  fill="rgb(237 28 36)">InsightError(); } } } } public validateWhere(q: any)</text><text x="1809" y="2550"  fill="rgb(255 255 255)">: void { if (Array.isArr</text><text x="1881" y="2550"  fill="rgb(237 28 36)">ay(q)) </text><text x="1902" y="2550"  fill="rgb(255 255 255)">{ throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(</text><text x="0" y="2555"  fill="rgb(255 255 255)">); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; ca</text><text x="615" y="2555"  fill="rgb(237 28 36)">se &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: thi</text><text x="855" y="2555"  fill="rgb(255 255 255)">s.validateIS(value); break; default: throw new InsightErr</text><text x="1026" y="2555"  fill="rgb(24 158 180)">or(); } } } pr</text><text x="1068" y="2555"  fill="rgb(255 255 255)">i</text><text x="1071" y="2555"  fill="rgb(24 158 180)">vate validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): </text><text x="1551" y="2555"  fill="rgb(255 255 255)">void { if (typeof value !== &quot;obje</text><text x="1650" y="2555"  fill="rgb(237 28 36)">ct&quot;) { throw new InsightError(); } if (Object.keys(va</text><text x="1809" y="2555"  fill="rgb(255 255 255)">lue).length !== 1) { thr</text><text x="1881" y="2555"  fill="rgb(237 28 36)">ow new </text><text x="1902" y="2555"  fill="rgb(255 255 255)">InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let </text><text x="0" y="2560"  fill="rgb(255 255 255)">str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfiel</text><text x="618" y="2560"  fill="rgb(237 28 36)">d)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void</text><text x="858" y="2560"  fill="rgb(255 255 255)"> { if (typeof value !== &quot;object&quot; || Object.keys(value).len</text><text x="1032" y="2560"  fill="rgb(24 158 180)">gth !== 1) </text><text x="1065" y="2560"  fill="rgb(255 255 255)">{</text><text x="1068" y="2560"  fill="rgb(24 158 180)"> throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: s</text><text x="1545" y="2560"  fill="rgb(255 255 255)">tring = mkey[0]; let mfield: strin</text><text x="1647" y="2560"  fill="rgb(237 28 36)">g = mkey[1]; let num: any = Object.values(value)[0]; i</text><text x="1809" y="2560"  fill="rgb(255 255 255)">f ((typeof num !== &quot;num</text><text x="1878" y="2560"  fill="rgb(237 28 36)">ber&quot;) |</text><text x="1899" y="2560"  fill="rgb(255 255 255)">| !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw</text><text x="0" y="2565"  fill="rgb(255 255 255)"> new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset o</text><text x="624" y="2565"  fill="rgb(237 28 36)">f this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuer</text><text x="861" y="2565"  fill="rgb(255 255 255)">y.push(idstring); if (insightDataset.kind === InsightDatas</text><text x="1035" y="2565"  fill="rgb(24 158 180)">etKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } retu</text><text x="1542" y="2565"  fill="rgb(255 255 255)">rn true; } } return false; } else </text><text x="1644" y="2565"  fill="rgb(237 28 36)">{ return this.idInQuery.includes(idstring); } } public</text><text x="1806" y="2565"  fill="rgb(255 255 255)"> getIdInQuery(): string[</text><text x="1878" y="2565"  fill="rgb(237 28 36)">] { ret</text><text x="1899" y="2565"  fill="rgb(255 255 255)">urn this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pas</text><text x="0" y="2570"  fill="rgb(255 255 255)">s&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfi</text><text x="630" y="2570"  fill="rgb(237 28 36)">elds: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;typ</text><text x="861" y="2570"  fill="rgb(255 255 255)">e&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] </text><text x="1041" y="2570"  fill="rgb(24 158 180)">= [&quot;MA</text><text x="1059" y="2570"  fill="rgb(255 255 255)">X</text><text x="1062" y="2570"  fill="rgb(24 158 180)">&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQue</text><text x="1536" y="2570"  fill="rgb(255 255 255)">ry: string[]; // all keys appeared </text><text x="1641" y="2570"  fill="rgb(237 28 36)">in columns after being validated private transformation</text><text x="1806" y="2570"  fill="rgb(255 255 255)">Key: string[]; // keys a</text><text x="1878" y="2570"  fill="rgb(237 28 36)">ppeare</text><text x="1896" y="2570"  fill="rgb(255 255 255)">d in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { thi</text><text x="0" y="2575"  fill="rgb(255 255 255)">s.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } fo</text><text x="636" y="2575"  fill="rgb(237 28 36)">r (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; </text><text x="864" y="2575"  fill="rgb(255 255 255)">key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } t</text><text x="1044" y="2575"  fill="rgb(24 158 180)">his.</text><text x="1056" y="2575"  fill="rgb(255 255 255)">v</text><text x="1059" y="2575"  fill="rgb(24 158 180)">alidateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransform</text><text x="1533" y="2575"  fill="rgb(255 255 255)">ations(q: any): void { if (typeof q</text><text x="1638" y="2575"  fill="rgb(237 28 36)">.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot;</text><text x="1806" y="2575"  fill="rgb(255 255 255)"> || Object.keys(q).lengt</text><text x="1878" y="2575"  fill="rgb(237 28 36)">h !==</text><text x="1893" y="2575"  fill="rgb(255 255 255)"> 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // </text><text x="0" y="2580"  fill="rgb(255 255 255)">q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateK</text><text x="639" y="2580"  fill="rgb(237 28 36)">ey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (spl</text><text x="864" y="2580"  fill="rgb(255 255 255)">ittedKey.length !== 2) { throw new InsightError(); } if (!(this.v</text><text x="1059" y="2580"  fill="rgb(24 158 180)">alidateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } privat</text><text x="1527" y="2580"  fill="rgb(255 255 255)">e validateAPPLY(q: any): void { if (</text><text x="1635" y="2580"  fill="rgb(237 28 36)">!Array.isArray(q)) { throw new InsightError(); // q shoul</text><text x="1806" y="2580"  fill="rgb(255 255 255)">d be an array, and shoul</text><text x="1878" y="2580"  fill="rgb(237 28 36)">d hav</text><text x="1893" y="2580"  fill="rgb(255 255 255)">e at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let</text><text x="0" y="2585"  fill="rgb(255 255 255)"> criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArr</text><text x="645" y="2585"  fill="rgb(237 28 36)">ay(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError</text><text x="867" y="2585"  fill="rgb(255 255 255)">(); } let applytoken: string = Object.keys(criteria)[0]; if (!th</text><text x="1059" y="2585"  fill="rgb(24 158 180)">is.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if</text><text x="1524" y="2585"  fill="rgb(255 255 255)"> (key.length !== 2) { throw new Insi</text><text x="1632" y="2585"  fill="rgb(237 28 36)">ghtError(); } if (this.mtoken.includes(applytoken)) { if </text><text x="1803" y="2585"  fill="rgb(255 255 255)">(!(this.validateIdstring</text><text x="1875" y="2585"  fill="rgb(237 28 36)">(key[</text><text x="1890" y="2585"  fill="rgb(255 255 255)">0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.</text><text x="0" y="2590"  fill="rgb(255 255 255)">includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightErr</text><text x="651" y="2590"  fill="rgb(237 28 36)">or(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOr</text><text x="870" y="2590"  fill="rgb(255 255 255)">der(q.ORDER); } } private validateColumns(q: any): void { if (!</text><text x="1059" y="2590"  fill="rgb(24 158 180)">q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(msk</text><text x="1518" y="2590"  fill="rgb(255 255 255)">ey)) { throw new InsightError(); } } </text><text x="1629" y="2590"  fill="rgb(237 28 36)">else { this.validateKey(mskey); } this.keysInQuery.push(ms</text><text x="1803" y="2590"  fill="rgb(255 255 255)">key); } } private valida</text><text x="1875" y="2590"  fill="rgb(237 28 36)">teOrd</text><text x="1890" y="2590"  fill="rgb(255 255 255)">er(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys ||</text><text x="0" y="2595"  fill="rgb(255 255 255)"> Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightE</text><text x="657" y="2595"  fill="rgb(237 28 36)">rror(); } for (let anykey of keys) { if (!this.keysInQuery.includes(any</text><text x="870" y="2595"  fill="rgb(255 255 255)">key)) { throw new InsightError(); } } } } public validateWhere(q</text><text x="1062" y="2595"  fill="rgb(24 158 180)">: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private val</text><text x="1512" y="2595"  fill="rgb(255 255 255)">idateFilter(q: any): void { if (Object</text><text x="1626" y="2595"  fill="rgb(237 28 36)">.keys(q).length !== 1) { throw new InsightError(); } else {</text><text x="1803" y="2595"  fill="rgb(255 255 255)"> let key: string = Objec</text><text x="1875" y="2595"  fill="rgb(237 28 36)">t.ke</text><text x="1887" y="2595"  fill="rgb(255 255 255)">ys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.va</text><text x="0" y="2600"  fill="rgb(255 255 255)">lidateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.val</text><text x="660" y="2600"  fill="rgb(237 28 36)">idateFilter(value); } private validateIS(value: any): void { if (typeof</text><text x="873" y="2600"  fill="rgb(255 255 255)"> value !== &quot;object&quot;) { throw new InsightError(); } if (Object.key</text><text x="1068" y="2600"  fill="rgb(24 158 180)">s(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new Insi</text><text x="1509" y="2600"  fill="rgb(255 255 255)">ghtError(); } else { let idstring: str</text><text x="1623" y="2600"  fill="rgb(237 28 36)">ing = skey[0]; let sfield: string = skey[1]; let str: any = </text><text x="1803" y="2600"  fill="rgb(255 255 255)">Object.values(value)[0];</text><text x="1875" y="2600"  fill="rgb(237 28 36)"> if </text><text x="1887" y="2600"  fill="rgb(255 255 255)">(typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } }</text><text x="0" y="2605"  fill="rgb(255 255 255)"> } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { </text><text x="666" y="2605"  fill="rgb(237 28 36)">throw new InsightError(); } else { let idstring: string = mkey[0]; let</text><text x="876" y="2605"  fill="rgb(255 255 255)"> mfield: string = mkey[1]; let num: any = Object.values(value)[0];</text><text x="1074" y="2605"  fill="rgb(24 158 180)"> if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private</text><text x="1503" y="2605"  fill="rgb(255 255 255)"> validateANDOR(value: any): void { if (</text><text x="1620" y="2605"  fill="rgb(237 28 36)">!Array.isArray(value) || value.length &lt; 1) { throw new Insig</text><text x="1800" y="2605"  fill="rgb(255 255 255)">htError(); } for (let inn</text><text x="1875" y="2605"  fill="rgb(237 28 36)">erO</text><text x="1884" y="2605"  fill="rgb(255 255 255)">bject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (ins</text><text x="0" y="2610"  fill="rgb(255 255 255)">ightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roomm</text><text x="672" y="2610"  fill="rgb(237 28 36)">fields; this.sfields = this.roomsfields; } return true; } } return fa</text><text x="879" y="2610"  fill="rgb(255 255 255)">lse; } else { return this.idInQuery.includes(idstring); } } public </text><text x="1080" y="2610"  fill="rgb(24 158 180)">getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; ex</text><text x="1497" y="2610"  fill="rgb(255 255 255)">port default class QueryValidator { priv</text><text x="1617" y="2610"  fill="rgb(237 28 36)">ate readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;</text><text x="1800" y="2610"  fill="rgb(255 255 255)">, &quot;audit&quot;, &quot;year&quot;]; priva</text><text x="1875" y="2610"  fill="rgb(237 28 36)">te</text><text x="1881" y="2610"  fill="rgb(255 255 255)"> readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;sh</text><text x="0" y="2615"  fill="rgb(255 255 255)">ortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure </text><text x="678" y="2615"  fill="rgb(237 28 36)">the query only has one id private keysInQuery: string[]; // all key</text><text x="879" y="2615"  fill="rgb(255 255 255)">s appeared in columns after being validated private transformationKey</text><text x="1086" y="2615"  fill="rgb(24 158 180)">: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfiel</text><text x="1491" y="2615"  fill="rgb(255 255 255)">ds: string[]; private sfields: string[]; </text><text x="1614" y="2615"  fill="rgb(237 28 36)">constructor(insightDatasets: InsightDataset[]) { this.idInQuer</text><text x="1800" y="2615"  fill="rgb(255 255 255)">y = []; this.keysInQuery</text><text x="1872" y="2615"  fill="rgb(237 28 36)"> = </text><text x="1881" y="2615"  fill="rgb(255 255 255)">[]; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) {</text><text x="0" y="2620"  fill="rgb(255 255 255)"> if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOption</text><text x="684" y="2620"  fill="rgb(237 28 36)">s(q.OPTIONS); } public validateTransformations(q: any): void { if </text><text x="882" y="2620"  fill="rgb(255 255 255)">(typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || O</text><text x="1092" y="2620"  fill="rgb(24 158 180)">bject.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private valid</text><text x="1485" y="2620"  fill="rgb(255 255 255)">ateGROUP(q: any): void { if (!Array.isArra</text><text x="1611" y="2620"  fill="rgb(237 28 36)">y(q) || q.length &lt; 1) { throw new InsightError(); // q should b</text><text x="1800" y="2620"  fill="rgb(255 255 255)">e an object, and should </text><text x="1872" y="2620"  fill="rgb(237 28 36)">ha</text><text x="1878" y="2620"  fill="rgb(255 255 255)">s at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let sp</text><text x="0" y="2625"  fill="rgb(255 255 255)">littedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { </text><text x="690" y="2625"  fill="rgb(237 28 36)">throw new InsightError(); } } private validateAPPLY(q: any): void</text><text x="885" y="2625"  fill="rgb(255 255 255)"> { if (!Array.isArray(q)) { throw new InsightError(); // q should be an</text><text x="1098" y="2625"  fill="rgb(24 158 180)"> array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule</text><text x="1479" y="2625"  fill="rgb(255 255 255)">).length &gt; 1) { throw new InsightError(); }</text><text x="1608" y="2625"  fill="rgb(237 28 36)"> let applykey: string = Object.keys(applyrule)[0]; let criteria</text><text x="1797" y="2625"  fill="rgb(255 255 255)"> = applyrule[applykey]; i</text><text x="1872" y="2625"  fill="rgb(237 28 36)">f </text><text x="1878" y="2625"  fill="rgb(255 255 255)">(applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(</text><text x="0" y="2630"  fill="rgb(255 255 255)">criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = cr</text><text x="696" y="2630"  fill="rgb(237 28 36)">iteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw ne</text><text x="885" y="2630"  fill="rgb(255 255 255)">w InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.va</text><text x="1104" y="2630"  fill="rgb(24 158 180)">lidateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(ap</text><text x="1473" y="2630"  fill="rgb(255 255 255)">plytoken)) { if (!(this.validateIdstring(key</text><text x="1605" y="2630"  fill="rgb(237 28 36)">[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(</text><text x="1797" y="2630"  fill="rgb(255 255 255)">key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateCol</text><text x="0" y="2635"  fill="rgb(255 255 255)">umns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.t</text><text x="702" y="2635"  fill="rgb(237 28 36)">ransformationKey.includes(mskey)) { throw new InsightError(); </text><text x="888" y="2635"  fill="rgb(255 255 255)">} } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } pr</text><text x="1110" y="2635"  fill="rgb(24 158 180)">ivate validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;</text><text x="1464" y="2635"  fill="rgb(255 255 255)">) { if (!this.keysInQuery.includes(q)) { throw</text><text x="1602" y="2635"  fill="rgb(237 28 36)"> new InsightError(); } } else { if (!q.dir || !q.keys || Object.k</text><text x="1797" y="2635"  fill="rgb(255 255 255)">eys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anyke</text><text x="0" y="2640"  fill="rgb(255 255 255)">y of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFil</text><text x="708" y="2640"  fill="rgb(237 28 36)">ter(q); } } } private validateFilter(q: any): void { if (Obje</text><text x="891" y="2640"  fill="rgb(255 255 255)">ct.keys(q).length !== 1) { throw new InsightError(); } else { let key: strin</text><text x="1119" y="2640"  fill="rgb(24 158 180)">g = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateA</text><text x="1458" y="2640"  fill="rgb(255 255 255)">NDOR(value); break; case &quot;NOT&quot;: this.validateNO</text><text x="1599" y="2640"  fill="rgb(237 28 36)">T(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGT</text><text x="1794" y="2640"  fill="rgb(255 255 255)">LTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } p</text><text x="0" y="2645"  fill="rgb(255 255 255)">rivate validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !</text><text x="714" y="2645"  fill="rgb(237 28 36)">== 2) { throw new InsightError(); } else { let idstring: str</text><text x="894" y="2645"  fill="rgb(255 255 255)">ing = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(val</text><text x="1125" y="2645"  fill="rgb(24 158 180)">ue)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)</text><text x="1452" y="2645"  fill="rgb(255 255 255)">) || !this.validateIdstring(idstring) || !this.s</text><text x="1596" y="2645"  fill="rgb(237 28 36)">fields.includes(sfield)) { throw new InsightError(); } } } } priva</text><text x="1794" y="2645"  fill="rgb(255 255 255)">te validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightErro</text><text x="0" y="2650"  fill="rgb(255 255 255)">r(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightErro</text><text x="720" y="2650"  fill="rgb(237 28 36)">r(); } } } private validateANDOR(value: any): void { if (!</text><text x="894" y="2650"  fill="rgb(255 255 255)">Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let</text><text x="1134" y="2650"  fill="rgb(24 158 180)"> innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: strin</text><text x="1443" y="2650"  fill="rgb(255 255 255)">g): boolean { if (this.idInQuery.length === 0) { f</text><text x="1593" y="2650"  fill="rgb(237 28 36)">or (let insightDataset of this.allInsightDataset) { if (insightData</text><text x="1794" y="2650"  fill="rgb(255 255 255)">set.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfield</text><text x="0" y="2655"  fill="rgb(255 255 255)">s = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsi</text><text x="726" y="2655"  fill="rgb(237 28 36)">ghtFacade&quot;; export default class QueryValidator { private</text><text x="897" y="2655"  fill="rgb(255 255 255)"> readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; pri</text><text x="1140" y="2655"  fill="rgb(24 158 180)">vate readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private rea</text><text x="1434" y="2655"  fill="rgb(255 255 255)">donly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;</text><text x="1590" y="2655"  fill="rgb(237 28 36)">]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;</text><text x="1794" y="2655"  fill="rgb(255 255 255)">, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only ha</text><text x="0" y="2660"  fill="rgb(255 255 255)">s one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; pri</text><text x="732" y="2660"  fill="rgb(237 28 36)">vate mfields: string[]; private sfields: string[]; const</text><text x="900" y="2660"  fill="rgb(255 255 255)">ructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery =</text><text x="1149" y="2660"  fill="rgb(24 158 180)"> []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validat</text><text x="1425" y="2660"  fill="rgb(255 255 255)">e(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { </text><text x="1587" y="2660"  fill="rgb(237 28 36)">throw new InsightError(); } for (let key of Object.keys(q)) { if (ke</text><text x="1791" y="2660"  fill="rgb(255 255 255)">y !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); }</text><text x="0" y="2665"  fill="rgb(255 255 255)"> public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private</text><text x="738" y="2665"  fill="rgb(237 28 36)"> validateGROUP(q: any): void { if (!Array.isArray(q) ||</text><text x="903" y="2665"  fill="rgb(255 255 255)"> q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at</text><text x="1161" y="2665"  fill="rgb(24 158 180)"> least one element } for (let key of q) { this.validateKey(key); this.transformationK</text><text x="1416" y="2665"  fill="rgb(255 255 255)">ey.push(key); // if the key is valid, push it to transfo</text><text x="1584" y="2665"  fill="rgb(237 28 36)">rmationKey } } private validateKey(key: string): void { let splittedK</text><text x="1791" y="2665"  fill="rgb(255 255 255)">ey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new Ins</text><text x="0" y="2670"  fill="rgb(255 255 255)">ightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one e</text><text x="483" y="2670"  fill="rgb(237 28 36)">le</text><text x="489" y="2670"  fill="rgb(255 255 255)">ment } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrul</text><text x="747" y="2670"  fill="rgb(237 28 36)">e).length &gt; 1) { throw new InsightError(); } let app</text><text x="903" y="2670"  fill="rgb(255 255 255)">lykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applyk</text><text x="1170" y="2670"  fill="rgb(24 158 180)">ey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(a</text><text x="1404" y="2670"  fill="rgb(255 255 255)">pplykey)) { throw new InsightError(); } this.transformatio</text><text x="1578" y="2670"  fill="rgb(237 28 36)">nKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteri</text><text x="1791" y="2670"  fill="rgb(255 255 255)">a).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[appl</text><text x="0" y="2675"  fill="rgb(255 255 255)">ytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfield</text><text x="486" y="2675"  fill="rgb(237 28 36)">s</text><text x="489" y="2675"  fill="rgb(255 255 255)">.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(apply</text><text x="753" y="2675"  fill="rgb(237 28 36)">token)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (t</text><text x="906" y="2675"  fill="rgb(255 255 255)">his.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError();</text><text x="1182" y="2675"  fill="rgb(24 158 180)"> } } } } public validateOptions(q: any): void { let keys: any[] = Objec</text><text x="1395" y="2675"  fill="rgb(255 255 255)">t.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; </text><text x="1575" y="2675"  fill="rgb(237 28 36)">key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.</text><text x="1791" y="2675"  fill="rgb(255 255 255)">COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transforma</text><text x="0" y="2680"  fill="rgb(255 255 255)">tionKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void {</text><text x="486" y="2680"  fill="rgb(237 28 36)"> i</text><text x="492" y="2680"  fill="rgb(255 255 255)">f (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (</text><text x="759" y="2680"  fill="rgb(237 28 36)">!this.keysInQuery.includes(q)) { throw new Insight</text><text x="909" y="2680"  fill="rgb(255 255 255)">Error(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightErr</text><text x="1197" y="2680"  fill="rgb(24 158 180)">or(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new I</text><text x="1380" y="2680"  fill="rgb(255 255 255)">nsightError(); } let keys: any = q.keys; if (!Array.isArray(keys</text><text x="1572" y="2680"  fill="rgb(237 28 36)">) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of k</text><text x="1788" y="2680"  fill="rgb(255 255 255)">eys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q);</text><text x="0" y="2685"  fill="rgb(255 255 255)"> } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value:</text><text x="489" y="2685"  fill="rgb(237 28 36)"> a</text><text x="495" y="2685"  fill="rgb(255 255 255)">ny = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value);</text><text x="765" y="2685"  fill="rgb(237 28 36)"> break; case &quot;NOT&quot;: this.validateNOT(value); brea</text><text x="912" y="2685"  fill="rgb(255 255 255)">k; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(va</text><text x="1212" y="2685"  fill="rgb(24 158 180)">lue); break; default: throw new InsightError(); } }</text><text x="1365" y="2685"  fill="rgb(255 255 255)"> } private validateNOT(value: any): void { if (typeof value !== &quot;obj</text><text x="1569" y="2685"  fill="rgb(237 28 36)">ect&quot;) { throw new InsightError(); } this.validateFilter(value); } private</text><text x="1788" y="2685"  fill="rgb(255 255 255)"> validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2)</text><text x="0" y="2690"  fill="rgb(255 255 255)"> { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;str</text><text x="489" y="2690"  fill="rgb(237 28 36)">ing</text><text x="498" y="2690"  fill="rgb(255 255 255)">&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.valida</text><text x="774" y="2690"  fill="rgb(237 28 36)">teIdstring(idstring) || !this.sfields.includes</text><text x="912" y="2690"  fill="rgb(255 255 255)">(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !</text><text x="1233" y="2690"  fill="rgb(24 158 180)">== &quot;object&quot; || Object.keys(value).len</text><text x="1344" y="2690"  fill="rgb(255 255 255)">gth !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(</text><text x="1566" y="2690"  fill="rgb(237 28 36)">value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); }</text><text x="1788" y="2690"  fill="rgb(255 255 255)"> else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError()</text><text x="0" y="2695"  fill="rgb(255 255 255)">; } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this</text><text x="492" y="2695"  fill="rgb(237 28 36)">.v</text><text x="498" y="2695"  fill="rgb(255 255 255)">alidateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this</text><text x="780" y="2695"  fill="rgb(237 28 36)">.idInQuery.length === 0) { for (let insightDa</text><text x="915" y="2695"  fill="rgb(255 255 255)">taset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDat</text><text x="1269" y="2695"  fill="rgb(24 158 180)">aset.kind ==</text><text x="1305" y="2695"  fill="rgb(255 255 255)">= InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this</text><text x="1563" y="2695"  fill="rgb(237 28 36)">.coursesfields; } else { this.mfields = this.roommfields; this.sfields = t</text><text x="1785" y="2695"  fill="rgb(255 255 255)">his.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsig</text><text x="0" y="2700"  fill="rgb(255 255 255)">htFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields</text><text x="492" y="2700"  fill="rgb(237 28 36)">: s</text><text x="501" y="2700"  fill="rgb(255 255 255)">tring[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[]</text><text x="786" y="2700"  fill="rgb(237 28 36)"> = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly</text><text x="918" y="2700"  fill="rgb(255 255 255)"> roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = </text><text x="1560" y="2700"  fill="rgb(237 28 36)">[&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one</text><text x="1785" y="2700"  fill="rgb(255 255 255)"> id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; pr</text><text x="0" y="2705"  fill="rgb(255 255 255)">ivate mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationK</text><text x="495" y="2705"  fill="rgb(237 28 36)">ey </text><text x="504" y="2705"  fill="rgb(255 255 255)">= []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WH</text><text x="795" y="2705"  fill="rgb(237 28 36)">ERE || !q.OPTIONS) { throw new InsightErro</text><text x="921" y="2705"  fill="rgb(255 255 255)">r(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateT</text><text x="1557" y="2705"  fill="rgb(237 28 36)">ransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } publ</text><text x="1785" y="2705"  fill="rgb(255 255 255)">ic validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } priv</text><text x="0" y="2710"  fill="rgb(255 255 255)">ate validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } </text><text x="495" y="2710"  fill="rgb(237 28 36)">for </text><text x="507" y="2710"  fill="rgb(255 255 255)">(let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, </text><text x="801" y="2710"  fill="rgb(237 28 36)">push it to transformationKey } } private </text><text x="924" y="2710"  fill="rgb(255 255 255)">validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(spl</text><text x="1554" y="2710"  fill="rgb(237 28 36)">ittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new Insight</text><text x="1782" y="2710"  fill="rgb(255 255 255)">Error(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(ap</text><text x="0" y="2715"  fill="rgb(255 255 255)">plyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || </text><text x="498" y="2715"  fill="rgb(237 28 36)">appl</text><text x="510" y="2715"  fill="rgb(255 255 255)">ykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.</text><text x="810" y="2715"  fill="rgb(237 28 36)">transformationKey.push(applykey); if (</text><text x="924" y="2715"  fill="rgb(255 255 255)">Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(ap</text><text x="1548" y="2715"  fill="rgb(237 28 36)">plytoken)) { throw new InsightError(); } let key: string[] = criteria[applytok</text><text x="1782" y="2715"  fill="rgb(255 255 255)">en].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includ</text><text x="0" y="2720"  fill="rgb(255 255 255)">es(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public </text><text x="501" y="2720"  fill="rgb(237 28 36)">vali</text><text x="513" y="2720"  fill="rgb(255 255 255)">dateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;CO</text><text x="816" y="2720"  fill="rgb(237 28 36)">LUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw ne</text><text x="927" y="2720"  fill="rgb(255 255 255)">w InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let </text><text x="1545" y="2720"  fill="rgb(237 28 36)">mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformation</text><text x="1782" y="2720"  fill="rgb(255 255 255)">Key.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;strin</text><text x="0" y="2725"  fill="rgb(255 255 255)">g&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if </text><text x="501" y="2725"  fill="rgb(237 28 36)">(q.di</text><text x="516" y="2725"  fill="rgb(255 255 255)">r !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArra</text><text x="825" y="2725"  fill="rgb(237 28 36)">y(keys) || keys.length &lt; 1) { throw</text><text x="930" y="2725"  fill="rgb(255 255 255)"> new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new Insight</text><text x="1542" y="2725"  fill="rgb(237 28 36)">Error(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } }</text><text x="1782" y="2725"  fill="rgb(255 255 255)"> } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateA</text><text x="0" y="2730"  fill="rgb(255 255 255)">NDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); b</text><text x="504" y="2730"  fill="rgb(237 28 36)">reak;</text><text x="519" y="2730"  fill="rgb(255 255 255)"> default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;</text><text x="831" y="2730"  fill="rgb(237 28 36)">object&quot;) { throw new InsightError(</text><text x="933" y="2730"  fill="rgb(255 255 255)">); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } </text><text x="1539" y="2730"  fill="rgb(237 28 36)">let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { </text><text x="1779" y="2730"  fill="rgb(255 255 255)">throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) </text><text x="0" y="2735"  fill="rgb(255 255 255)">|| !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !</text><text x="504" y="2735"  fill="rgb(237 28 36)">== &quot;ob</text><text x="522" y="2735"  fill="rgb(255 255 255)">ject&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(v</text><text x="840" y="2735"  fill="rgb(237 28 36)">alue)[0].split(&quot;_&quot;); if (mkey.le</text><text x="936" y="2735"  fill="rgb(255 255 255)">ngth !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateId</text><text x="1536" y="2735"  fill="rgb(237 28 36)">string(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); }</text><text x="1779" y="2735"  fill="rgb(255 255 255)"> } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): b</text><text x="0" y="2740"  fill="rgb(255 255 255)">oolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if </text><text x="507" y="2740"  fill="rgb(237 28 36)">(insig</text><text x="525" y="2740"  fill="rgb(255 255 255)">htDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.cou</text><text x="846" y="2740"  fill="rgb(237 28 36)">rsesfields; } else { this.mfiel</text><text x="939" y="2740"  fill="rgb(255 255 255)">ds = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQue</text><text x="1530" y="2740"  fill="rgb(237 28 36)">ry; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightF</text><text x="1779" y="2740"  fill="rgb(255 255 255)">acade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly ro</text><text x="0" y="2745"  fill="rgb(255 255 255)">ommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href</text><text x="510" y="2745"  fill="rgb(237 28 36)">&quot;]; pr</text><text x="528" y="2745"  fill="rgb(255 255 255)">ivate readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;</text><text x="855" y="2745"  fill="rgb(237 28 36)">]; private idInQuery: string[</text><text x="942" y="2745"  fill="rgb(255 255 255)">]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformat</text><text x="1527" y="2745"  fill="rgb(237 28 36)">ion, if there is a transformation private allInsightDataset: InsightDataset[]; priv</text><text x="1776" y="2745"  fill="rgb(255 255 255)">ate mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): </text><text x="0" y="2750"  fill="rgb(255 255 255)">void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATI</text><text x="510" y="2750"  fill="rgb(237 28 36)">ONS&quot;) {</text><text x="531" y="2750"  fill="rgb(255 255 255)"> throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformatio</text><text x="864" y="2750"  fill="rgb(237 28 36)">ns(q.TRANSFORMATIONS); } t</text><text x="942" y="2750"  fill="rgb(255 255 255)">his.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new </text><text x="1524" y="2750"  fill="rgb(237 28 36)">InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } privat</text><text x="1776" y="2750"  fill="rgb(255 255 255)">e validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); </text><text x="0" y="2755"  fill="rgb(255 255 255)">// if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2)</text><text x="513" y="2755"  fill="rgb(237 28 36)"> { throw</text><text x="537" y="2755"  fill="rgb(255 255 255)"> new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) ||</text><text x="870" y="2755"  fill="rgb(237 28 36)"> this.sfields.includes(sp</text><text x="945" y="2755"  fill="rgb(255 255 255)">littedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one </text><text x="1521" y="2755"  fill="rgb(237 28 36)">element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(appl</text><text x="1776" y="2755"  fill="rgb(255 255 255)">yrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw </text><text x="0" y="2760"  fill="rgb(255 255 255)">new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: </text><text x="516" y="2760"  fill="rgb(237 28 36)">string =</text><text x="540" y="2760"  fill="rgb(255 255 255)"> Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw n</text><text x="879" y="2760"  fill="rgb(237 28 36)">ew InsightError(); } le</text><text x="948" y="2760"  fill="rgb(255 255 255)">t key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mf</text><text x="1515" y="2760"  fill="rgb(237 28 36)">ields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.include</text><text x="1773" y="2760"  fill="rgb(255 255 255)">s(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let k</text><text x="0" y="2765"  fill="rgb(255 255 255)">ey of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } pri</text><text x="516" y="2765"  fill="rgb(237 28 36)">vate vali</text><text x="543" y="2765"  fill="rgb(255 255 255)">dateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.t</text><text x="888" y="2765"  fill="rgb(237 28 36)">ransformationKey.leng</text><text x="951" y="2765"  fill="rgb(255 255 255)">th &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): v</text><text x="1512" y="2765"  fill="rgb(237 28 36)">oid { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string</text><text x="1773" y="2765"  fill="rgb(255 255 255)">&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys:</text><text x="0" y="2770"  fill="rgb(255 255 255)"> any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new Insi</text><text x="519" y="2770"  fill="rgb(237 28 36)">ghtError(</text><text x="546" y="2770"  fill="rgb(255 255 255)">); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object</text><text x="897" y="2770"  fill="rgb(237 28 36)">.keys(q).length !==</text><text x="954" y="2770"  fill="rgb(255 255 255)"> 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let</text><text x="1509" y="2770"  fill="rgb(237 28 36)"> value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateAN</text><text x="1773" y="2770"  fill="rgb(255 255 255)">DOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: a</text><text x="0" y="2775"  fill="rgb(255 255 255)">ny): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) {</text><text x="522" y="2775"  fill="rgb(237 28 36)"> throw ne</text><text x="549" y="2775"  fill="rgb(255 255 255)">w InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys</text><text x="906" y="2775"  fill="rgb(237 28 36)">(value)[0].split(</text><text x="957" y="2775"  fill="rgb(255 255 255)">&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str </text><text x="1506" y="2775"  fill="rgb(237 28 36)">!== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) </text><text x="1770" y="2775"  fill="rgb(255 255 255)">|| !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError();</text><text x="0" y="2780"  fill="rgb(255 255 255)"> } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mke</text><text x="522" y="2780"  fill="rgb(237 28 36)">y[1]; let n</text><text x="555" y="2780"  fill="rgb(255 255 255)">um: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.in</text><text x="915" y="2780"  fill="rgb(237 28 36)">cludes(mfield))</text><text x="960" y="2780"  fill="rgb(255 255 255)"> { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of va</text><text x="1500" y="2780"  fill="rgb(237 28 36)">lue) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): b</text><text x="1770" y="2780"  fill="rgb(255 255 255)">oolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this</text><text x="0" y="2785"  fill="rgb(255 255 255)">.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return </text><text x="525" y="2785"  fill="rgb(237 28 36)">this.idInQu</text><text x="558" y="2785"  fill="rgb(255 255 255)">ery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightD</text><text x="921" y="2785"  fill="rgb(237 28 36)">atasetKind, In</text><text x="963" y="2785"  fill="rgb(255 255 255)">sightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly c</text><text x="1497" y="2785"  fill="rgb(237 28 36)">oursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly ro</text><text x="1770" y="2785"  fill="rgb(255 255 255)">ommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; pri</text><text x="0" y="2790"  fill="rgb(255 255 255)">vate readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns </text><text x="528" y="2790"  fill="rgb(237 28 36)">after being</text><text x="561" y="2790"  fill="rgb(255 255 255)"> validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private all</text><text x="933" y="2790"  fill="rgb(237 28 36)">InsightData</text><text x="966" y="2790"  fill="rgb(255 255 255)">set: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.t</text><text x="1494" y="2790"  fill="rgb(237 28 36)">ransformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): </text><text x="1770" y="2790"  fill="rgb(255 255 255)">void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.</text><text x="0" y="2795"  fill="rgb(255 255 255)">TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;</text><text x="528" y="2795"  fill="rgb(237 28 36)">undefined&quot; ||</text><text x="567" y="2795"  fill="rgb(255 255 255)"> typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); th</text><text x="942" y="2795"  fill="rgb(237 28 36)">is.valida</text><text x="969" y="2795"  fill="rgb(255 255 255)">teAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at leas</text><text x="1488" y="2795"  fill="rgb(237 28 36)">t one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key);</text><text x="1767" y="2795"  fill="rgb(255 255 255)"> // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0</text><text x="0" y="2800"  fill="rgb(255 255 255)">]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray</text><text x="531" y="2800"  fill="rgb(237 28 36)">(q)) { throw </text><text x="570" y="2800"  fill="rgb(255 255 255)">new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArra</text><text x="951" y="2800"  fill="rgb(237 28 36)">y(appl</text><text x="969" y="2800"  fill="rgb(255 255 255)">yrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applyke</text><text x="1485" y="2800"  fill="rgb(237 28 36)">y.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw</text><text x="1767" y="2800"  fill="rgb(255 255 255)"> new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken</text><text x="0" y="2805"  fill="rgb(255 255 255)">) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if</text><text x="534" y="2805"  fill="rgb(237 28 36)"> (this.mtoken.</text><text x="576" y="2805"  fill="rgb(255 255 255)">includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } e</text><text x="960" y="2805"  fill="rgb(237 28 36)">lse </text><text x="972" y="2805"  fill="rgb(255 255 255)">if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightErr</text><text x="1479" y="2805"  fill="rgb(237 28 36)">or(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let </text><text x="1767" y="2805"  fill="rgb(255 255 255)">key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw ne</text><text x="0" y="2810"  fill="rgb(255 255 255)">w InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.valid</text><text x="534" y="2810"  fill="rgb(237 28 36)">ateKey(mskey); </text><text x="579" y="2810"  fill="rgb(255 255 255)">} this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else</text><text x="969" y="2810"  fill="rgb(237 28 36)"> </text><text x="972" y="2810"  fill="rgb(255 255 255)">if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new</text><text x="1476" y="2810"  fill="rgb(237 28 36)"> InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let key</text><text x="1764" y="2810"  fill="rgb(255 255 255)">s: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isA</text><text x="0" y="2815"  fill="rgb(255 255 255)">rray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !==</text><text x="537" y="2815"  fill="rgb(237 28 36)"> 1) { throw new </text><text x="585" y="2815"  fill="rgb(255 255 255)">InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: </text><text x="1470" y="2815"  fill="rgb(237 28 36)">this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value:</text><text x="1764" y="2815"  fill="rgb(255 255 255)"> any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { t</text><text x="0" y="2820"  fill="rgb(255 255 255)">hrow new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sf</text><text x="540" y="2820"  fill="rgb(237 28 36)">ield: string = s</text><text x="588" y="2820"  fill="rgb(255 255 255)">key[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any):</text><text x="1467" y="2820"  fill="rgb(237 28 36)"> void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(</text><text x="1764" y="2820"  fill="rgb(255 255 255)">); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;nu</text><text x="0" y="2825"  fill="rgb(255 255 255)">mber&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) |</text><text x="543" y="2825"  fill="rgb(237 28 36)">| value.length &lt; </text><text x="594" y="2825"  fill="rgb(255 255 255)">1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.</text><text x="1461" y="2825"  fill="rgb(237 28 36)">idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = t</text><text x="1761" y="2825"  fill="rgb(255 255 255)">his.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string</text><text x="0" y="2830"  fill="rgb(255 255 255)">[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfiel</text><text x="543" y="2830"  fill="rgb(237 28 36)">ds: string[] = [&quot;av</text><text x="600" y="2830"  fill="rgb(255 255 255)">g&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;addre</text><text x="1458" y="2830"  fill="rgb(237 28 36)">ss&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; </text><text x="1761" y="2830"  fill="rgb(255 255 255)">private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys </text><text x="0" y="2835"  fill="rgb(255 255 255)">appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDataset</text><text x="546" y="2835"  fill="rgb(237 28 36)">s: InsightDataset[]</text><text x="603" y="2835"  fill="rgb(255 255 255)">) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !==</text><text x="1452" y="2835"  fill="rgb(237 28 36)"> &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if </text><text x="1761" y="2835"  fill="rgb(255 255 255)">(q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).leng</text><text x="0" y="2840"  fill="rgb(255 255 255)">th !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { thro</text><text x="549" y="2840"  fill="rgb(237 28 36)">w new InsightError()</text><text x="609" y="2840"  fill="rgb(255 255 255)">; // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(</text><text x="1449" y="2840"  fill="rgb(237 28 36)">&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedK</text><text x="1758" y="2840"  fill="rgb(255 255 255)">ey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and shou</text><text x="0" y="2845"  fill="rgb(255 255 255)">ld have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object</text><text x="552" y="2845"  fill="rgb(237 28 36)">.keys(applyrule)[0]; </text><text x="615" y="2845"  fill="rgb(255 255 255)">let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw </text><text x="1443" y="2845"  fill="rgb(237 28 36)">new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applyt</text><text x="1758" y="2845"  fill="rgb(255 255 255)">oken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring</text><text x="0" y="2850"  fill="rgb(255 255 255)">(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(</text><text x="552" y="2850"  fill="rgb(237 28 36)">key[1]) || this.mfields</text><text x="621" y="2850"  fill="rgb(255 255 255)">.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER</text><text x="1437" y="2850"  fill="rgb(237 28 36)">) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { thro</text><text x="1758" y="2850"  fill="rgb(255 255 255)">w new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private valida</text><text x="0" y="2855"  fill="rgb(255 255 255)">teOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { i</text><text x="555" y="2855"  fill="rgb(237 28 36)">f (!q.dir || !q.keys || </text><text x="627" y="2855"  fill="rgb(255 255 255)">Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keys</text><text x="1434" y="2855"  fill="rgb(237 28 36)">InQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Arra</text><text x="1755" y="2855"  fill="rgb(255 255 255)">y.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Objec</text><text x="0" y="2860"  fill="rgb(255 255 255)">t.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;L</text><text x="558" y="2860"  fill="rgb(237 28 36)">T&quot;: case &quot;EQ&quot;: this.valid</text><text x="633" y="2860"  fill="rgb(255 255 255)">ateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: </text><text x="1428" y="2860"  fill="rgb(237 28 36)">any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1</text><text x="1755" y="2860"  fill="rgb(255 255 255)">) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0];</text><text x="0" y="2865"  fill="rgb(255 255 255)"> if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new </text><text x="561" y="2865"  fill="rgb(237 28 36)">InsightError(); } } } } pr</text><text x="639" y="2865"  fill="rgb(255 255 255)">ivate validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstr</text><text x="1422" y="2865"  fill="rgb(237 28 36)">ing: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !=</text><text x="1755" y="2865"  fill="rgb(255 255 255)">= &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let inn</text><text x="0" y="2870"  fill="rgb(255 255 255)">erObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsi</text><text x="561" y="2870"  fill="rgb(237 28 36)">ghtDataset) { if (insightDat</text><text x="645" y="2870"  fill="rgb(255 255 255)">aset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields;</text><text x="1416" y="2870"  fill="rgb(237 28 36)"> } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): </text><text x="1752" y="2870"  fill="rgb(255 255 255)">string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; priva</text><text x="0" y="2875"  fill="rgb(255 255 255)">te readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[</text><text x="564" y="2875"  fill="rgb(237 28 36)">] = [&quot;fullname&quot;, &quot;shortname&quot;,</text><text x="651" y="2875"  fill="rgb(255 255 255)"> &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private key</text><text x="1413" y="2875"  fill="rgb(237 28 36)">sInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; //</text><text x="1752" y="2875"  fill="rgb(255 255 255)"> keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery </text><text x="0" y="2880"  fill="rgb(255 255 255)">= []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key o</text><text x="567" y="2880"  fill="rgb(237 28 36)">f Object.keys(q)) { if (key !=</text><text x="657" y="2880"  fill="rgb(255 255 255)">= &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTr</text><text x="1407" y="2880"  fill="rgb(237 28 36)">ansformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q</text><text x="1752" y="2880"  fill="rgb(255 255 255)">).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should h</text><text x="0" y="2885"  fill="rgb(255 255 255)">as at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: stri</text><text x="570" y="2885"  fill="rgb(237 28 36)">ng): void { let splittedKey: st</text><text x="663" y="2885"  fill="rgb(255 255 255)">ring[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } }</text><text x="1401" y="2885"  fill="rgb(237 28 36)"> private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, a</text><text x="1749" y="2885"  fill="rgb(255 255 255)">nd should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if</text><text x="0" y="2890"  fill="rgb(255 255 255)"> (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteri</text><text x="570" y="2890"  fill="rgb(237 28 36)">a) || Object.keys(criteria).length</text><text x="672" y="2890"  fill="rgb(255 255 255)"> &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(</text><text x="1395" y="2890"  fill="rgb(237 28 36)">&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateI</text><text x="1749" y="2890"  fill="rgb(255 255 255)">dstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new Ins</text><text x="0" y="2895"  fill="rgb(255 255 255)">ightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } }</text><text x="573" y="2895"  fill="rgb(237 28 36)"> this.validateColumns(q.COLUMNS); i</text><text x="678" y="2895"  fill="rgb(255 255 255)">f (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.inc</text><text x="1386" y="2895"  fill="rgb(237 28 36)">ludes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } privat</text><text x="1746" y="2895"  fill="rgb(255 255 255)">e validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { thr</text><text x="0" y="2900"  fill="rgb(255 255 255)">ow new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); </text><text x="576" y="2900"  fill="rgb(237 28 36)">} for (let anykey of keys) { if (!thi</text><text x="687" y="2900"  fill="rgb(255 255 255)">s.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } pr</text><text x="1380" y="2900"  fill="rgb(237 28 36)">ivate validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string</text><text x="1746" y="2900"  fill="rgb(255 255 255)"> = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;I</text><text x="0" y="2905"  fill="rgb(255 255 255)">S&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFil</text><text x="579" y="2905"  fill="rgb(237 28 36)">ter(value); } private validateIS(value</text><text x="693" y="2905"  fill="rgb(255 255 255)">: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { thro</text><text x="1374" y="2905"  fill="rgb(237 28 36)">w new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(va</text><text x="1746" y="2905"  fill="rgb(255 255 255)">lue)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: an</text><text x="0" y="2910"  fill="rgb(255 255 255)">y): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw n</text><text x="582" y="2910"  fill="rgb(237 28 36)">ew InsightError(); } else { let idstring</text><text x="702" y="2910"  fill="rgb(255 255 255)">: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } }</text><text x="1368" y="2910"  fill="rgb(237 28 36)"> } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for</text><text x="1743" y="2910"  fill="rgb(255 255 255)"> (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this</text><text x="0" y="2915"  fill="rgb(255 255 255)">.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields</text><text x="585" y="2915"  fill="rgb(237 28 36)">; this.sfields = this.roomsfields; } retur</text><text x="711" y="2915"  fill="rgb(255 255 255)">n true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsight</text><text x="1359" y="2915"  fill="rgb(237 28 36)">Facade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year</text><text x="1743" y="2915"  fill="rgb(255 255 255)">&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;addre</text><text x="0" y="2920"  fill="rgb(255 255 255)">ss&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the </text><text x="585" y="2920"  fill="rgb(237 28 36)">query only has one id private keysInQuery: st</text><text x="720" y="2920"  fill="rgb(255 255 255)">ring[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; pr</text><text x="1353" y="2920"  fill="rgb(237 28 36)">ivate mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.key</text><text x="1743" y="2920"  fill="rgb(255 255 255)">sInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;</text><text x="0" y="2925"  fill="rgb(255 255 255)">WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q</text><text x="588" y="2925"  fill="rgb(237 28 36)">.OPTIONS); } public validateTransformations(q: </text><text x="729" y="2925"  fill="rgb(255 255 255)">any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } p</text><text x="1344" y="2925"  fill="rgb(237 28 36)">rivate validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, an</text><text x="1740" y="2925"  fill="rgb(255 255 255)">d should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;</text><text x="0" y="2930"  fill="rgb(255 255 255)">); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { th</text><text x="591" y="2930"  fill="rgb(237 28 36)">row new InsightError(); } } private validateAPPLY</text><text x="738" y="2930"  fill="rgb(255 255 255)">(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.k</text><text x="1335" y="2930"  fill="rgb(237 28 36)">eys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[app</text><text x="1740" y="2930"  fill="rgb(255 255 255)">lykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new I</text><text x="0" y="2935"  fill="rgb(255 255 255)">nsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = cri</text><text x="594" y="2935"  fill="rgb(237 28 36)">teria[applytoken].split(&quot;_&quot;); if (key.length !== 2) </text><text x="750" y="2935"  fill="rgb(255 255 255)">{ throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstok</text><text x="1326" y="2935"  fill="rgb(237 28 36)">en.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { thr</text><text x="1740" y="2935"  fill="rgb(255 255 255)">ow new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { thi</text><text x="0" y="2940"  fill="rgb(255 255 255)">s.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.t</text><text x="597" y="2940"  fill="rgb(237 28 36)">ransformationKey.includes(mskey)) { throw new InsightE</text><text x="759" y="2940"  fill="rgb(255 255 255)">rror(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof </text><text x="1317" y="2940"  fill="rgb(237 28 36)">q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !</text><text x="1737" y="2940"  fill="rgb(255 255 255)">== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.</text><text x="0" y="2945"  fill="rgb(255 255 255)">includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFi</text><text x="600" y="2945"  fill="rgb(237 28 36)">lter(q); } } } private validateFilter(q: any): void { if </text><text x="771" y="2945"  fill="rgb(255 255 255)">(Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;:</text><text x="1308" y="2945"  fill="rgb(237 28 36)"> this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); bre</text><text x="1737" y="2945"  fill="rgb(255 255 255)">ak; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void</text><text x="0" y="2950"  fill="rgb(255 255 255)"> { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length</text><text x="603" y="2950"  fill="rgb(237 28 36)"> !== 2) { throw new InsightError(); } else { let idstring: s</text><text x="783" y="2950"  fill="rgb(255 255 255)">tring = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -</text><text x="1299" y="2950"  fill="rgb(237 28 36)">1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTE</text><text x="1737" y="2950"  fill="rgb(255 255 255)">Q(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string </text><text x="0" y="2955"  fill="rgb(255 255 255)">= mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new Insight</text><text x="603" y="2955"  fill="rgb(237 28 36)">Error(); } } } private validateANDOR(value: any): void { if (!Ar</text><text x="795" y="2955"  fill="rgb(255 255 255)">ray.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstrin</text><text x="1287" y="2955"  fill="rgb(237 28 36)">g(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idst</text><text x="1734" y="2955"  fill="rgb(255 255 255)">ring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true</text><text x="0" y="2960"  fill="rgb(255 255 255)">; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./</text><text x="606" y="2960"  fill="rgb(237 28 36)">IInsightFacade&quot;; export default class QueryValidator { private reado</text><text x="810" y="2960"  fill="rgb(255 255 255)">nly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;u</text><text x="1275" y="2960"  fill="rgb(237 28 36)">uid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;n</text><text x="1734" y="2960"  fill="rgb(255 255 255)">ame&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: strin</text><text x="0" y="2965"  fill="rgb(255 255 255)">g[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[</text><text x="609" y="2965"  fill="rgb(237 28 36)">]; private mfields: string[]; private sfields: string[]; constructor(ins</text><text x="825" y="2965"  fill="rgb(255 255 255)">ightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatase</text><text x="1260" y="2965"  fill="rgb(237 28 36)">ts; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot;</text><text x="1731" y="2965"  fill="rgb(255 255 255)"> &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: </text><text x="0" y="2970"  fill="rgb(255 255 255)">any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } </text><text x="612" y="2970"  fill="rgb(237 28 36)">private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) </text><text x="843" y="2970"  fill="rgb(255 255 255)">{ throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key)</text><text x="1245" y="2970"  fill="rgb(237 28 36)">; this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = </text><text x="1731" y="2970"  fill="rgb(255 255 255)">key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAP</text><text x="0" y="2975"  fill="rgb(255 255 255)">PLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys</text><text x="615" y="2975"  fill="rgb(237 28 36)">(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Objec</text><text x="861" y="2975"  fill="rgb(255 255 255)">t.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.tran</text><text x="1227" y="2975"  fill="rgb(237 28 36)">sformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) </text><text x="1731" y="2975"  fill="rgb(255 255 255)">{ throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length </text><text x="0" y="2980"  fill="rgb(255 255 255)">!== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.incl</text><text x="618" y="2980"  fill="rgb(237 28 36)">udes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]</text><text x="882" y="2980"  fill="rgb(255 255 255)">) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): v</text><text x="1203" y="2980"  fill="rgb(237 28 36)">oid { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (</text><text x="1728" y="2980"  fill="rgb(255 255 255)">q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw ne</text><text x="0" y="2985"  fill="rgb(255 255 255)">w InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;stri</text><text x="621" y="2985"  fill="rgb(237 28 36)">ng&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !</text><text x="909" y="2985"  fill="rgb(255 255 255)">q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;</text><text x="1176" y="2985"  fill="rgb(237 28 36)">&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!thi</text><text x="1728" y="2985"  fill="rgb(255 255 255)">s.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: an</text><text x="0" y="2990"  fill="rgb(255 255 255)">y): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateA</text><text x="624" y="2990"  fill="rgb(237 28 36)">NDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.valid</text><text x="945" y="2990"  fill="rgb(255 255 255)">ateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); brea</text><text x="1137" y="2990"  fill="rgb(237 28 36)">k; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(va</text><text x="1725" y="2990"  fill="rgb(255 255 255)">lue: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else</text><text x="0" y="2995"  fill="rgb(255 255 255)"> { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) |</text><text x="627" y="2995"  fill="rgb(237 28 36)">| !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(va</text><text x="1020" y="2995"  fill="rgb(255 255 255)">lue: any</text><text x="1044" y="2995"  fill="rgb(237 28 36)">): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let id</text><text x="1725" y="2995"  fill="rgb(255 255 255)">string: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value</text><text x="0" y="3000"  fill="rgb(255 255 255)">: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boo</text><text x="630" y="3000"  fill="rgb(237 28 36)">lean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields</text><text x="1725" y="3000"  fill="rgb(255 255 255)">; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class Que</text><text x="0" y="3005"  fill="rgb(255 255 255)">ryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly room</text><text x="630" y="3005"  fill="rgb(237 28 36)">mfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private ke</text><text x="1722" y="3005"  fill="rgb(255 255 255)">ysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sf</text><text x="0" y="3010"  fill="rgb(255 255 255)">ields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): voi</text><text x="633" y="3010"  fill="rgb(237 28 36)">d { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTra</text><text x="1722" y="3010"  fill="rgb(255 255 255)">nsformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { i</text><text x="0" y="3015"  fill="rgb(255 255 255)">f (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // i</text><text x="636" y="3015"  fill="rgb(237 28 36)">f the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } p</text><text x="1719" y="3015"  fill="rgb(255 255 255)">rivate validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new In</text><text x="0" y="3020"  fill="rgb(255 255 255)">sightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new I</text><text x="639" y="3020"  fill="rgb(237 28 36)">nsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;)</text><text x="1719" y="3020"  fill="rgb(255 255 255)">; if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.valida</text><text x="0" y="3025"  fill="rgb(255 255 255)">teIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of </text><text x="642" y="3025"  fill="rgb(237 28 36)">keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(m</text><text x="1719" y="3025"  fill="rgb(255 255 255)">skey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.include</text><text x="0" y="3030"  fill="rgb(255 255 255)">s(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = </text><text x="645" y="3030"  fill="rgb(237 28 36)">q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private va</text><text x="1716" y="3030"  fill="rgb(255 255 255)">lidateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: thi</text><text x="0" y="3035"  fill="rgb(255 255 255)">s.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): voi</text><text x="648" y="3035"  fill="rgb(237 28 36)">d { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new Insi</text><text x="1716" y="3035"  fill="rgb(255 255 255)">ghtError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring)</text><text x="0" y="3040"  fill="rgb(255 255 255)"> || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mk</text><text x="651" y="3040"  fill="rgb(237 28 36)">ey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private </text><text x="1713" y="3040"  fill="rgb(255 255 255)">validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length </text><text x="0" y="3045"  fill="rgb(255 255 255)">=== 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfi</text><text x="654" y="3045"  fill="rgb(237 28 36)">elds; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; expor</text><text x="1713" y="3045"  fill="rgb(255 255 255)">t default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;</text><text x="0" y="3050"  fill="rgb(255 255 255)">, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readon</text><text x="657" y="3050"  fill="rgb(237 28 36)">ly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: </text><text x="1710" y="3050"  fill="rgb(255 255 255)">string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPT</text><text x="0" y="3055"  fill="rgb(255 255 255)">IONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATI</text><text x="660" y="3055"  fill="rgb(237 28 36)">ONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGRO</text><text x="1710" y="3055"  fill="rgb(255 255 255)">UP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to </text><text x="0" y="3060"  fill="rgb(255 255 255)">transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.m</text><text x="663" y="3060"  fill="rgb(237 28 36)">fields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length</text><text x="1710" y="3060"  fill="rgb(255 255 255)"> &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transfor</text><text x="0" y="3065"  fill="rgb(255 255 255)">mationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mst</text><text x="666" y="3065"  fill="rgb(237 28 36)">oken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)</text><text x="1707" y="3065"  fill="rgb(255 255 255)">) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot;</text><text x="0" y="3070"  fill="rgb(255 255 255)"> &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(</text><text x="669" y="3070"  fill="rgb(237 28 36)">); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!thi</text><text x="1707" y="3070"  fill="rgb(255 255 255)">s.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(k</text><text x="0" y="3075"  fill="rgb(255 255 255)">eys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw</text><text x="672" y="3075"  fill="rgb(237 28 36)"> new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); </text><text x="1704" y="3075"  fill="rgb(255 255 255)">break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;o</text><text x="0" y="3080"  fill="rgb(255 255 255)">bject&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightE</text><text x="675" y="3080"  fill="rgb(237 28 36)">rror(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.vali</text><text x="1704" y="3080"  fill="rgb(255 255 255)">dateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys</text><text x="0" y="3085"  fill="rgb(255 255 255)">(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.va</text><text x="678" y="3085"  fill="rgb(237 28 36)">lidateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if </text><text x="1701" y="3085"  fill="rgb(255 255 255)">(this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this</text><text x="0" y="3090"  fill="rgb(255 255 255)">.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.id</text><text x="681" y="3090"  fill="rgb(237 28 36)">InQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: s</text><text x="1701" y="3090"  fill="rgb(255 255 255)">tring[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [</text><text x="0" y="3095"  fill="rgb(255 255 255)">&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transfor</text><text x="684" y="3095"  fill="rgb(237 28 36)">mation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (</text><text x="1698" y="3095"  fill="rgb(255 255 255)">!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTra</text><text x="0" y="3100"  fill="rgb(255 255 255)">nsformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new</text><text x="687" y="3100"  fill="rgb(237 28 36)"> InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the k</text><text x="1698" y="3100"  fill="rgb(255 255 255)">ey is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splitt</text><text x="0" y="3105"  fill="rgb(255 255 255)">edKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one e</text><text x="690" y="3105"  fill="rgb(237 28 36)">lement } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new Insigh</text><text x="1695" y="3105"  fill="rgb(255 255 255)">tError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applyto</text><text x="0" y="3110"  fill="rgb(255 255 255)">ken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfield</text><text x="693" y="3110"  fill="rgb(237 28 36)">s.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys</text><text x="1695" y="3110"  fill="rgb(255 255 255)">) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey </text><text x="0" y="3115"  fill="rgb(255 255 255)">of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { </text><text x="696" y="3115"  fill="rgb(237 28 36)">if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.</text><text x="1692" y="3115"  fill="rgb(255 255 255)">keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError()</text><text x="0" y="3120"  fill="rgb(255 255 255)">; } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: a</text><text x="702" y="3120"  fill="rgb(237 28 36)">ny = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void</text><text x="1692" y="3120"  fill="rgb(255 255 255)"> { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey</text><text x="0" y="3125"  fill="rgb(255 255 255)">: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string</text><text x="705" y="3125"  fill="rgb(237 28 36)">&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let m</text><text x="1689" y="3125"  fill="rgb(255 255 255)">key: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(id</text><text x="0" y="3130"  fill="rgb(255 255 255)">string) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.va</text><text x="708" y="3130"  fill="rgb(237 28 36)">lidateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursem</text><text x="1689" y="3130"  fill="rgb(255 255 255)">fields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } imp</text><text x="0" y="3135"  fill="rgb(255 255 255)">ort {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: st</text><text x="711" y="3135"  fill="rgb(237 28 36)">ring[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private re</text><text x="1686" y="3135"  fill="rgb(255 255 255)">adonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if ther</text><text x="0" y="3140"  fill="rgb(255 255 255)">e is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey =</text><text x="714" y="3140"  fill="rgb(237 28 36)"> []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFO</text><text x="1686" y="3140"  fill="rgb(255 255 255)">RMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(</text><text x="0" y="3145"  fill="rgb(255 255 255)">); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (</text><text x="717" y="3145"  fill="rgb(237 28 36)">let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; </text><text x="1683" y="3145"  fill="rgb(255 255 255)">(this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for </text><text x="0" y="3150"  fill="rgb(255 255 255)">(let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || apply</text><text x="720" y="3150"  fill="rgb(237 28 36)">key.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !</text><text x="1683" y="3150"  fill="rgb(255 255 255)">this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(k</text><text x="0" y="3155"  fill="rgb(255 255 255)">ey[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public valid</text><text x="723" y="3155"  fill="rgb(237 28 36)">ateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new Ins</text><text x="1680" y="3155"  fill="rgb(255 255 255)">ightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.i</text><text x="0" y="3160"  fill="rgb(255 255 255)">sArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir</text><text x="726" y="3160"  fill="rgb(237 28 36)"> !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(</text><text x="1680" y="3160"  fill="rgb(255 255 255)">q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Obje</text><text x="0" y="3165"  fill="rgb(255 255 255)">ct.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; d</text><text x="732" y="3165"  fill="rgb(237 28 36)">efault: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw</text><text x="1677" y="3165"  fill="rgb(255 255 255)"> new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { thr</text><text x="0" y="3170"  fill="rgb(255 255 255)">ow new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;obje</text><text x="735" y="3170"  fill="rgb(237 28 36)">ct&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;numbe</text><text x="1674" y="3170"  fill="rgb(255 255 255)">r&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateF</text><text x="0" y="3175"  fill="rgb(255 255 255)">ilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insight</text><text x="738" y="3175"  fill="rgb(237 28 36)">Dataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] </text><text x="1674" y="3175"  fill="rgb(255 255 255)">{ return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[]</text><text x="0" y="3180"  fill="rgb(255 255 255)"> = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; priv</text><text x="741" y="3180"  fill="rgb(237 28 36)">ate readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys ap</text><text x="1671" y="3180"  fill="rgb(255 255 255)">peared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; </text><text x="0" y="3185"  fill="rgb(255 255 255)">this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { t</text><text x="744" y="3185"  fill="rgb(237 28 36)">hrow new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length</text><text x="1671" y="3185"  fill="rgb(255 255 255)"> !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let </text><text x="0" y="3190"  fill="rgb(255 255 255)">key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw </text><text x="747" y="3190"  fill="rgb(237 28 36)">new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and shoul</text><text x="1668" y="3190"  fill="rgb(255 255 255)">d have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey</text><text x="0" y="3195"  fill="rgb(255 255 255)">.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = O</text><text x="753" y="3195"  fill="rgb(237 28 36)">bject.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(</text><text x="1668" y="3195"  fill="rgb(255 255 255)">key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validat</text><text x="0" y="3200"  fill="rgb(255 255 255)">eOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private valida</text><text x="756" y="3200"  fill="rgb(237 28 36)">teColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private valida</text><text x="1665" y="3200"  fill="rgb(255 255 255)">teOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir </text><text x="0" y="3205"  fill="rgb(255 255 255)">!== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError();</text><text x="759" y="3205"  fill="rgb(237 28 36)"> } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Obje</text><text x="1662" y="3205"  fill="rgb(255 255 255)">ct.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; </text><text x="0" y="3210"  fill="rgb(255 255 255)">default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new </text><text x="762" y="3210"  fill="rgb(237 28 36)">InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]</text><text x="1662" y="3210"  fill="rgb(255 255 255)">; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;ob</text><text x="0" y="3215"  fill="rgb(255 255 255)">ject&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let nu</text><text x="765" y="3215"  fill="rgb(237 28 36)">m: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let i</text><text x="1659" y="3215"  fill="rgb(255 255 255)">nnerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insi</text><text x="0" y="3220"  fill="rgb(255 255 255)">ghtDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuer</text><text x="771" y="3220"  fill="rgb(237 28 36)">y.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; pri</text><text x="1659" y="3220"  fill="rgb(255 255 255)">vate readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; </text><text x="0" y="3225"  fill="rgb(255 255 255)">private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being v</text><text x="774" y="3225"  fill="rgb(237 28 36)">alidated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQue</text><text x="1656" y="3225"  fill="rgb(255 255 255)">ry = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;</text><text x="0" y="3230"  fill="rgb(255 255 255)">) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || </text><text x="777" y="3230"  fill="rgb(237 28 36)">typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and shou</text><text x="1653" y="3230"  fill="rgb(255 255 255)">ld has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { </text><text x="0" y="3235"  fill="rgb(255 255 255)">throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw n</text><text x="780" y="3235"  fill="rgb(237 28 36)">ew InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]</text><text x="1653" y="3235"  fill="rgb(255 255 255)">; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: st</text><text x="0" y="3240"  fill="rgb(255 255 255)">ring = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.i</text><text x="786" y="3240"  fill="rgb(237 28 36)">ncludes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw ne</text><text x="1650" y="3240"  fill="rgb(255 255 255)">w InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } priva</text><text x="0" y="3245"  fill="rgb(255 255 255)">te validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); }</text><text x="789" y="3245"  fill="rgb(237 28 36)"> this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2)</text><text x="1647" y="3245"  fill="rgb(255 255 255)"> { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new Insig</text><text x="0" y="3250"  fill="rgb(255 255 255)">htError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new </text><text x="792" y="3250"  fill="rgb(237 28 36)">InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; c</text><text x="1647" y="3250"  fill="rgb(255 255 255)">ase &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) {</text><text x="0" y="3255"  fill="rgb(255 255 255)"> throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = s</text><text x="795" y="3255"  fill="rgb(237 28 36)">key[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(va</text><text x="1644" y="3255"  fill="rgb(255 255 255)">lue: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mke</text><text x="0" y="3260"  fill="rgb(255 255 255)">y[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; </text><text x="801" y="3260"  fill="rgb(237 28 36)">1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring</text><text x="1641" y="3260"  fill="rgb(255 255 255)">) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return</text><text x="0" y="3265"  fill="rgb(255 255 255)"> this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;a</text><text x="804" y="3265"  fill="rgb(237 28 36)">vg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;</text><text x="1641" y="3265"  fill="rgb(255 255 255)">, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in column</text><text x="0" y="3270"  fill="rgb(255 255 255)">s after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[</text><text x="807" y="3270"  fill="rgb(237 28 36)">]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; </text><text x="1638" y="3270"  fill="rgb(255 255 255)">key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP ===</text><text x="0" y="3275"  fill="rgb(255 255 255)"> &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(</text><text x="813" y="3275"  fill="rgb(237 28 36)">); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key</text><text x="1635" y="3275"  fill="rgb(255 255 255)">.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isAr</text><text x="0" y="3280"  fill="rgb(255 255 255)">ray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]</text><text x="816" y="3280"  fill="rgb(237 28 36)">; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { </text><text x="1632" y="3280"  fill="rgb(255 255 255)">throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); </text><text x="0" y="3285"  fill="rgb(255 255 255)">} if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfie</text><text x="819" y="3285"  fill="rgb(237 28 36)">lds.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.O</text><text x="1632" y="3285"  fill="rgb(255 255 255)">RDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.v</text><text x="0" y="3290"  fill="rgb(255 255 255)">alidateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys </text><text x="825" y="3290"  fill="rgb(237 28 36)">|| Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.</text><text x="1629" y="3290"  fill="rgb(255 255 255)">keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).lengt</text><text x="0" y="3295"  fill="rgb(255 255 255)">h !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.v</text><text x="828" y="3295"  fill="rgb(237 28 36)">alidateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(valu</text><text x="1626" y="3295"  fill="rgb(255 255 255)">e: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; </text><text x="0" y="3300"  fill="rgb(255 255 255)">let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } </text><text x="834" y="3300"  fill="rgb(237 28 36)">} private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let ids</text><text x="1623" y="3300"  fill="rgb(255 255 255)">tring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(v</text><text x="0" y="3305"  fill="rgb(255 255 255)">alue) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insig</text><text x="837" y="3305"  fill="rgb(237 28 36)">htDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields;</text><text x="1623" y="3305"  fill="rgb(255 255 255)"> } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly cour</text><text x="0" y="3310"  fill="rgb(255 255 255)">semfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;short</text><text x="840" y="3310"  fill="rgb(237 28 36)">name&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private key</text><text x="1620" y="3310"  fill="rgb(255 255 255)">sInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insigh</text><text x="0" y="3315"  fill="rgb(255 255 255)">tDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (</text><text x="846" y="3315"  fill="rgb(237 28 36)">key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTra</text><text x="1617" y="3315"  fill="rgb(255 255 255)">nsformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; </text><text x="0" y="3320"  fill="rgb(255 255 255)">1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splitted</text><text x="849" y="3320"  fill="rgb(237 28 36)">Key: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } p</text><text x="1614" y="3320"  fill="rgb(255 255 255)">rivate validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: strin</text><text x="0" y="3325"  fill="rgb(255 255 255)">g = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria</text><text x="855" y="3325"  fill="rgb(237 28 36)">).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;)</text><text x="1614" y="3325"  fill="rgb(255 255 255)">; if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields</text><text x="0" y="3330"  fill="rgb(255 255 255)">.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.CO</text><text x="858" y="3330"  fill="rgb(237 28 36)">LUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(</text><text x="1611" y="3330"  fill="rgb(255 255 255)">mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); }</text><text x="0" y="3335"  fill="rgb(255 255 255)"> } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) </text><text x="864" y="3335"  fill="rgb(237 28 36)">{ if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private v</text><text x="1608" y="3335"  fill="rgb(255 255 255)">alidateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;</text><text x="0" y="3340"  fill="rgb(255 255 255)">GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private valid</text><text x="867" y="3340"  fill="rgb(237 28 36)">ateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new In</text><text x="1605" y="3340"  fill="rgb(255 255 255)">sightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield))</text><text x="0" y="3345"  fill="rgb(255 255 255)"> { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { </text><text x="873" y="3345"  fill="rgb(237 28 36)">let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } privat</text><text x="1602" y="3345"  fill="rgb(255 255 255)">e validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of</text><text x="0" y="3350"  fill="rgb(255 255 255)"> this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsf</text><text x="876" y="3350"  fill="rgb(237 28 36)">ields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; ex</text><text x="1599" y="3350"  fill="rgb(255 255 255)">port default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsf</text><text x="0" y="3355"  fill="rgb(255 255 255)">ields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private </text><text x="882" y="3355"  fill="rgb(237 28 36)">keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields</text><text x="1599" y="3355"  fill="rgb(255 255 255)">: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); }</text><text x="0" y="3360"  fill="rgb(255 255 255)"> for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTr</text><text x="885" y="3360"  fill="rgb(237 28 36)">ansformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validate</text><text x="1596" y="3360"  fill="rgb(255 255 255)">GROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private valid</text><text x="0" y="3365"  fill="rgb(255 255 255)">ateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } pri</text><text x="891" y="3365"  fill="rgb(237 28 36)">vate validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).le</text><text x="1593" y="3365"  fill="rgb(255 255 255)">ngth &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array</text><text x="0" y="3370"  fill="rgb(255 255 255)">.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); i</text><text x="894" y="3370"  fill="rgb(237 28 36)">f (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applyto</text><text x="1590" y="3370"  fill="rgb(255 255 255)">ken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new In</text><text x="0" y="3375"  fill="rgb(255 255 255)">sightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)</text><text x="900" y="3375"  fill="rgb(237 28 36)">) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if </text><text x="1587" y="3375"  fill="rgb(255 255 255)">(!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw ne</text><text x="0" y="3380"  fill="rgb(255 255 255)">w InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFi</text><text x="906" y="3380"  fill="rgb(237 28 36)">lter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(val</text><text x="1584" y="3380"  fill="rgb(255 255 255)">ue); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError();</text><text x="0" y="3385"  fill="rgb(255 255 255)"> } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(</text><text x="909" y="3385"  fill="rgb(237 28 36)">); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !thi</text><text x="1581" y="3385"  fill="rgb(255 255 255)">s.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.len</text><text x="0" y="3390"  fill="rgb(255 255 255)">gth !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDO</text><text x="915" y="3390"  fill="rgb(237 28 36)">R(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean</text><text x="1578" y="3390"  fill="rgb(255 255 255)"> { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfiel</text><text x="0" y="3395"  fill="rgb(255 255 255)">ds = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default clas</text><text x="921" y="3395"  fill="rgb(237 28 36)">s QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfi</text><text x="1575" y="3395"  fill="rgb(255 255 255)">elds: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string</text><text x="0" y="3400"  fill="rgb(255 255 255)">[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; privat</text><text x="924" y="3400"  fill="rgb(237 28 36)">e sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void</text><text x="1572" y="3400"  fill="rgb(255 255 255)"> { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } </text><text x="0" y="3405"  fill="rgb(255 255 255)">this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void {</text><text x="930" y="3405"  fill="rgb(237 28 36)"> if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // </text><text x="1569" y="3405"  fill="rgb(255 255 255)">if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(</text><text x="0" y="3410"  fill="rgb(255 255 255)">splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new In</text><text x="936" y="3410"  fill="rgb(237 28 36)">sightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw ne</text><text x="1566" y="3410"  fill="rgb(255 255 255)">w InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); }</text><text x="0" y="3415"  fill="rgb(255 255 255)"> let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validat</text><text x="939" y="3415"  fill="rgb(237 28 36)">eIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let ke</text><text x="1563" y="3415"  fill="rgb(255 255 255)">y of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.</text><text x="0" y="3420"  fill="rgb(255 255 255)">length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q</text><text x="945" y="3420"  fill="rgb(237 28 36)">)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys:</text><text x="1560" y="3420"  fill="rgb(255 255 255)"> any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).lengt</text><text x="0" y="3425"  fill="rgb(255 255 255)">h !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.val</text><text x="951" y="3425"  fill="rgb(237 28 36)">idateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: </text><text x="1557" y="3425"  fill="rgb(255 255 255)">any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].</text><text x="0" y="3430"  fill="rgb(255 255 255)">split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !th</text><text x="957" y="3430"  fill="rgb(237 28 36)">is.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(</text><text x="1554" y="3430"  fill="rgb(255 255 255)">); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(m</text><text x="0" y="3435"  fill="rgb(255 255 255)">field)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { </text><text x="963" y="3435"  fill="rgb(237 28 36)">for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = </text><text x="1548" y="3435"  fill="rgb(255 255 255)">this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDataset</text><text x="0" y="3440"  fill="rgb(255 255 255)">Kind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]</text><text x="966" y="3440"  fill="rgb(237 28 36)">; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]</text><text x="1545" y="3440"  fill="rgb(255 255 255)">; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allIn</text><text x="0" y="3445"  fill="rgb(255 255 255)">sightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { thro</text><text x="972" y="3445"  fill="rgb(237 28 36)">w new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); </text><text x="1542" y="3445"  fill="rgb(255 255 255)">if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); t</text><text x="0" y="3450"  fill="rgb(255 255 255)">his.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformation</text><text x="978" y="3450"  fill="rgb(237 28 36)">Key } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splitt</text><text x="1539" y="3450"  fill="rgb(255 255 255)">edKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.is</text><text x="0" y="3455"  fill="rgb(255 255 255)">Array(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(a</text><text x="984" y="3455"  fill="rgb(237 28 36)">pplykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(ap</text><text x="1536" y="3455"  fill="rgb(255 255 255)">plytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError()</text><text x="0" y="3460"  fill="rgb(255 255 255)">; } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER</text><text x="990" y="3460"  fill="rgb(237 28 36)">&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) </text><text x="1530" y="3460"  fill="rgb(255 255 255)">{ throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError</text><text x="0" y="3465"  fill="rgb(255 255 255)">(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length </text><text x="996" y="3465"  fill="rgb(237 28 36)">&lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if</text><text x="1527" y="3465"  fill="rgb(255 255 255)"> (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { cas</text><text x="0" y="3470"  fill="rgb(255 255 255)">e &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new In</text><text x="1002" y="3470"  fill="rgb(237 28 36)">sightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).lengt</text><text x="1524" y="3470"  fill="rgb(255 255 255)">h !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if </text><text x="0" y="3475"  fill="rgb(255 255 255)">((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); i</text><text x="1008" y="3475"  fill="rgb(237 28 36)">f (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((type</text><text x="1518" y="3475"  fill="rgb(255 255 255)">of num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private val</text><text x="0" y="3480"  fill="rgb(255 255 255)">idateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { t</text><text x="1014" y="3480"  fill="rgb(237 28 36)">his.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdIn</text><text x="1515" y="3480"  fill="rgb(255 255 255)">Query(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;ti</text><text x="0" y="3485"  fill="rgb(255 255 255)">tle&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: </text><text x="1023" y="3485"  fill="rgb(237 28 36)">string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: st</text><text x="1512" y="3485"  fill="rgb(255 255 255)">ring[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDat</text><text x="0" y="3490"  fill="rgb(255 255 255)">asets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS)</text><text x="1029" y="3490"  fill="rgb(237 28 36)">; } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || O</text><text x="1506" y="3490"  fill="rgb(255 255 255)">bject.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); </text><text x="0" y="3495"  fill="rgb(255 255 255)">this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.include</text><text x="1035" y="3495"  fill="rgb(237 28 36)">s(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be</text><text x="1503" y="3495"  fill="rgb(255 255 255)"> an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformati</text><text x="0" y="3500"  fill="rgb(255 255 255)">onKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); }</text><text x="1041" y="3500"  fill="rgb(237 28 36)"> let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(</text><text x="1497" y="3500"  fill="rgb(255 255 255)">this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: </text><text x="0" y="3505"  fill="rgb(255 255 255)">any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.len</text><text x="1050" y="3505"  fill="rgb(237 28 36)">gth &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(msk</text><text x="1491" y="3505"  fill="rgb(255 255 255)">ey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { thr</text><text x="0" y="3510"  fill="rgb(255 255 255)">ow new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !==</text><text x="1056" y="3510"  fill="rgb(237 28 36)"> 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else {</text><text x="1488" y="3510"  fill="rgb(255 255 255)"> let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); </text><text x="0" y="3515"  fill="rgb(255 255 255)">} } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_</text><text x="1065" y="3515"  fill="rgb(237 28 36)">&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any </text><text x="1482" y="3515"  fill="rgb(255 255 255)">= Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length </text><text x="0" y="3520"  fill="rgb(255 255 255)">!== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { </text><text x="1071" y="3520"  fill="rgb(237 28 36)">throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new In</text><text x="1476" y="3520"  fill="rgb(255 255 255)">sightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetK</text><text x="0" y="3525"  fill="rgb(255 255 255)">ind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, Insight</text><text x="1080" y="3525"  fill="rgb(237 28 36)">Error} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;</text><text x="1470" y="3525"  fill="rgb(255 255 255)">fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] =</text><text x="0" y="3530"  fill="rgb(255 255 255)"> [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: In</text><text x="1089" y="3530"  fill="rgb(237 28 36)">sightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.id</text><text x="1467" y="3530"  fill="rgb(255 255 255)">InQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } t</text><text x="0" y="3535"  fill="rgb(255 255 255)">his.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q</text><text x="1098" y="3535"  fill="rgb(237 28 36)">.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q </text><text x="1461" y="3535"  fill="rgb(255 255 255)">should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(t</text><text x="0" y="3540"  fill="rgb(255 255 255)">his.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || O</text><text x="1104" y="3540"  fill="rgb(237 28 36)">bject.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; le</text><text x="1452" y="3540"  fill="rgb(255 255 255)">t criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if</text><text x="0" y="3545"  fill="rgb(255 255 255)"> (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.msto</text><text x="1113" y="3545"  fill="rgb(237 28 36)">ken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfiel</text><text x="1446" y="3545"  fill="rgb(255 255 255)">ds.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { </text><text x="0" y="3550"  fill="rgb(255 255 255)">if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === </text><text x="1125" y="3550"  fill="rgb(237 28 36)">&quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.ke</text><text x="1440" y="3550"  fill="rgb(255 255 255)">ys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateW</text><text x="0" y="3555"  fill="rgb(255 255 255)">here(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.valida</text><text x="1134" y="3555"  fill="rgb(237 28 36)">teANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: </text><text x="1434" y="3555"  fill="rgb(255 255 255)">this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Ob</text><text x="0" y="3560"  fill="rgb(255 255 255)">ject.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) |</text><text x="1146" y="3560"  fill="rgb(237 28 36)">| !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightErro</text><text x="1425" y="3560"  fill="rgb(255 255 255)">r(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(</text><text x="0" y="3565"  fill="rgb(255 255 255)">value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boole</text><text x="1155" y="3565"  fill="rgb(237 28 36)">an { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDatas</text><text x="1416" y="3565"  fill="rgb(255 255 255)">et) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring);</text><text x="0" y="3570"  fill="rgb(255 255 255)"> } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields</text><text x="1170" y="3570"  fill="rgb(237 28 36)">: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = </text><text x="1407" y="3570"  fill="rgb(255 255 255)">[&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private tra</text><text x="0" y="3575"  fill="rgb(255 255 255)">nsformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q</text><text x="1182" y="3575"  fill="rgb(237 28 36)"> || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key o</text><text x="1398" y="3575"  fill="rgb(255 255 255)">f Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === </text><text x="0" y="3580"  fill="rgb(255 255 255)">&quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is v</text><text x="1197" y="3580"  fill="rgb(237 28 36)">alid, push it to transformationKey } } private validateKey(key:</text><text x="1386" y="3580"  fill="rgb(255 255 255)"> string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError();</text><text x="0" y="3585"  fill="rgb(255 255 255)"> // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } th</text><text x="1215" y="3585"  fill="rgb(237 28 36)">is.transformationKey.push(applykey); if (Array.isArr</text><text x="1371" y="3585"  fill="rgb(255 255 255)">ay(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytok</text><text x="0" y="3590"  fill="rgb(255 255 255)">en)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUM</text><text x="1239" y="3590"  fill="rgb(237 28 36)">NS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new I</text><text x="1350" y="3590"  fill="rgb(255 255 255)">nsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQue</text><text x="0" y="3595"  fill="rgb(255 255 255)">ry.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || key</text><text x="1281" y="3595"  fill="rgb(237 28 36)">s.length </text><text x="1308" y="3595"  fill="rgb(255 255 255)">&lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError()</text><text x="0" y="3600"  fill="rgb(255 255 255)">; } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let s</text><text x="0" y="3605"  fill="rgb(255 255 255)">tr: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw </text><text x="0" y="3610"  fill="rgb(255 255 255)">new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass</text><text x="0" y="3615"  fill="rgb(255 255 255)">&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this</text><text x="0" y="3620"  fill="rgb(255 255 255)">.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q</text><text x="0" y="3625"  fill="rgb(255 255 255)"> should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let </text><text x="0" y="3630"  fill="rgb(255 255 255)">criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.i</text><text x="0" y="3635"  fill="rgb(255 255 255)">ncludes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || </text><text x="0" y="3640"  fill="rgb(255 255 255)">Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.val</text><text x="0" y="3645"  fill="rgb(255 255 255)">idateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } </text><text x="0" y="3650"  fill="rgb(255 255 255)">} private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insi</text><text x="0" y="3655"  fill="rgb(255 255 255)">ghtDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;sho</text><text x="0" y="3660"  fill="rgb(255 255 255)">rtname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { </text><text x="0" y="3665"  fill="rgb(255 255 255)">if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let spl</text><text x="0" y="3670"  fill="rgb(255 255 255)">ittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(c</text><text x="0" y="3675"  fill="rgb(255 255 255)">riteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColu</text><text x="0" y="3680"  fill="rgb(255 255 255)">mns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey</text><text x="0" y="3685"  fill="rgb(255 255 255)"> of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } pr</text><text x="0" y="3690"  fill="rgb(255 255 255)">ivate validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError</text><text x="0" y="3695"  fill="rgb(255 255 255)">(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields</text><text x="0" y="3700"  fill="rgb(255 255 255)"> = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has</text><text x="0" y="3705"  fill="rgb(255 255 255)"> one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } </text><text x="0" y="3710"  fill="rgb(255 255 255)">public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new Insi</text><text x="0" y="3715"  fill="rgb(255 255 255)">ghtError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[apply</text><text x="0" y="3720"  fill="rgb(255 255 255)">token].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformat</text><text x="0" y="3725"  fill="rgb(255 255 255)">ionKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); </text><text x="0" y="3730"  fill="rgb(255 255 255)">} } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) </text><text x="0" y="3735"  fill="rgb(255 255 255)">{ throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError();</text><text x="0" y="3740"  fill="rgb(255 255 255)"> } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsigh</text><text x="0" y="3745"  fill="rgb(255 255 255)">tFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; pri</text><text x="0" y="3750"  fill="rgb(255 255 255)">vate mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } priva</text><text x="0" y="3755"  fill="rgb(255 255 255)">te validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(app</text><text x="0" y="3760"  fill="rgb(255 255 255)">lyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.include</text><text x="0" y="3765"  fill="rgb(255 255 255)">s(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string</text><text x="0" y="3770"  fill="rgb(255 255 255)">&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateAN</text><text x="0" y="3775"  fill="rgb(255 255 255)">DOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) |</text><text x="0" y="3780"  fill="rgb(255 255 255)">| !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): bo</text><text x="0" y="3785"  fill="rgb(255 255 255)">olean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roo</text><text x="0" y="3790"  fill="rgb(255 255 255)">mmfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): v</text><text x="0" y="3795"  fill="rgb(255 255 255)">oid { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); /</text><text x="0" y="3800"  fill="rgb(255 255 255)">/ if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw n</text><text x="0" y="3805"  fill="rgb(255 255 255)">ew InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let ke</text><text x="0" y="3810"  fill="rgb(255 255 255)">y of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: </text><text x="0" y="3815"  fill="rgb(255 255 255)">any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: an</text><text x="0" y="3820"  fill="rgb(255 255 255)">y): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); </text><text x="0" y="3825"  fill="rgb(255 255 255)">} let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.</text><text x="0" y="3830"  fill="rgb(255 255 255)">coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; priv</text><text x="0" y="3835"  fill="rgb(255 255 255)">ate readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.T</text><text x="0" y="3840"  fill="rgb(255 255 255)">RANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]</text><text x="0" y="3845"  fill="rgb(255 255 255)">) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken)</text><text x="0" y="3850"  fill="rgb(255 255 255)"> &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new</text><text x="0" y="3855"  fill="rgb(255 255 255)"> InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isAr</text><text x="0" y="3860"  fill="rgb(255 255 255)">ray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { th</text><text x="0" y="3865"  fill="rgb(255 255 255)">row new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;num</text><text x="0" y="3870"  fill="rgb(255 255 255)">ber&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[</text><text x="0" y="3875"  fill="rgb(255 255 255)">] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys a</text><text x="0" y="3880"  fill="rgb(255 255 255)">ppeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).lengt</text><text x="0" y="3885"  fill="rgb(255 255 255)">h !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and shoul</text><text x="0" y="3890"  fill="rgb(255 255 255)">d have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(</text><text x="0" y="3895"  fill="rgb(255 255 255)">key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validat</text><text x="0" y="3900"  fill="rgb(255 255 255)">eOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object</text><text x="0" y="3905"  fill="rgb(255 255 255)">.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; </text><text x="0" y="3910"  fill="rgb(255 255 255)">if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let inne</text><text x="0" y="3915"  fill="rgb(255 255 255)">rObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; privat</text><text x="0" y="3920"  fill="rgb(255 255 255)">e readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery =</text><text x="0" y="3925"  fill="rgb(255 255 255)"> []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should ha</text><text x="0" y="3930"  fill="rgb(255 255 255)">s at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if </text><text x="0" y="3935"  fill="rgb(255 255 255)">(applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new Insi</text><text x="0" y="3940"  fill="rgb(255 255 255)">ghtError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { thro</text><text x="0" y="3945"  fill="rgb(255 255 255)">w new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS</text><text x="0" y="3950"  fill="rgb(255 255 255)">&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any</text><text x="0" y="3955"  fill="rgb(255 255 255)">): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.</text><text x="0" y="3960"  fill="rgb(255 255 255)">idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;addres</text><text x="0" y="3965"  fill="rgb(255 255 255)">s&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;W</text><text x="0" y="3970"  fill="rgb(255 255 255)">HERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;)</text><text x="0" y="3975"  fill="rgb(255 255 255)">; if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new In</text><text x="0" y="3980"  fill="rgb(255 255 255)">sightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this</text><text x="0" y="3985"  fill="rgb(255 255 255)">.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.i</text><text x="0" y="3990"  fill="rgb(255 255 255)">ncludes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void </text><text x="0" y="3995"  fill="rgb(255 255 255)">{ if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string =</text><text x="0" y="4000"  fill="rgb(255 255 255)"> mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true;</text><text x="0" y="4005"  fill="rgb(255 255 255)"> } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string</text><text x="0" y="4010"  fill="rgb(255 255 255)">[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: a</text><text x="0" y="4015"  fill="rgb(255 255 255)">ny): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPP</text><text x="0" y="4020"  fill="rgb(255 255 255)">LY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !</text><text x="0" y="4025"  fill="rgb(255 255 255)">== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new</text><text x="0" y="4030"  fill="rgb(255 255 255)"> InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any</text><text x="0" y="4035"  fill="rgb(255 255 255)">): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else </text><text x="0" y="4040"  fill="rgb(255 255 255)">{ let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value:</text><text x="0" y="4045"  fill="rgb(255 255 255)"> any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class Quer</text><text x="0" y="4050"  fill="rgb(255 255 255)">yValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfi</text><text x="0" y="4055"  fill="rgb(255 255 255)">elds: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if</text><text x="0" y="4060"  fill="rgb(255 255 255)"> (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new Ins</text><text x="0" y="4065"  fill="rgb(255 255 255)">ightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validat</text><text x="0" y="4070"  fill="rgb(255 255 255)">eIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes</text><text x="0" y="4075"  fill="rgb(255 255 255)">(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this</text><text x="0" y="4080"  fill="rgb(255 255 255)">.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) </text><text x="0" y="4085"  fill="rgb(255 255 255)">|| !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length =</text><text x="0" y="4090"  fill="rgb(255 255 255)">== 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;,</text><text x="0" y="4095"  fill="rgb(255 255 255)"> &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTI</text><text x="0" y="4100"  fill="rgb(255 255 255)">ONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTransformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to t</text><text x="0" y="4105"  fill="rgb(255 255 255)">ransformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splittedKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transform</text><text x="0" y="4110"  fill="rgb(255 255 255)">ationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytoken)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; </text><text x="0" y="4115"  fill="rgb(255 255 255)">&amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey of q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(ke</text><text x="0" y="4120"  fill="rgb(255 255 255)">ys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else { if (Object.keys(q).length !== 0) { this.validateFilter(q); } } } private validateFilter(q: any): void { if (Object.keys(q).length !== 1) { throw new InsightError(); } else { let key: string = Object.keys(q)[0]; let value: any = Object.values(q)[0]; switch (key) { case &quot;AND&quot;: case &quot;OR&quot;: this.validateANDOR(value); break; case &quot;NOT&quot;: this.validateNOT(value); break; case &quot;GT&quot;: case &quot;LT&quot;: case &quot;EQ&quot;: this.validateGTLTEQ(value); break; case &quot;IS&quot;: this.validateIS(value); break; default: throw new InsightError(); } } } private validateNOT(value: any): void { if (typeof value !== &quot;ob</text><text x="0" y="4125"  fill="rgb(255 255 255)">ject&quot;) { throw new InsightError(); } this.validateFilter(value); } private validateIS(value: any): void { if (typeof value !== &quot;object&quot;) { throw new InsightError(); } if (Object.keys(value).length !== 1) { throw new InsightError(); } let skey: string[] = Object.keys(value)[0].split(&quot;_&quot;); if (skey.length !== 2) { throw new InsightError(); } else { let idstring: string = skey[0]; let sfield: string = skey[1]; let str: any = Object.values(value)[0]; if (typeof str !== &quot;string&quot;) { throw new InsightError(); } else { if ((str.slice(1, -1).includes(&quot;*&quot;)) || !this.validateIdstring(idstring) || !this.sfields.includes(sfield)) { throw new InsightError(); } } } } private validateGTLTEQ(value: any): void { if (typeof value !== &quot;object&quot; || Object.keys(value).length !== 1) { throw new InsightError(); } let mkey: string[] = Object.keys(</text><text x="0" y="4130"  fill="rgb(255 255 255)">value)[0].split(&quot;_&quot;); if (mkey.length !== 2) { throw new InsightError(); } else { let idstring: string = mkey[0]; let mfield: string = mkey[1]; let num: any = Object.values(value)[0]; if ((typeof num !== &quot;number&quot;) || !this.validateIdstring(idstring) || !this.mfields.includes(mfield)) { throw new InsightError(); } } } private validateANDOR(value: any): void { if (!Array.isArray(value) || value.length &lt; 1) { throw new InsightError(); } for (let innerObject of value) { this.validateFilter(innerObject); } } private validateIdstring(idstring: string): boolean { if (this.idInQuery.length === 0) { for (let insightDataset of this.allInsightDataset) { if (insightDataset.id === idstring) { this.idInQuery.push(idstring); if (insightDataset.kind === InsightDatasetKind.Courses) { this.mfields = this.coursemfields; this.sfields = this.</text><text x="0" y="4135"  fill="rgb(255 255 255)">coursesfields; } else { this.mfields = this.roommfields; this.sfields = this.roomsfields; } return true; } } return false; } else { return this.idInQuery.includes(idstring); } } public getIdInQuery(): string[] { return this.idInQuery; } } import {InsightDataset, InsightDatasetKind, InsightError} from &quot;./IInsightFacade&quot;; export default class QueryValidator { private readonly coursemfields: string[] = [&quot;avg&quot;, &quot;pass&quot;, &quot;fail&quot;, &quot;audit&quot;, &quot;year&quot;]; private readonly coursesfields: string[] = [&quot;dept&quot;, &quot;id&quot;, &quot;instructor&quot;, &quot;title&quot;, &quot;uuid&quot;]; private readonly roommfields: string[] = [&quot;lat&quot;, &quot;lon&quot;, &quot;seats&quot;]; private readonly roomsfields: string[] = [&quot;fullname&quot;, &quot;shortname&quot;, &quot;number&quot; , &quot;name&quot;, &quot;address&quot;, &quot;type&quot;, &quot;furniture&quot;, &quot;href&quot;]; private readonly mtoken: string[] = [&quot;MAX&quot;, &quot;MIN&quot;, &quot;AVG&quot;, &quot;SUM&quot;]; private readonly mstoken: string[] = [&quot;</text><text x="0" y="4140"  fill="rgb(255 255 255)">COUNT&quot;]; private idInQuery: string[]; // make sure the query only has one id private keysInQuery: string[]; // all keys appeared in columns after being validated private transformationKey: string[]; // keys appeared in transformation, if there is a transformation private allInsightDataset: InsightDataset[]; private mfields: string[]; private sfields: string[]; constructor(insightDatasets: InsightDataset[]) { this.idInQuery = []; this.keysInQuery = []; this.transformationKey = []; this.allInsightDataset = insightDatasets; } public validate(q: any): void { if (!q || !q.WHERE || !q.OPTIONS) { throw new InsightError(); } for (let key of Object.keys(q)) { if (key !== &quot;OPTIONS&quot; &amp;&amp; key !== &quot;WHERE&quot; &amp;&amp; key !== &quot;TRANSFORMATIONS&quot;) { throw new InsightError(); } } this.validateWhere(q.WHERE); if (q.TRANSFORMATIONS) { this.validateTran</text><text x="0" y="4145"  fill="rgb(255 255 255)">sformations(q.TRANSFORMATIONS); } this.validateOptions(q.OPTIONS); } public validateTransformations(q: any): void { if (typeof q.GROUP === &quot;undefined&quot; || typeof q.APPLY === &quot;undefined&quot; || Object.keys(q).length !== 2) { throw new InsightError(); } this.validateGROUP(q.GROUP); this.validateAPPLY(q.APPLY); } private validateGROUP(q: any): void { if (!Array.isArray(q) || q.length &lt; 1) { throw new InsightError(); // q should be an object, and should has at least one element } for (let key of q) { this.validateKey(key); this.transformationKey.push(key); // if the key is valid, push it to transformationKey } } private validateKey(key: string): void { let splittedKey: string[] = key.split(&quot;_&quot;); if (splittedKey.length !== 2) { throw new InsightError(); } if (!(this.validateIdstring(splittedKey[0]) &amp;&amp; (this.mfields.includes(splitte</text><text x="0" y="4150"  fill="rgb(255 255 255)">dKey[1]) || this.sfields.includes(splittedKey[1])))) { throw new InsightError(); } } private validateAPPLY(q: any): void { if (!Array.isArray(q)) { throw new InsightError(); // q should be an array, and should have at least one element } for (let applyrule of q) { if (Array.isArray(applyrule) || Object.keys(applyrule).length &gt; 1) { throw new InsightError(); } let applykey: string = Object.keys(applyrule)[0]; let criteria = applyrule[applykey]; if (applykey.length === 0 || applykey.includes(&quot;_&quot;) || this.transformationKey.includes(applykey)) { throw new InsightError(); } this.transformationKey.push(applykey); if (Array.isArray(criteria) || Object.keys(criteria).length &gt; 1) { throw new InsightError(); } let applytoken: string = Object.keys(criteria)[0]; if (!this.mtoken.includes(applytoken) &amp;&amp; !this.mstoken.includes(applytok</text><text x="0" y="4155"  fill="rgb(255 255 255)">en)) { throw new InsightError(); } let key: string[] = criteria[applytoken].split(&quot;_&quot;); if (key.length !== 2) { throw new InsightError(); } if (this.mtoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; this.mfields.includes(key[1]))) { throw new InsightError(); } } else if (this.mstoken.includes(applytoken)) { if (!(this.validateIdstring(key[0]) &amp;&amp; (this.sfields.includes(key[1]) || this.mfields.includes(key[1])))) { throw new InsightError(); } } } } public validateOptions(q: any): void { let keys: any[] = Object.keys(q); for (let key of keys) { if (key !== &quot;COLUMNS&quot; &amp;&amp; key !== &quot;ORDER&quot;) { throw new InsightError(); } } this.validateColumns(q.COLUMNS); if (q.ORDER) { this.validateOrder(q.ORDER); } } private validateColumns(q: any): void { if (!q || q.length &lt; 1) { throw new InsightError(); } for (let mskey o</text><text x="0" y="4160"  fill="rgb(255 255 255)">f q) { if (this.transformationKey.length &gt; 0) { if (!this.transformationKey.includes(mskey)) { throw new InsightError(); } } else { this.validateKey(mskey); } this.keysInQuery.push(mskey); } } private validateOrder(q: any): void { if (Array.isArray(q)) { throw new InsightError(); } else if (typeof q === &quot;string&quot;) { if (!this.keysInQuery.includes(q)) { throw new InsightError(); } } else { if (!q.dir || !q.keys || Object.keys(q).length !== 2) { throw new InsightError(); } if (q.dir !== &quot;UP&quot; &amp;&amp; q.dir !== &quot;DOWN&quot;) { throw new InsightError(); } let keys: any = q.keys; if (!Array.isArray(keys) || keys.length &lt; 1) { throw new InsightError(); } for (let anykey of keys) { if (!this.keysInQuery.includes(anykey)) { throw new InsightError(); } } } } public validateWhere(q: any): void { if (Array.isArray(q)) { throw new InsightError();</text></svg>